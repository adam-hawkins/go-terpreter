<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="generator" content="pandoc" />
          <meta name="author" content="Thorsten Ball" />
              <meta name="date" content="2016-01-01" />
              <title>Writing An Interpreter In Go</title>
      <style type="text/css">code{white-space: pre;}</style>
        <style type="text/css">
    body {
      margin: 40px auto;

      max-width:700px;

      padding: 0 10px;

      font-family: Georgia, serif;
      font-size: 18px;

      line-height: 1.45;
      color: black;
    }

    h1, h2, h3 {
      line-height:1.2;
    }

    pre {
      padding-left:15px;
    }

    .cover {
      text-align: center;
    }

    .cover img {
      max-width: 400px;
    }

    #TOC {
      margin-top: 5em;
    }

    .sourceCode {
      line-height: 1.4;
      font-size: 15px;
    }

    .figure {
      text-align:center;
    }

    .caption {
      font-style:italic;
    }
    </style>
          <style type="text/css">
    a.sourceLine { display: inline-block; line-height: 1.25; }
    a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
    a.sourceLine:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode { white-space: pre; position: relative; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    code.sourceCode { white-space: pre-wrap; }
    a.sourceLine { text-indent: -1em; padding-left: 1em; }
    }
    pre.numberSource a.sourceLine
      { position: relative; left: -4em; }
    pre.numberSource a.sourceLine::before
      { content: attr(data-line-number);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; pointer-events: all; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  }
    @media screen {
    a.sourceLine::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      </style>
                  </head>
  <body>
            <div id="header">
    <div class="cover">
      <img src="./images/html_cover.png">
    </div>
    <h1 class="title">Writing An Interpreter In Go</h1>
            <h2 class="author">Thorsten Ball</h2>
        </div>
            <div id="TOC">
    <h3>Contents</h3>
    <ul>
    <li><a href="#acknowledgments">Acknowledgments</a></li>
    <li><a href="#introduction">Introduction</a><ul>
    <li><a href="#the-monkey-programming-language-interpreter">The Monkey Programming Language &amp; Interpreter</a></li>
    <li><a href="#why-go">Why Go?</a></li>
    <li><a href="#how-to-use-this-book">How to Use this Book</a></li>
    </ul></li>
    <li><a href="#lexing">Lexing</a><ul>
    <li><a href="#lexical-analysis">1.1 - Lexical Analysis</a></li>
    <li><a href="#defining-our-tokens">1.2 - Defining Our Tokens</a></li>
    <li><a href="#the-lexer">1.3 - The Lexer</a></li>
    <li><a href="#extending-our-token-set-and-lexer">1.4 - Extending our Token Set and Lexer</a></li>
    <li><a href="#start-of-a-repl">1.5 - Start of a REPL</a></li>
    </ul></li>
    <li><a href="#parsing">Parsing</a><ul>
    <li><a href="#parsers">2.1 - Parsers</a></li>
    <li><a href="#why-not-a-parser-generator">2.2 - Why not a parser generator?</a></li>
    <li><a href="#writing-a-parser-for-the-monkey-programming-language">2.3 - Writing a Parser for the Monkey Programming Language</a></li>
    <li><a href="#parsers-first-steps-parsing-let-statements">2.4 - Parser’s first steps: parsing let statements</a></li>
    <li><a href="#parsing-return-statements">2.5 - Parsing Return Statements</a></li>
    <li><a href="#parsing-expressions">2.6 - Parsing Expressions</a><ul>
    <li><a href="#expressions-in-monkey">Expressions in Monkey</a></li>
    <li><a href="#top-down-operator-precedence-or-pratt-parsing">Top Down Operator Precedence (or: Pratt Parsing)</a></li>
    <li><a href="#terminology">Terminology</a></li>
    <li><a href="#preparing-the-ast">Preparing the AST</a></li>
    <li><a href="#implementing-the-pratt-parser">Implementing the Pratt Parser</a></li>
    <li><a href="#identifiers">Identifiers</a></li>
    <li><a href="#integer-literals">Integer Literals</a></li>
    <li><a href="#prefix-operators">Prefix Operators</a></li>
    <li><a href="#infix-operators">Infix Operators</a></li>
    </ul></li>
    <li><a href="#how-pratt-parsing-works">2.7 - How Pratt Parsing Works</a></li>
    <li><a href="#extending-the-parser">2.8 - Extending the Parser</a><ul>
    <li><a href="#boolean-literals">Boolean Literals</a></li>
    <li><a href="#grouped-expressions">Grouped Expressions</a></li>
    <li><a href="#if-expressions">If Expressions</a></li>
    <li><a href="#function-literals">Function Literals</a></li>
    <li><a href="#call-expressions">Call Expressions</a></li>
    <li><a href="#removing-todos">Removing TODOs</a></li>
    </ul></li>
    <li><a href="#read-parse-print-loop">2.9 - Read-Parse-Print-Loop</a></li>
    </ul></li>
    <li><a href="#evaluation">Evaluation</a><ul>
    <li><a href="#giving-meaning-to-symbols">3.1 - Giving Meaning to Symbols</a></li>
    <li><a href="#strategies-of-evaluation">3.2 - Strategies of Evaluation</a></li>
    <li><a href="#a-tree-walking-interpreter">3.3 - A Tree-Walking Interpreter</a></li>
    <li><a href="#representing-objects">3.4 - Representing Objects</a><ul>
    <li><a href="#foundation-of-our-object-system">Foundation of our Object System</a></li>
    <li><a href="#integers">Integers</a></li>
    <li><a href="#booleans">Booleans</a></li>
    <li><a href="#null">Null</a></li>
    </ul></li>
    <li><a href="#evaluating-expressions">3.5 - Evaluating Expressions</a><ul>
    <li><a href="#integer-literals-1">Integer Literals</a></li>
    <li><a href="#completing-the-repl">Completing the REPL</a></li>
    <li><a href="#boolean-literals-1">Boolean Literals</a></li>
    <li><a href="#null-1">Null</a></li>
    <li><a href="#prefix-expressions">Prefix Expressions</a></li>
    <li><a href="#infix-expressions">Infix Expressions</a></li>
    </ul></li>
    <li><a href="#conditionals">3.6 - Conditionals</a></li>
    <li><a href="#return-statements">3.7 - Return Statements</a></li>
    <li><a href="#abort-abort-theres-been-a-mistake-or-error-handling">3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling</a></li>
    <li><a href="#bindings-the-environment">3.9 - Bindings &amp; The Environment</a></li>
    <li><a href="#functions-function-calls">3.10 - Functions &amp; Function Calls</a></li>
    <li><a href="#whos-taking-the-trash-out">3.11 - Who’s taking the trash out?</a></li>
    </ul></li>
    <li><a href="#extending-the-interpreter">Extending the Interpreter</a><ul>
    <li><a href="#data-types-functions">4.1 - Data Types &amp; Functions</a></li>
    <li><a href="#strings">4.2 - Strings</a><ul>
    <li><a href="#supporting-strings-in-our-lexer">Supporting Strings in our Lexer</a></li>
    <li><a href="#parsing-strings">Parsing Strings</a></li>
    <li><a href="#evaluating-strings">Evaluating Strings</a></li>
    <li><a href="#string-concatenation">String Concatenation</a></li>
    </ul></li>
    <li><a href="#built-in-functions">4.3 - Built-in Functions</a><ul>
    <li><a href="#len">len</a></li>
    </ul></li>
    <li><a href="#array">4.4 - Array</a><ul>
    <li><a href="#supporting-arrays-in-our-lexer">Supporting Arrays in our Lexer</a></li>
    <li><a href="#parsing-array-literals">Parsing Array Literals</a></li>
    <li><a href="#parsing-index-operator-expressions">Parsing Index Operator Expressions</a></li>
    <li><a href="#evaluating-array-literals">Evaluating Array Literals</a></li>
    <li><a href="#evaluating-index-operator-expressions">Evaluating Index Operator Expressions</a></li>
    <li><a href="#adding-built-in-functions-for-arrays">Adding Built-in Functions for Arrays</a></li>
    <li><a href="#test-driving-arrays">Test-Driving Arrays</a></li>
    </ul></li>
    <li><a href="#hashes">4.5 - Hashes</a><ul>
    <li><a href="#lexing-hash-literals">Lexing Hash Literals</a></li>
    <li><a href="#parsing-hash-literals">Parsing Hash Literals</a></li>
    <li><a href="#hashing-objects">Hashing Objects</a></li>
    <li><a href="#evaluating-hash-literals">Evaluating Hash Literals</a></li>
    <li><a href="#evaluating-index-expressions-with-hashes">Evaluating Index Expressions With Hashes</a></li>
    </ul></li>
    <li><a href="#the-grand-finale">4.6 - The Grand Finale</a></li>
    </ul></li>
    <li><a href="#going-further">Going Further</a><ul>
    <li><a href="#the-lost-chapter">The Lost Chapter</a></li>
    <li><a href="#writing-a-compiler-in-go">Writing A Compiler In Go</a></li>
    </ul></li>
    <li><a href="#resources">Resources</a></li>
    <li><a href="#feedback">Feedback</a></li>
    <li><a href="#changelog">Changelog</a></li>
    </ul>
    </div>
        <h1 id="acknowledgments" class="unnumbered">Acknowledgments</h1>
<p>I want to use these lines to express my gratitude to my wife for supporting me. She’s the reason you’re reading this. This book wouldn’t exist without her encouragement, faith in me, assistance and her willingness to listen to my mechanical keyboard clacking away at 6am.</p>
<p>Thanks to my friends Christian, Felix and Robin for reviewing early versions of this book and providing me with invaluable feedback, advice and cheers. You improved this book more than you can imagine.</p>
<h1 id="introduction" class="unnumbered">Introduction</h1>
<p>The first sentence of this introduction was supposed to be this one: “Interpreters are magical”. But one of the earliest reviewers, who wishes to remain anonymous, said that “sounds super stupid”. Well, Christian, I don’t think so! I still think that interpreters <em>are</em> magical! Let me tell you why.</p>
<p>On the surface they look deceptively simple: text goes in and something comes out. They are programs that take other programs as their input and produce something. Simple, right? But the more you think about it, the more fascinating it becomes. Seemingly random characters - letters, numbers and special characters - are fed into the interpreter and suddenly become <strong>meaningful</strong>. The interpreter gives them meaning! It makes sense out of nonsense. And the computer, a machine that’s built on understanding ones and zeroes, now understands and acts upon this weird language we feed into it - thanks to an interpreter that translates this language while reading it.</p>
<p>I kept asking myself: <em>how does this work?</em> And the first time this question began forming in my mind, I already knew that I’ll only be satisfied with an answer if I get to it by writing my own interpreter. So I set out to do so.</p>
<p>A lot of books, articles, blog posts and tutorials on interpreters exist. Most of the time, though, they fall into one of two categories. Either they are huge, incredibly heavy on theory and more targeted towards people who already have a vast understanding of the topic, or they are really short, provide just a small introduction to the topic, use external tools as black boxes and only concern themselves with “toy interpreters”.</p>
<p>One of the main sources of frustration was this latter category of resources, because the interpreters they explain only interpret languages with a really simple syntax. I didn’t want to take a shortcut! I truly wanted to understand how interpreters work and that included understanding how lexers and parsers work. Especially with a C-like language and its curly braces and semicolons, where I didn’t even know how to start parsing them. The academic textbooks had the answers I was looking for, of course. But rather inaccessible to me, behind their lengthy, theoretical explanations and mathematical notation.</p>
<p>What I wanted was something between the 900 page book on compilers and the blog post that explains how to write a Lisp interpreter in 50 lines of Ruby code.</p>
<p>So I wrote this book, for you and me. This is the book I wish I had. This is a book for people who love to look under the hood. For people that love to learn by understanding how something really works.</p>
<p>In this book we’re going to write our own interpreter for our own programming language - from scratch. We won’t be using any 3rd party tools and libraries. The result won’t be production-ready, it won’t have the performance of a fully-fledged interpreter and, of course, the language it’s built to interpret will be missing features. But we’re going to learn a lot.</p>
<p>It’s difficult to make generic statements about interpreters since the variety is so high and none are alike. What can be said is that the one fundamental attribute they all share is that they take source code and evaluate it without producing some visible, intermediate result that can later be executed. That’s in contrast to compilers, which take source code and produce output in another language that the underlying system can understand.</p>
<p>Some interpreters are really small, tiny, and do not even bother with a parsing step. They just interpret the input right away. Look at one of the many Brainfuck interpreters out there to see what I mean.</p>
<p>On the other end of the spectrum are much more elaborate types of interpreters. Highly optimized and using advanced parsing and evaluation techniques. Some of them don’t just evaluate their input, but compile it into an internal representation called bytecode and then evaluate this. Even more advanced are JIT interpreters that compile the input just-in-time into native machine code that gets then executed.</p>
<p>But then, in between those two categories, there are interpreters that parse the source code, build an abstract syntax tree (AST) out of it and then evaluate this tree. This type of interpreter is sometimes called “tree-walking” interpreter, because it “walks” the AST and interprets it.</p>
<p>What we will be building in this book is such a tree-walking interpreter.</p>
<p>We’re going to build our own lexer, our own parser, our own tree representation and our own evaluator. We’ll see what “tokens” are, what an abstract syntax tree is, how to build such a tree, how to evaluate it and how to extend our language with new data structures and built-in functions.</p>
<h2 id="the-monkey-programming-language-interpreter">The Monkey Programming Language &amp; Interpreter</h2>
<p>Every interpreter is built to interpret a specific programming language. That’s how you “implement” a programming language. Without a compiler or an interpreter a programming language is nothing more than an idea or a specification.</p>
<p>We’re going to parse and evaluate our own language called Monkey. It’s a language specifically designed for this book. Its only implementation is the one we’re going to build in this book - our interpreter.</p>
<p>Expressed as a list of features, Monkey has the following:</p>
<ul>
<li>C-like syntax</li>
<li>variable bindings</li>
<li>integers and booleans</li>
<li>arithmetic expressions</li>
<li>built-in functions</li>
<li>first-class and higher-order functions</li>
<li>closures</li>
<li>a string data structure</li>
<li>an array data structure</li>
<li>a hash data structure</li>
</ul>
<p>We’re going to take a detailed look at and implement each of these features in the rest of this book. But for now, let’s see what Monkey looks like.</p>
<p>Here is how we bind values to names in Monkey:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">let</span> age <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">let</span> name <span class="op">=</span> <span class="st">&quot;Monkey&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">let</span> result <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> (<span class="dv">20</span> / <span class="dv">2</span>)<span class="op">;</span></a></code></pre></div>
<p>Besides integers, booleans and strings, the Monkey interpreter we’re going to build will also support arrays and hashes. Here’s what binding an array of integers to a name looks like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">let</span> myArray <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></a></code></pre></div>
<p>And here is a hash, where values are associated with keys:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">let</span> thorsten <span class="op">=</span> <span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Thorsten&quot;</span><span class="op">,</span> <span class="st">&quot;age&quot;</span><span class="op">:</span> <span class="dv">28</span><span class="op">};</span></a></code></pre></div>
<p>Accessing the elements in arrays and hashes is done with index expressions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" data-line-number="1">myArray[<span class="dv">0</span>]       <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">thorsten[<span class="st">&quot;name&quot;</span>] <span class="co">// =&gt; &quot;Thorsten&quot;</span></a></code></pre></div>
<p>The <code>let</code> statements can also be used to bind functions to names. Here’s a small function that adds two numbers:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(a<span class="op">,</span> b) <span class="op">{</span> <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">};</span></a></code></pre></div>
<p>But Monkey not only supports <code>return</code> statements. Implicit return values are also possible, which means we can leave out the <code>return</code> if we want to:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(a<span class="op">,</span> b) <span class="op">{</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">};</span></a></code></pre></div>
<p>And calling a function is as easy as you’d expect:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></a></code></pre></div>
<p>A more complex function, such as a <code>fibonacci</code> function that returns the Nth Fibonacci number, might look like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">let</span> fibonacci <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="cf">if</span> (x <span class="op">==</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="cf">if</span> (x <span class="op">==</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="at">fibonacci</span>(x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="at">fibonacci</span>(x <span class="op">-</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="op">};</span></a></code></pre></div>
<p>Note the recursive calls to <code>fibonacci</code> itself!</p>
<p>Monkey also supports a special type of functions, called higher order functions. These are functions that take other functions as arguments. Here is an example:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">let</span> twice <span class="op">=</span> <span class="at">fn</span>(f<span class="op">,</span> x) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="cf">return</span> <span class="at">f</span>(<span class="at">f</span>(x))<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">let</span> addTwo <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="cf">return</span> x <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="at">twice</span>(addTwo<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span> <span class="co">// =&gt; 6</span></a></code></pre></div>
<p>Here <code>twice</code> takes two arguments: another function called <code>addTwo</code> and the integer <code>2</code>. It calls <code>addTwo</code> two times with first <code>2</code> as argument and then with the return value of the first call. The last line produces <code>6</code>.</p>
<p>Yes, we can use functions as arguments in function calls. Functions in Monkey are just values, like integers or strings. That feature is called “first class functions”.</p>
<p>The interpreter we’re going to build in this book will implement all these features. It will tokenize and parse Monkey source code in a REPL, building up an internal representation of the code called abstract syntax tree and then evaluate this tree. It will have a few major parts:</p>
<ul>
<li>the lexer</li>
<li>the parser</li>
<li>the Abstract Syntax Tree (AST)</li>
<li>the internal object system</li>
<li>the evaluator</li>
</ul>
<p>We’re going to build these parts in exactly this order, from the bottom up. Or better put: starting with the source code and ending with the output. The drawback of this approach is that it won’t produce a simple “Hello World” after the first chapter. The advantage is that it’s easier to understand how all the pieces fit together and how the data flows through the program.</p>
<p>But why the name? Why is it called “Monkey”? Well, because monkeys are magnificent, elegant, fascinating and funny creatures. Exactly like our interpreter.</p>
<p>And why the name of the book?</p>
<h2 id="why-go">Why Go?</h2>
<p>If you read this far without noticing the title and the words “in Go” in it, first of all: congratulations, that’s pretty remarkable. And second: we will write our interpreter in Go. Why Go?</p>
<p>I like writing code in Go. I enjoy using the language, its standard library and the tools it provides. But other than that I think that Go is in possession of a few attributes that make it a great fit for this particular book.</p>
<p>Go is really easy to read and subsequently understand. You won’t need to decipher the Go code I present to you in this book. Even if you are not an experienced Go programmer. I’d bet that you can follow this book along even if you’ve never written a single line of Go in your life.</p>
<p>Another reason is the great tooling Go provides. The focus of this book is the interpreter we are writing - the ideas and concepts behind it and its implementation. With Go’s universal formatting style thanks to <code>gofmt</code> and a testing framework built-in, we can concentrate on our interpreter and not worry about 3rd party libraries, tools and dependencies. We won’t be using any other tools in this book other than the ones provided by the Go programming language.</p>
<p>But I think much more important is that the Go code presented in this book maps closely to other and possibly more low-level languages, like C, C++ and Rust. Maybe the reason for this is Go itself, with its focus on simplicity, its stripped-down charm and lack of programming language constructs that are absent in other languages and hard to translate. Or maybe it’s because of the way I chose to write Go for this book. Either way, there won’t be any meta-programming tricks to take a shortcut that nobody understands anymore after two weeks and no grandiose object-oriented designs and patterns that need pen, paper and the sentence “actually, it’s pretty easy” to explain.</p>
<p>All of these reasons make the code presented here easy to understand (on a conceptual as well as a technical level) and reusable for you. And if you, after reading this book, choose to write your own interpreter in another language this should come in handy. With this book I want to provide a starting point in your understanding and construction of interpreters and I think the code reflects that.</p>
<h2 id="how-to-use-this-book">How to Use this Book</h2>
<p>This book is neither a reference, nor is it a theory-laden paper describing concepts of interpreter implementation with code in the appendix. This book is meant to be read from start to finish and I recommend that you follow along by reading, typing out and modifying the presented code.</p>
<p>Each chapter builds upon its predecessor - in code and in prose. And in each chapter we build another part of our interpreter, piece by piece. To make it easier to follow along, the book comes with a folder called <code>code</code>, that contains, well, code. If your copy of the book came without the folder, you can download it here:</p>
<p><a href="https://interpreterbook.com/waiig_code_1.5.zip" class="uri">https://interpreterbook.com/waiig_code_1.5.zip</a></p>
<p>The <code>code</code> folder is divided into several subfolders, with one for each chapter, containing the final result of the corresponding chapter.</p>
<p>Sometimes I’ll only allude to something being in the code, without showing the code itself (because either it would take up too much space, as is the case with the test files, or it is just some detail) - you can find this code in the folder accompanying the chapter, too.</p>
<p>Which tools do you need to follow along? Not much: a text editor and the Go programming language. Any Go version above 1.0 should work, but just as a disclaimer and for future generations: at the time of writing I’m using Go 1.7.</p>
<p>I also recommend using <a href="http://direnv.net/">direnv</a>, which can change the environment of your shell according to an <code>.envrc</code> file. Each sub-folder in the code folder accompanying this book contains such an <code>.envrc</code> file that sets the <code>GOPATH</code> correctly for this sub-folder. That allows us to easily work with the code of different chapters.</p>
<p>And with that out of the way, let’s get started!</p>
<h1 id="lexing">Lexing</h1>
<h2 id="lexical-analysis">1.1 - Lexical Analysis</h2>
<p>In order for us to work with source code we need to turn it into a more accessible form. As easy as plain text is to work with in our editor, it becomes cumbersome pretty fast when trying to interpret it in a programming language as another programming language.</p>
<p>So, what we need to do is represent our source code in other forms that <strong>are</strong> easier to work with. We’re going to change the representation of our source code two times before we evaluate it:</p>
<figure>
<img src="./images/source_code_tokens_ast.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>The first transformation, from source code to tokens, is called “lexical analysis”, or “lexing” for short. It’s done by a lexer (also called tokenizer or scanner – some use one word or the other to denote subtle differences in behaviour, which we can ignore in this book).</p>
<p>Tokens themselves are small, easily categorizable data structures that are then fed to the parser, which does the second transformation and turns the tokens into an “Abstract Syntax Tree”.</p>
<p>Here’s an example. This is the input one gives to a lexer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="st">&quot;let x = 5 + 5;&quot;</span></a></code></pre></div>
<p>And what comes out of the lexer looks kinda like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" data-line-number="1">[</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  LET<span class="op">,</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="at">IDENTIFIER</span>(<span class="st">&quot;x&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  EQUAL_SIGN<span class="op">,</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="at">INTEGER</span>(<span class="dv">5</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  PLUS_SIGN<span class="op">,</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="at">INTEGER</span>(<span class="dv">5</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  SEMICOLON</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">]</a></code></pre></div>
<p>All of these tokens have the original source code representation attached. <code>&quot;let&quot;</code> in the case of <code>LET</code>, <code>&quot;+&quot;</code> in the case of <code>PLUS_SIGN</code>, and so on. Some, like <code>IDENTIFIER</code> and <code>INTEGER</code> in our example, also have the concrete values they represent attached: <code>5</code> (not <code>&quot;5&quot;</code>!) in the case of <code>INTEGER</code> and <code>&quot;x&quot;</code> in the case of <code>IDENTIFIER</code>. But what exactly constitutes a “token” varies between different lexer implementations. As an example, some lexers only convert the <code>&quot;5&quot;</code> to an integer in the parsing stage, or even later, and not when constructing tokens.</p>
<p>A thing to note about this example: whitespace characters don’t show up as tokens. In our case that’s okay, because whitespace length is not significant in the Monkey language. Whitespace merely acts as a separator for other tokens. It doesn’t matter if we type this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>Or if we type this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">let</span>   x   <span class="op">=</span>   <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>In other languages, like Python, the length of whitespace <em>is</em> significant. That means the lexer can’t just “eat up” the whitespace and newline characters. It has to output the whitespace characters as tokens so the parser can later on make sense of them (or output an error, of course, if there are not enough or too many).</p>
<p>A production-ready lexer might also attach the line number, column number and filename to a token. Why? For example, to later output more useful error messages in the parsing stage. Instead of <code>&quot;error: expected semicolon token&quot;</code> it can output:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb14-1" data-line-number="1">&quot;error: expected semicolon token. line 42, column 23, program.monkey&quot;</a></code></pre></div>
<p>We’re not going to bother with that. Not because it’s too complex, but because it would take away from the essential simpleness of the tokens and the lexer, making it harder to understand.</p>
<h2 id="defining-our-tokens">1.2 - Defining Our Tokens</h2>
<p>The first thing we have to do is to define the tokens our lexer is going to output. We’re going to start with just a few token definitions and then add more when extending the lexer.</p>
<p>The subset of the Monkey language we’re going to lex in our first step looks like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">let</span> five <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">let</span> ten <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  x <span class="op">+</span> y<span class="op">;</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="op">};</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">let</span> result <span class="op">=</span> <span class="at">add</span>(five<span class="op">,</span> ten)<span class="op">;</span></a></code></pre></div>
<p>Let’s break this down: which types of tokens does this example contain? First of all, there are the numbers like <code>5</code> and <code>10</code>. These are pretty obvious. Then we have the variable names <code>x</code>, <code>y</code>, <code>add</code> and <code>result</code>. And then there are also these parts of the language that are not numbers, just words, but no variable names either, like <code>let</code> and <code>fn</code>. Of course, there are also a lot of special characters: <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>=</code>, <code>,</code>, <code>;</code>.</p>
<p>The numbers are just integers and we’re going to treat them as such and give them a separate type. In the lexer or parser we don’t care if the number is <code>5</code> or <code>10</code>, we just want to know if it’s a number. The same goes for “variable names”: we’ll call them “identifiers” and treat them the same. Now, the other words, the ones that look like identifiers, but aren’t really identifiers, since they’re part of the language, are called “keywords”. We won’t group these together since it <strong>should</strong> make a difference in the parsing stage whether we encounter a <code>let</code> or a <code>fn</code>. The same goes for the last category we identified: the special characters. We’ll treat each of them separately, since it is a big difference whether or not we have a <code>(</code> or a <code>)</code> in the source code.</p>
<p>Let’s define our <code>Token</code> data structure. Which fields does it need? As we just saw, we definitely need a “type” attribute, so we can distinguish between “integers” and “right bracket” for example. And it also needs a field that holds the literal value of the token, so we can reuse it later and the information whether a “number” token is a <code>5</code> or a <code>10</code> doesn’t get lost.</p>
<p>In a new <code>token</code> package we define our <code>Token</code> struct and our <code>TokenType</code> type:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">package</span> token</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">type</span> TokenType <span class="dt">string</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="kw">type</span> Token <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    Type    TokenType</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    Literal <span class="dt">string</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">}</a></code></pre></div>
<p>We defined the <code>TokenType</code> type to be a <code>string</code>. That allows us to use many different values as <code>TokenType</code>s, which in turn allows us to distinguish between different types of tokens. Using <code>string</code> also has the advantage of being easy to debug without a lot of boilerplate and helper functions: we can just print a <code>string</code>. Of course, using a <code>string</code> might not lead to the same performance as using an <code>int</code> or a <code>byte</code> would, but for this book a <code>string</code> is perfect.</p>
<p>As we just saw, there is a limited number of different token types in the Monkey language. That means we can define the possible <code>TokenType</code>s as constants. In the same file we add this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    ILLEGAL = <span class="st">&quot;ILLEGAL&quot;</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    EOF     = <span class="st">&quot;EOF&quot;</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    <span class="co">// Identifiers + literals</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    IDENT = <span class="st">&quot;IDENT&quot;</span> <span class="co">// add, foobar, x, y, ...</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">    INT   = <span class="st">&quot;INT&quot;</span>   <span class="co">// 1343456</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    <span class="co">// Operators</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    ASSIGN   = <span class="st">&quot;=&quot;</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">    PLUS     = <span class="st">&quot;+&quot;</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">    <span class="co">// Delimiters</span></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">    COMMA     = <span class="st">&quot;,&quot;</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">    SEMICOLON = <span class="st">&quot;;&quot;</span></a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">    LPAREN = <span class="st">&quot;(&quot;</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">    RPAREN = <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    LBRACE = <span class="st">&quot;{&quot;</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">    RBRACE = <span class="st">&quot;}&quot;</span></a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">    <span class="co">// Keywords</span></a>
<a class="sourceLine" id="cb17-25" data-line-number="25">    FUNCTION = <span class="st">&quot;FUNCTION&quot;</span></a>
<a class="sourceLine" id="cb17-26" data-line-number="26">    LET      = <span class="st">&quot;LET&quot;</span></a>
<a class="sourceLine" id="cb17-27" data-line-number="27">)</a></code></pre></div>
<p>As you can see there are two special types: <code>ILLEGAL</code> and <code>EOF</code>. We didn’t see them in the example above, but we’ll need them. <code>ILLEGAL</code> signifies a token/character we don’t know about and <code>EOF</code> stands for “end of file”, which tells our parser later on that it can stop.</p>
<p>So far so good! We are ready to start writing our lexer.</p>
<h2 id="the-lexer">1.3 - The Lexer</h2>
<p>Before we start to write code, let’s be clear about the goal of this section. We’re going to write our own lexer. It will take source code as input and output the tokens that represent the source code. It will go through its input and output the next token it recognizes. It doesn’t need to buffer or save tokens, since there will only be one method called <code>NextToken()</code>, which will output the next token.</p>
<p>That means, we’ll initialize the lexer with our source code and then repeatedly call <code>NextToken()</code> on it to go through the source code, token by token, character by character. We’ll also make life simpler here by using <code>string</code> as the type for our source code. Again: in a production environment it makes sense to attach filenames and line numbers to tokens, to better track down lexing and parsing errors. So it would be better to initialize the lexer with an <code>io.Reader</code> and the filename. But since that would add more complexity we’re not here to handle, we’ll start small and just use a <code>string</code> and ignore filenames and line numbers.</p>
<p>Having thought this through, we now realize that what our lexer needs to do is pretty clear. So let’s create a new package and add a first test that we can continuously run to get feedback about the working state of the lexer. We’re starting small here and will extend the test case as we add more capabilities to the lexer:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">package</span> lexer</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">    <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">    input := <span class="st">`=+(){},;`</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        expectedType    token.TokenType</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">        expectedLiteral <span class="dt">string</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">    }{</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">        {token.ASSIGN, <span class="st">&quot;=&quot;</span>},</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">        {token.PLUS, <span class="st">&quot;+&quot;</span>},</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">        {token.LPAREN, <span class="st">&quot;(&quot;</span>},</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">        {token.RPAREN, <span class="st">&quot;)&quot;</span>},</a>
<a class="sourceLine" id="cb18-22" data-line-number="22">        {token.LBRACE, <span class="st">&quot;{&quot;</span>},</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">        {token.RBRACE, <span class="st">&quot;}&quot;</span>},</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">        {token.COMMA, <span class="st">&quot;,&quot;</span>},</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">        {token.EOF, <span class="st">&quot;&quot;</span>},</a>
<a class="sourceLine" id="cb18-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb18-28" data-line-number="28"></a>
<a class="sourceLine" id="cb18-29" data-line-number="29">    l := New(input)</a>
<a class="sourceLine" id="cb18-30" data-line-number="30"></a>
<a class="sourceLine" id="cb18-31" data-line-number="31">    <span class="kw">for</span> i, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb18-32" data-line-number="32">        tok := l.NextToken()</a>
<a class="sourceLine" id="cb18-33" data-line-number="33"></a>
<a class="sourceLine" id="cb18-34" data-line-number="34">        <span class="kw">if</span> tok.Type != tt.expectedType {</a>
<a class="sourceLine" id="cb18-35" data-line-number="35">            t.Fatalf(<span class="st">&quot;tests[%d] - tokentype wrong. expected=%q, got=%q&quot;</span>,</a>
<a class="sourceLine" id="cb18-36" data-line-number="36">                i, tt.expectedType, tok.Type)</a>
<a class="sourceLine" id="cb18-37" data-line-number="37">        }</a>
<a class="sourceLine" id="cb18-38" data-line-number="38"></a>
<a class="sourceLine" id="cb18-39" data-line-number="39">        <span class="kw">if</span> tok.Literal != tt.expectedLiteral {</a>
<a class="sourceLine" id="cb18-40" data-line-number="40">            t.Fatalf(<span class="st">&quot;tests[%d] - literal wrong. expected=%q, got=%q&quot;</span>,</a>
<a class="sourceLine" id="cb18-41" data-line-number="41">                i, tt.expectedLiteral, tok.Literal)</a>
<a class="sourceLine" id="cb18-42" data-line-number="42">        }</a>
<a class="sourceLine" id="cb18-43" data-line-number="43">    }</a>
<a class="sourceLine" id="cb18-44" data-line-number="44">}</a></code></pre></div>
<p>Of the course, the tests fail – we haven’t written any code yet:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb19-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"># monkey/lexer</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">lexer/lexer_test.go:27: undefined: New</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">FAIL    monkey/lexer [build failed]</a></code></pre></div>
<p>So let’s start by defining the <code>New()</code> function that returns <code>*Lexer</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">package</span> lexer</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">type</span> Lexer <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    input        <span class="dt">string</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    position     <span class="dt">int</span>  <span class="co">// current position in input (points to current char)</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    readPosition <span class="dt">int</span>  <span class="co">// current reading position in input (after current char)</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    ch           <span class="dt">byte</span> <span class="co">// current char under examination</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb20-10" data-line-number="10"></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="kw">func</span> New(input <span class="dt">string</span>) *Lexer {</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    l := &amp;Lexer{input: input}</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">    <span class="kw">return</span> l</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">}</a></code></pre></div>
<p>Most of the fields in <code>Lexer</code> are pretty self-explanatory. The ones that might cause some confusion right now are <code>position</code> and <code>readPosition</code>. Both will be used to access characters in <code>input</code> by using them as an index, e.g.: <code>l.input[l.readPosition]</code>. The reason for these two “pointers” pointing into our input string is the fact that we will need to be able to “peek” further into the input and look after the current character to see what comes up next. <code>readPosition</code> always points to the “next” character in the input. <code>position</code> points to the character in the input that corresponds to the <code>ch</code> byte.</p>
<p>A first helper method called <code>readChar()</code> should make the usage of these fields easier to understand:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) readChar() {</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="kw">if</span> l.readPosition &gt;= <span class="bu">len</span>(l.input) {</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        l.ch = <span class="dv">0</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        l.ch = l.input[l.readPosition]</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    l.position = l.readPosition</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    l.readPosition += <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">}</a></code></pre></div>
<p>The purpose of <code>readChar</code> is to give us the next character and advance our position in the <code>input</code> string. The first thing it does is to check whether we have reached the end of <code>input</code>. If that’s the case it sets <code>l.ch</code> to <code>0</code>, which is the ASCII code for the <code>&quot;NUL&quot;</code> character and signifies either “we haven’t read anything yet” or “end of file” for us. But if we haven’t reached the end of <code>input</code> yet it sets <code>l.ch</code> to the next character by accessing <code>l.input[l.readPosition]</code>.</p>
<p>After that <code>l.position</code> is updated to the just used <code>l.readPosition</code> and <code>l.readPosition</code> is incremented by one. That way, <code>l.readPosition</code> always points to the next position where we’re going to read from next and <code>l.position</code> always points to the position where we last read. This will come in handy soon enough.</p>
<p>While talking about <code>readChar</code> it’s worth pointing out that the lexer only supports ASCII characters instead of the full Unicode range. Why? Because this lets us keep things simple and concentrate on the essential parts of our interpreter. In order to fully support Unicode and UTF-8 we would need to change <code>l.ch</code> from a <code>byte</code> to <code>rune</code> and change the way we read the next characters, since they could be multiple bytes wide now. Using <code>l.input[l.readPosition]</code> wouldn’t work anymore. And then we’d also need to change a few other methods and functions we’ll see later on. So it’s left as an exercise to the reader to fully support Unicode (and emojis!) in Monkey.</p>
<p>Let’s use <code>readChar</code> in our <code>New()</code> function so our <code>*Lexer</code> is in a fully working state before anyone calls <code>NextToken()</code>, with <code>l.ch</code>, <code>l.position</code> and <code>l.readPosition</code> already initialized:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">func</span> New(input <span class="dt">string</span>) *Lexer {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    l := &amp;Lexer{input: input}</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    l.readChar()</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    <span class="kw">return</span> l</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">}</a></code></pre></div>
<p>Our tests now tell us that calling <code>New(input)</code> doesn’t result in problems anymore, but the <code>NextToken()</code> method is still missing. Let’s fix that by adding a first version:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="kw">package</span> lexer</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">import</span> <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    <span class="kw">var</span> tok token.Token</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    <span class="kw">case</span> <span class="ch">&#39;=&#39;</span>:</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">        tok = newToken(token.ASSIGN, l.ch)</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    <span class="kw">case</span> <span class="ch">&#39;;&#39;</span>:</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">        tok = newToken(token.SEMICOLON, l.ch)</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    <span class="kw">case</span> <span class="ch">&#39;(&#39;</span>:</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        tok = newToken(token.LPAREN, l.ch)</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">    <span class="kw">case</span> <span class="ch">&#39;)&#39;</span>:</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">        tok = newToken(token.RPAREN, l.ch)</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">    <span class="kw">case</span> <span class="ch">&#39;,&#39;</span>:</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">        tok = newToken(token.COMMA, l.ch)</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    <span class="kw">case</span> <span class="ch">&#39;+&#39;</span>:</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">        tok = newToken(token.PLUS, l.ch)</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">    <span class="kw">case</span> <span class="ch">&#39;{&#39;</span>:</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">        tok = newToken(token.LBRACE, l.ch)</a>
<a class="sourceLine" id="cb23-25" data-line-number="25">    <span class="kw">case</span> <span class="ch">&#39;}&#39;</span>:</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">        tok = newToken(token.RBRACE, l.ch)</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">    <span class="kw">case</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">        tok.Literal = <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-29" data-line-number="29">        tok.Type = token.EOF</a>
<a class="sourceLine" id="cb23-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb23-31" data-line-number="31"></a>
<a class="sourceLine" id="cb23-32" data-line-number="32">    l.readChar()</a>
<a class="sourceLine" id="cb23-33" data-line-number="33">    <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb23-34" data-line-number="34">}</a>
<a class="sourceLine" id="cb23-35" data-line-number="35"></a>
<a class="sourceLine" id="cb23-36" data-line-number="36"><span class="kw">func</span> newToken(tokenType token.TokenType, ch <span class="dt">byte</span>) token.Token {</a>
<a class="sourceLine" id="cb23-37" data-line-number="37">    <span class="kw">return</span> token.Token{Type: tokenType, Literal: <span class="dt">string</span>(ch)}</a>
<a class="sourceLine" id="cb23-38" data-line-number="38">}</a></code></pre></div>
<p>That’s the basic structure of the <code>NextToken()</code> method. We look at the current character under examination (<code>l.ch</code>) and return a token depending on which character it is. Before returning the token we advance our pointers into the input so when we call <code>NextToken()</code> again the <code>l.ch</code> field is already updated. A small function called <code>newToken</code> helps us with initializing these tokens.</p>
<p>Running the tests we can see that they pass:</p>
<pre><code>$ go test ./lexer
ok      monkey/lexer 0.007s</code></pre>
<p>Great! Let’s now extend the test case so it starts to resemble Monkey source code.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"></a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12"><span class="st">`</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        expectedType    token.TokenType</a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        expectedLiteral <span class="dt">string</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">    }{</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">        {token.LET, <span class="st">&quot;let&quot;</span>},</a>
<a class="sourceLine" id="cb25-19" data-line-number="19">        {token.IDENT, <span class="st">&quot;five&quot;</span>},</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">        {token.ASSIGN, <span class="st">&quot;=&quot;</span>},</a>
<a class="sourceLine" id="cb25-21" data-line-number="21">        {token.INT, <span class="st">&quot;5&quot;</span>},</a>
<a class="sourceLine" id="cb25-22" data-line-number="22">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb25-23" data-line-number="23">        {token.LET, <span class="st">&quot;let&quot;</span>},</a>
<a class="sourceLine" id="cb25-24" data-line-number="24">        {token.IDENT, <span class="st">&quot;ten&quot;</span>},</a>
<a class="sourceLine" id="cb25-25" data-line-number="25">        {token.ASSIGN, <span class="st">&quot;=&quot;</span>},</a>
<a class="sourceLine" id="cb25-26" data-line-number="26">        {token.INT, <span class="st">&quot;10&quot;</span>},</a>
<a class="sourceLine" id="cb25-27" data-line-number="27">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb25-28" data-line-number="28">        {token.LET, <span class="st">&quot;let&quot;</span>},</a>
<a class="sourceLine" id="cb25-29" data-line-number="29">        {token.IDENT, <span class="st">&quot;add&quot;</span>},</a>
<a class="sourceLine" id="cb25-30" data-line-number="30">        {token.ASSIGN, <span class="st">&quot;=&quot;</span>},</a>
<a class="sourceLine" id="cb25-31" data-line-number="31">        {token.FUNCTION, <span class="st">&quot;fn&quot;</span>},</a>
<a class="sourceLine" id="cb25-32" data-line-number="32">        {token.LPAREN, <span class="st">&quot;(&quot;</span>},</a>
<a class="sourceLine" id="cb25-33" data-line-number="33">        {token.IDENT, <span class="st">&quot;x&quot;</span>},</a>
<a class="sourceLine" id="cb25-34" data-line-number="34">        {token.COMMA, <span class="st">&quot;,&quot;</span>},</a>
<a class="sourceLine" id="cb25-35" data-line-number="35">        {token.IDENT, <span class="st">&quot;y&quot;</span>},</a>
<a class="sourceLine" id="cb25-36" data-line-number="36">        {token.RPAREN, <span class="st">&quot;)&quot;</span>},</a>
<a class="sourceLine" id="cb25-37" data-line-number="37">        {token.LBRACE, <span class="st">&quot;{&quot;</span>},</a>
<a class="sourceLine" id="cb25-38" data-line-number="38">        {token.IDENT, <span class="st">&quot;x&quot;</span>},</a>
<a class="sourceLine" id="cb25-39" data-line-number="39">        {token.PLUS, <span class="st">&quot;+&quot;</span>},</a>
<a class="sourceLine" id="cb25-40" data-line-number="40">        {token.IDENT, <span class="st">&quot;y&quot;</span>},</a>
<a class="sourceLine" id="cb25-41" data-line-number="41">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb25-42" data-line-number="42">        {token.RBRACE, <span class="st">&quot;}&quot;</span>},</a>
<a class="sourceLine" id="cb25-43" data-line-number="43">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb25-44" data-line-number="44">        {token.LET, <span class="st">&quot;let&quot;</span>},</a>
<a class="sourceLine" id="cb25-45" data-line-number="45">        {token.IDENT, <span class="st">&quot;result&quot;</span>},</a>
<a class="sourceLine" id="cb25-46" data-line-number="46">        {token.ASSIGN, <span class="st">&quot;=&quot;</span>},</a>
<a class="sourceLine" id="cb25-47" data-line-number="47">        {token.IDENT, <span class="st">&quot;add&quot;</span>},</a>
<a class="sourceLine" id="cb25-48" data-line-number="48">        {token.LPAREN, <span class="st">&quot;(&quot;</span>},</a>
<a class="sourceLine" id="cb25-49" data-line-number="49">        {token.IDENT, <span class="st">&quot;five&quot;</span>},</a>
<a class="sourceLine" id="cb25-50" data-line-number="50">        {token.COMMA, <span class="st">&quot;,&quot;</span>},</a>
<a class="sourceLine" id="cb25-51" data-line-number="51">        {token.IDENT, <span class="st">&quot;ten&quot;</span>},</a>
<a class="sourceLine" id="cb25-52" data-line-number="52">        {token.RPAREN, <span class="st">&quot;)&quot;</span>},</a>
<a class="sourceLine" id="cb25-53" data-line-number="53">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb25-54" data-line-number="54">        {token.EOF, <span class="st">&quot;&quot;</span>},</a>
<a class="sourceLine" id="cb25-55" data-line-number="55">    }</a>
<a class="sourceLine" id="cb25-56" data-line-number="56"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb25-57" data-line-number="57">}</a></code></pre></div>
<p>Most notably the <code>input</code> in this test case has changed. It looks like a subset of the Monkey language. It contains all the symbols we already successfully turned into tokens, but also new things that are now causing our tests to fail: identifiers, keywords and numbers.</p>
<p>Let’s start with the identifiers and keywords. What our lexer needs to do is recognize whether the current character is a letter and if so, it needs to read the rest of the identifier/keyword until it encounters a non-letter-character. Having read that identifier/keyword, we then need to find out if it is a identifier or a keyword, so we can use the correct <code>token.TokenType</code>. The first step is extending our switch statement:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="kw">import</span> <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="kw">var</span> tok token.Token</a>
<a class="sourceLine" id="cb26-7" data-line-number="7"></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">        <span class="kw">if</span> isLetter(l.ch) {</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">            tok.Literal = l.readIdentifier()</a>
<a class="sourceLine" id="cb26-13" data-line-number="13">            <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">            tok = newToken(token.ILLEGAL, l.ch)</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">        }</a>
<a class="sourceLine" id="cb26-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb26-18" data-line-number="18"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb26-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb26-20" data-line-number="20"></a>
<a class="sourceLine" id="cb26-21" data-line-number="21"><span class="kw">func</span> (l *Lexer) readIdentifier() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb26-22" data-line-number="22">    position := l.position</a>
<a class="sourceLine" id="cb26-23" data-line-number="23">    <span class="kw">for</span> isLetter(l.ch) {</a>
<a class="sourceLine" id="cb26-24" data-line-number="24">        l.readChar()</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb26-26" data-line-number="26">    <span class="kw">return</span> l.input[position:l.position]</a>
<a class="sourceLine" id="cb26-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb26-28" data-line-number="28"></a>
<a class="sourceLine" id="cb26-29" data-line-number="29"><span class="kw">func</span> isLetter(ch <span class="dt">byte</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb26-30" data-line-number="30">    <span class="kw">return</span> <span class="ch">&#39;a&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="ch">&#39;z&#39;</span> || <span class="ch">&#39;A&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="ch">&#39;Z&#39;</span> || ch == <span class="ch">&#39;_&#39;</span></a>
<a class="sourceLine" id="cb26-31" data-line-number="31">}</a></code></pre></div>
<p>We added a <code>default</code> branch to our switch statement, so we can check for identifiers whenever the <code>l.ch</code> is not one of the recognized characters. We also added the generation of <code>token.ILLEGAL</code> tokens. If we end up there, we truly don’t know how to handle the current character and declare it as <code>token.ILLEGAL</code>.</p>
<p>The <code>isLetter</code> helper function just checks whether the given argument is a letter. That sounds easy enough, but what’s noteworthy about <code>isLetter</code> is that changing this function has a larger impact on the language our interpreter will be able to parse than one would expect from such a small function. As you can see, in our case it contains the check <code>ch == '_'</code>, which means that we’ll treat <code>_</code> as a letter and allow it in identifiers and keywords. That means we can use variable names like <code>foo_bar</code>. Other programming languages even allow <code>!</code> and <code>?</code> in identifiers. If you want to allow that too, this is the place to sneak it in.</p>
<p><code>readIdentifier()</code> does exactly what its name suggests: it reads in an identifier and advances our lexer’s positions until it encounters a non-letter-character.</p>
<p>In the <code>default:</code> branch of the switch statement we use <code>readIdentifier()</code> to set the <code>Literal</code> field of our current token. But what about its <code>Type</code>? Now that we have read identifiers like <code>let</code>, <code>fn</code> or <code>foobar</code>, we need to be able to tell user-defined identifiers apart from language keywords. We need a function that returns the correct <code>TokenType</code> for the token literal we have. What better place than the <code>token</code> package to add such a function?</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">var</span> keywords = <span class="kw">map</span>[<span class="dt">string</span>]TokenType{</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    <span class="st">&quot;fn&quot;</span>:  FUNCTION,</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    <span class="st">&quot;let&quot;</span>: LET,</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="kw">func</span> LookupIdent(ident <span class="dt">string</span>) TokenType {</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">    <span class="kw">if</span> tok, ok := keywords[ident]; ok {</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">        <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    <span class="kw">return</span> IDENT</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">}</a></code></pre></div>
<p><code>LookupIdent</code> checks the <code>keywords</code> table to see whether the given identifier is in fact a keyword. If it is, it returns the keyword’s <code>TokenType</code> constant. If it isn’t, we just get back <code>token.IDENT</code>, which is the <code>TokenType</code> for all user-defined identifiers.</p>
<p>With this in hand we can now complete the lexing of identifiers and keywords:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="kw">var</span> tok token.Token</a>
<a class="sourceLine" id="cb28-5" data-line-number="5"></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">        <span class="kw">if</span> isLetter(l.ch) {</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">            tok.Literal = l.readIdentifier()</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">            tok.Type = token.LookupIdent(tok.Literal)</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">            <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">            tok = newToken(token.ILLEGAL, l.ch)</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">        }</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb28-17" data-line-number="17"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18">}</a></code></pre></div>
<p>The early exit here, our <code>return tok</code> statement, is necessary because when calling <code>readIdentifier()</code>, we call <code>readChar()</code> repeatedly and advance our <code>readPosition</code> and <code>position</code> fields past the last character of the current identifier. So we don’t need the call to <code>readChar()</code> after the switch statement again.</p>
<p>Running our tests now, we can see that <code>let</code> is identified correctly but the tests still fail:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb29-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">--- FAIL: TestNextToken (0.00s)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  lexer_test.go:70: tests[1] - tokentype wrong. expected=&quot;IDENT&quot;, got=&quot;ILLEGAL&quot;</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">FAIL    monkey/lexer 0.008s</a></code></pre></div>
<p>The problem is the next token we want: a <code>IDENT</code> token with <code>&quot;five&quot;</code> in its <code>Literal</code> field. Instead we get an <code>ILLEGAL</code> token. Why is that? Because of the whitespace character between “let” and “five”. But in Monkey whitespace only acts as a separator of tokens and doesn’t have meaning, so we need to skip over it entirely:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="kw">var</span> tok token.Token</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    l.skipWhitespace()</a>
<a class="sourceLine" id="cb30-7" data-line-number="7"></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb30-11" data-line-number="11"></a>
<a class="sourceLine" id="cb30-12" data-line-number="12"><span class="kw">func</span> (l *Lexer) skipWhitespace() {</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    <span class="kw">for</span> l.ch == <span class="ch">&#39; &#39;</span> || l.ch == <span class="ch">&#39;\t&#39;</span> || l.ch == <span class="ch">&#39;\n&#39;</span> || l.ch == <span class="ch">&#39;\r&#39;</span> {</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">        l.readChar()</a>
<a class="sourceLine" id="cb30-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb30-16" data-line-number="16">}</a></code></pre></div>
<p>This little helper function is found in a lot of parsers. Sometimes it’s called <code>eatWhitespace</code> and sometimes <code>consumeWhitespace</code> and sometimes something entirely different. Which characters these functions actually skip depends on the language being lexed. Some language implementations do create tokens for newline characters for example and throw parsing errors if they are not at the correct place in the stream of tokens. We skip over newline characters to make the parsing step later on a little easier.</p>
<p>With <code>skipWhitespace()</code> in place, the lexer trips over the <code>5</code> in the <code>let five = 5;</code> part of our test input. And that’s right, it doesn’t know yet how to turn numbers into tokens. It’s time to add this.</p>
<p>As we did previously for identifiers, we now need to add more functionality to the <code>default</code> branch of our switch statement.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="kw">var</span> tok token.Token</a>
<a class="sourceLine" id="cb31-5" data-line-number="5"></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">    l.skipWhitespace()</a>
<a class="sourceLine" id="cb31-7" data-line-number="7"></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">        <span class="kw">if</span> isLetter(l.ch) {</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">            tok.Literal = l.readIdentifier()</a>
<a class="sourceLine" id="cb31-13" data-line-number="13">            tok.Type = token.LookupIdent(tok.Literal)</a>
<a class="sourceLine" id="cb31-14" data-line-number="14">            <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb31-15" data-line-number="15">        } <span class="kw">else</span> <span class="kw">if</span> isDigit(l.ch) {</a>
<a class="sourceLine" id="cb31-16" data-line-number="16">            tok.Type = token.INT</a>
<a class="sourceLine" id="cb31-17" data-line-number="17">            tok.Literal = l.readNumber()</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">            <span class="kw">return</span> tok</a>
<a class="sourceLine" id="cb31-19" data-line-number="19">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb31-20" data-line-number="20">            tok = newToken(token.ILLEGAL, l.ch)</a>
<a class="sourceLine" id="cb31-21" data-line-number="21">        }</a>
<a class="sourceLine" id="cb31-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb31-23" data-line-number="23"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb31-24" data-line-number="24">}</a>
<a class="sourceLine" id="cb31-25" data-line-number="25"></a>
<a class="sourceLine" id="cb31-26" data-line-number="26"><span class="kw">func</span> (l *Lexer) readNumber() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb31-27" data-line-number="27">    position := l.position</a>
<a class="sourceLine" id="cb31-28" data-line-number="28">    <span class="kw">for</span> isDigit(l.ch) {</a>
<a class="sourceLine" id="cb31-29" data-line-number="29">        l.readChar()</a>
<a class="sourceLine" id="cb31-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb31-31" data-line-number="31">    <span class="kw">return</span> l.input[position:l.position]</a>
<a class="sourceLine" id="cb31-32" data-line-number="32">}</a>
<a class="sourceLine" id="cb31-33" data-line-number="33"></a>
<a class="sourceLine" id="cb31-34" data-line-number="34"><span class="kw">func</span> isDigit(ch <span class="dt">byte</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb31-35" data-line-number="35">    <span class="kw">return</span> <span class="ch">&#39;0&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="ch">&#39;9&#39;</span></a>
<a class="sourceLine" id="cb31-36" data-line-number="36">}</a></code></pre></div>
<p>As you can see, the added code closely mirrors the part concerned with reading identifiers and keywords. The <code>readNumber</code> method is exactly the same as <code>readIdentifier</code> except for its usage of <code>isDigit</code> instead of <code>isLetter</code>. We could probably generalize this by passing in the character-identifying functions as arguments, but won’t, for simplicity’s sake and ease of understanding.</p>
<p>The <code>isDigit</code> function is as simple as <code>isLetter</code>. It just returns whether the passed in byte is a Latin digit between <code>0</code> and <code>9</code>.</p>
<p>With this added, our tests pass:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb32-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">ok      monkey/lexer 0.008s</a></code></pre></div>
<p>I don’t know if you noticed, but we simplified things a lot in <code>readNumber</code>. We only read in <em>integers</em>. What about floats? Or numbers in hex notation? Octal notation? We ignore them and just say that Monkey doesn’t support this. Of course, the reason for this is again the educational aim and limited scope of this book.</p>
<p>It’s time to pop the champagne and celebrate: we successfully turned the small subset of the Monkey language we used in the our test case into tokens!</p>
<p>With this victory under our belt, it’s easy to extend the lexer so it can tokenize a lot more of Monkey source code.</p>
<h2 id="extending-our-token-set-and-lexer">1.4 - Extending our Token Set and Lexer</h2>
<p>In order to eliminate the need to jump between packages when later writing our parser, we need to extend our lexer so it can recognize more of the Monkey language and output more tokens. So in this section we will add support for <code>==</code>, <code>!</code>, <code>!=</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>&lt;</code>, <code>&gt;</code> and the keywords <code>true</code>, <code>false</code>, <code>if</code>, <code>else</code> and <code>return</code>.</p>
<p>The new tokens we will need to add, build and output can be classified as one of these three: one-character token (e.g. <code>-</code>), two-character token (e.g. <code>==</code>) and keyword token (e.g. <code>return</code>). We already know how to handle one-character and keyword tokens, so we add support for these first, before extending the lexer for two-character tokens.</p>
<p>Adding support for <code>-</code>, <code>/</code>, <code>*</code>, <code>&lt;</code> and <code>&gt;</code> is trivial. The first thing we need to do, of course, is modify the input of our test case in <code>lexer/lexer_test.go</code> to include these characters. Just like we did before. In the code accompanying this chapter you can also find the extended <code>tests</code> table, which I won’t show in the remainder of this chapter, in order to save space and to keep you from getting bored.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6"></a>
<a class="sourceLine" id="cb33-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb33-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10"></a>
<a class="sourceLine" id="cb33-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb33-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14"><span class="st">`</span></a>
<a class="sourceLine" id="cb33-15" data-line-number="15"></a>
<a class="sourceLine" id="cb33-16" data-line-number="16"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb33-17" data-line-number="17">}</a></code></pre></div>
<p>Note that although the input looks like an actual piece of Monkey source code, some lines don’t really make sense, with gibberish like <code>!-/*5</code>. That’s okay. The lexer’s job is not to tell us whether code makes sense, works or contains errors. That comes in a later stage. The lexer should only turn this input into tokens. For that reason the test cases I write for lexers cover all tokens and also try to provoke off-by-one errors, edge cases at end-of-file, newline handling, multi-digit number parsing and so on. That’s why the “code” looks like gibberish.</p>
<p>Running the test we get <code>undefined:</code> errors, because the tests contain references to undefined <code>TokenType</code>s. To fix them we add the following constants to <code>token/token.go</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">    <span class="co">// Operators</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    ASSIGN   = <span class="st">&quot;=&quot;</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    PLUS     = <span class="st">&quot;+&quot;</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    MINUS    = <span class="st">&quot;-&quot;</span></a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    BANG     = <span class="st">&quot;!&quot;</span></a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    ASTERISK = <span class="st">&quot;*&quot;</span></a>
<a class="sourceLine" id="cb34-12" data-line-number="12">    SLASH    = <span class="st">&quot;/&quot;</span></a>
<a class="sourceLine" id="cb34-13" data-line-number="13"></a>
<a class="sourceLine" id="cb34-14" data-line-number="14">    LT = <span class="st">&quot;&lt;&quot;</span></a>
<a class="sourceLine" id="cb34-15" data-line-number="15">    GT = <span class="st">&quot;&gt;&quot;</span></a>
<a class="sourceLine" id="cb34-16" data-line-number="16"></a>
<a class="sourceLine" id="cb34-17" data-line-number="17"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb34-18" data-line-number="18">)</a></code></pre></div>
<p>With the new constants added, the tests still fail, because we don’t return the tokens with the expected <code>TokenType</code>s.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb35-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">--- FAIL: TestNextToken (0.00s)</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  lexer_test.go:84: tests[36] - tokentype wrong. expected=&quot;!&quot;, got=&quot;ILLEGAL&quot;</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">FAIL    monkey/lexer 0.007s</a></code></pre></div>
<p>Turning these tests from failing to passing requires us to extend our switch statement in the <code>NextToken()</code> method of <code>Lexer</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">    <span class="kw">case</span> <span class="ch">&#39;=&#39;</span>:</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">        tok = newToken(token.ASSIGN, l.ch)</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="kw">case</span> <span class="ch">&#39;+&#39;</span>:</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">        tok = newToken(token.PLUS, l.ch)</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">    <span class="kw">case</span> <span class="ch">&#39;-&#39;</span>:</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">        tok = newToken(token.MINUS, l.ch)</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">    <span class="kw">case</span> <span class="ch">&#39;!&#39;</span>:</a>
<a class="sourceLine" id="cb36-13" data-line-number="13">        tok = newToken(token.BANG, l.ch)</a>
<a class="sourceLine" id="cb36-14" data-line-number="14">    <span class="kw">case</span> <span class="ch">&#39;/&#39;</span>:</a>
<a class="sourceLine" id="cb36-15" data-line-number="15">        tok = newToken(token.SLASH, l.ch)</a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="kw">case</span> <span class="ch">&#39;*&#39;</span>:</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">        tok = newToken(token.ASTERISK, l.ch)</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">    <span class="kw">case</span> <span class="ch">&#39;&lt;&#39;</span>:</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">        tok = newToken(token.LT, l.ch)</a>
<a class="sourceLine" id="cb36-20" data-line-number="20">    <span class="kw">case</span> <span class="ch">&#39;&gt;&#39;</span>:</a>
<a class="sourceLine" id="cb36-21" data-line-number="21">        tok = newToken(token.GT, l.ch)</a>
<a class="sourceLine" id="cb36-22" data-line-number="22">    <span class="kw">case</span> <span class="ch">&#39;;&#39;</span>:</a>
<a class="sourceLine" id="cb36-23" data-line-number="23">        tok = newToken(token.SEMICOLON, l.ch)</a>
<a class="sourceLine" id="cb36-24" data-line-number="24">    <span class="kw">case</span> <span class="ch">&#39;,&#39;</span>:</a>
<a class="sourceLine" id="cb36-25" data-line-number="25">        tok = newToken(token.COMMA, l.ch)</a>
<a class="sourceLine" id="cb36-26" data-line-number="26"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb36-27" data-line-number="27">}</a></code></pre></div>
<p>The tokens are now added and the cases of the switch statement have been reordered to reflect the structure of the constants in <code>token/token.go</code>. This small change makes our tests pass:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb37-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">ok      monkey/lexer 0.007s</a></code></pre></div>
<p>The new one-character tokens have been successfully added. Next step: add the new keywords <code>true</code>, <code>false</code>, <code>if</code>, <code>else</code> and <code>return</code>.</p>
<p>Again, the first step is to extend the input in our test to include these new keywords. Here is what the <code>input</code> in <code>TestNextToken</code> looks like now:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"></a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10"></a>
<a class="sourceLine" id="cb38-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14"></a>
<a class="sourceLine" id="cb38-15" data-line-number="15"><span class="st">if (5 &lt; 10) {</span></a>
<a class="sourceLine" id="cb38-16" data-line-number="16"><span class="st">    return true;</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17"><span class="st">} else {</span></a>
<a class="sourceLine" id="cb38-18" data-line-number="18"><span class="st">    return false;</span></a>
<a class="sourceLine" id="cb38-19" data-line-number="19"><span class="st">}`</span></a>
<a class="sourceLine" id="cb38-20" data-line-number="20"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb38-21" data-line-number="21">}</a></code></pre></div>
<p>The tests do not even compile since the references in the test expectations to the new keywords are undefined. Fixing that, again, means just adding new constants and in this case, adding the keywords to the lookup table for <code>LookupIdent()</code>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">    <span class="co">// Keywords</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">    FUNCTION = <span class="st">&quot;FUNCTION&quot;</span></a>
<a class="sourceLine" id="cb39-8" data-line-number="8">    LET      = <span class="st">&quot;LET&quot;</span></a>
<a class="sourceLine" id="cb39-9" data-line-number="9">    TRUE     = <span class="st">&quot;TRUE&quot;</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    FALSE    = <span class="st">&quot;FALSE&quot;</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">    IF       = <span class="st">&quot;IF&quot;</span></a>
<a class="sourceLine" id="cb39-12" data-line-number="12">    ELSE     = <span class="st">&quot;ELSE&quot;</span></a>
<a class="sourceLine" id="cb39-13" data-line-number="13">    RETURN   = <span class="st">&quot;RETURN&quot;</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">)</a>
<a class="sourceLine" id="cb39-15" data-line-number="15"></a>
<a class="sourceLine" id="cb39-16" data-line-number="16"><span class="kw">var</span> keywords = <span class="kw">map</span>[<span class="dt">string</span>]TokenType{</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">    <span class="st">&quot;fn&quot;</span>:     FUNCTION,</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">    <span class="st">&quot;let&quot;</span>:    LET,</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">    <span class="st">&quot;true&quot;</span>:   TRUE,</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">    <span class="st">&quot;false&quot;</span>:  FALSE,</a>
<a class="sourceLine" id="cb39-21" data-line-number="21">    <span class="st">&quot;if&quot;</span>:     IF,</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">    <span class="st">&quot;else&quot;</span>:   ELSE,</a>
<a class="sourceLine" id="cb39-23" data-line-number="23">    <span class="st">&quot;return&quot;</span>: RETURN,</a>
<a class="sourceLine" id="cb39-24" data-line-number="24">}</a></code></pre></div>
<p>And it turns out that we not only fixed the compilation error by fixing references to undefined variables, we even made the tests pass:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb40-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">ok      monkey/lexer 0.007s</a></code></pre></div>
<p>The lexer now recognizes the new keywords and the necessary changes were trivial, easy to predict and easy to make. I’d say a pat on the back is in order. We did a great job!</p>
<p>But before we can move onto the next chapter and start with our parser, we still need to extend the lexer so it recognizes tokens that are composed of two characters. The tokens we want to support look like this in the source code: <code>==</code> and <code>!=</code>.</p>
<p>At first glance you may be thinking: “why not add a new case to our switch statement and be done with it?” Since our switch statement takes the current character <code>l.ch</code> as the expression to compare against the cases, we can’t just add new cases like <code>case &quot;==&quot;</code> - the compiler won’t let us. We can’t compare our <code>l.ch</code> byte with strings like <code>&quot;==&quot;</code>.</p>
<p>What we can do instead is to reuse the existing branches for <code>'='</code> and <code>'!'</code> and extend them. So what we’re going to do is to look ahead in the input and then determine whether to return a token for <code>=</code> or <code>==</code>. After extending <code>input</code> in <code>lexer/lexer_test.go</code> again, it now looks like this:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"></a>
<a class="sourceLine" id="cb41-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb41-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb41-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14"></a>
<a class="sourceLine" id="cb41-15" data-line-number="15"><span class="st">if (5 &lt; 10) {</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16"><span class="st">    return true;</span></a>
<a class="sourceLine" id="cb41-17" data-line-number="17"><span class="st">} else {</span></a>
<a class="sourceLine" id="cb41-18" data-line-number="18"><span class="st">    return false;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="st">}</span></a>
<a class="sourceLine" id="cb41-20" data-line-number="20"></a>
<a class="sourceLine" id="cb41-21" data-line-number="21"><span class="st">10 == 10;</span></a>
<a class="sourceLine" id="cb41-22" data-line-number="22"><span class="st">10 != 9;</span></a>
<a class="sourceLine" id="cb41-23" data-line-number="23"><span class="st">`</span></a>
<a class="sourceLine" id="cb41-24" data-line-number="24"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb41-25" data-line-number="25">}</a></code></pre></div>
<p>Before we start working on the switch statement in <code>NextToken()</code>, we need to add a new helper method defined on <code>*Lexer</code> called <code>peekChar()</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"></a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) peekChar() <span class="dt">byte</span> {</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">    <span class="kw">if</span> l.readPosition &gt;= <span class="bu">len</span>(l.input) {</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">        <span class="kw">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">        <span class="kw">return</span> l.input[l.readPosition]</a>
<a class="sourceLine" id="cb42-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb42-9" data-line-number="9">}</a></code></pre></div>
<p><code>peekChar()</code> is really similar to <code>readChar()</code>, except that it doesn’t increment <code>l.position</code> and <code>l.readPosition</code>. We only want to “peek” ahead in the input and not move around in it, so we know what a call to <code>readChar()</code> would return. Most lexers and parser have such a “peek” function that looks ahead and most of the time it only returns the immediately next character. The difficulty of parsing different languages often comes down to how far you have to peek ahead (or look backwards!) in the source code to make sense of it.</p>
<p>With <code>peekChar()</code> added, the code with the updated test input doesn’t compile. Of course, since we’re referencing undefined token constants in the tests. Fixing that, again, is easy:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5"></a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    EQ     = <span class="st">&quot;==&quot;</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">    NOT_EQ = <span class="st">&quot;!=&quot;</span></a>
<a class="sourceLine" id="cb43-8" data-line-number="8"></a>
<a class="sourceLine" id="cb43-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb43-10" data-line-number="10">)</a></code></pre></div>
<p>With the references to <code>token.EQ</code> and <code>token.NOT_EQ</code> in the tests for the lexer fixed, running <code>go test</code> now returns the correct failure message:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb44-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">--- FAIL: TestNextToken (0.00s)</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  lexer_test.go:118: tests[66] - tokentype wrong. expected=&quot;==&quot;, got=&quot;=&quot;</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">FAIL    monkey/lexer 0.007s</a></code></pre></div>
<p>When the lexer comes upon a <code>==</code> in the input it creates two <code>token.ASSIGN</code> tokens instead of one <code>token.EQ</code> token. The solution is to use our new <code>peekChar()</code> method. In the branches of the switch statement for <code>'='</code> and <code>'!'</code> we “peek” ahead. If the next token is also a <code>=</code> we create either a <code>token.EQ</code> or a <code>token.NOT_EQ</code> token:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"></a>
<a class="sourceLine" id="cb45-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">    <span class="kw">case</span> <span class="ch">&#39;=&#39;</span>:</a>
<a class="sourceLine" id="cb45-7" data-line-number="7">        <span class="kw">if</span> l.peekChar() == <span class="ch">&#39;=&#39;</span> {</a>
<a class="sourceLine" id="cb45-8" data-line-number="8">            ch := l.ch</a>
<a class="sourceLine" id="cb45-9" data-line-number="9">            l.readChar()</a>
<a class="sourceLine" id="cb45-10" data-line-number="10">            literal := <span class="dt">string</span>(ch) + <span class="dt">string</span>(l.ch)</a>
<a class="sourceLine" id="cb45-11" data-line-number="11">            tok = token.Token{Type: token.EQ, Literal: literal}</a>
<a class="sourceLine" id="cb45-12" data-line-number="12">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb45-13" data-line-number="13">            tok = newToken(token.ASSIGN, l.ch)</a>
<a class="sourceLine" id="cb45-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb45-15" data-line-number="15"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb45-16" data-line-number="16">    <span class="kw">case</span> <span class="ch">&#39;!&#39;</span>:</a>
<a class="sourceLine" id="cb45-17" data-line-number="17">        <span class="kw">if</span> l.peekChar() == <span class="ch">&#39;=&#39;</span> {</a>
<a class="sourceLine" id="cb45-18" data-line-number="18">            ch := l.ch</a>
<a class="sourceLine" id="cb45-19" data-line-number="19">            l.readChar()</a>
<a class="sourceLine" id="cb45-20" data-line-number="20">            literal := <span class="dt">string</span>(ch) + <span class="dt">string</span>(l.ch)</a>
<a class="sourceLine" id="cb45-21" data-line-number="21">            tok = token.Token{Type: token.NOT_EQ, Literal: literal}</a>
<a class="sourceLine" id="cb45-22" data-line-number="22">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb45-23" data-line-number="23">            tok = newToken(token.BANG, l.ch)</a>
<a class="sourceLine" id="cb45-24" data-line-number="24">        }</a>
<a class="sourceLine" id="cb45-25" data-line-number="25"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb45-26" data-line-number="26">}</a></code></pre></div>
<p>Note that we save <code>l.ch</code> in a local variable before calling <code>l.readChar()</code> again. This way we don’t lose the current character and can safely advance the lexer so it leaves the <code>NextToken()</code> with <code>l.position</code> and <code>l.readPosition</code> in the correct state. If we were to start supporting more two-character tokens in Monkey, we should probably abstract the behaviour away in a method called <code>makeTwoCharToken</code> that peeks and advances if it found the right token. Because those two branches look awfully similar. For now though <code>==</code> and <code>!=</code> are the only two-character tokens in Monkey, so let’s leave it as it is and run our tests again to make sure it works:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb46-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">ok      monkey/lexer 0.006s</a></code></pre></div>
<p>They pass! We did it! The lexer can now produce the extended set of tokens and we’re ready to write our parser. But before we do that, let’s lay another ground stone we can build upon in the coming chapters…</p>
<h2 id="start-of-a-repl">1.5 - Start of a REPL</h2>
<p>The Monkey language needs a REPL. REPL stands for “Read Eval Print Loop” and you probably know what it is from other interpreted languages: Python has a REPL, Ruby has one, every JavaScript runtime has one, most Lisps have one and a lot of other languages too. Sometimes the REPL is called “console”, sometimes “interactive mode”. The concept is the same: the REPL reads input, sends it to the interpreter for evaluation, prints the result/output of the interpreter and starts again. Read, Eval, Print, Loop.</p>
<p>We don’t know how to fully “Eval” Monkey source code yet. We only have one part of the process that hides behind “Eval”: we can tokenize Monkey source code. But we also know how to read and print something, and I don’t think looping poses a problem.</p>
<p>Here is a REPL that tokenizes Monkey source code and prints the tokens. Later on, we will expand on this and add parsing and evaluation to it.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">// repl/repl.go</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"></a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="kw">package</span> repl</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"></a>
<a class="sourceLine" id="cb47-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb47-6" data-line-number="6">    <span class="st">&quot;bufio&quot;</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb47-8" data-line-number="8">    <span class="st">&quot;io&quot;</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">    <span class="st">&quot;monkey/lexer&quot;</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10">    <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11">)</a>
<a class="sourceLine" id="cb47-12" data-line-number="12"></a>
<a class="sourceLine" id="cb47-13" data-line-number="13"><span class="kw">const</span> PROMPT = <span class="st">&quot;&gt;&gt; &quot;</span></a>
<a class="sourceLine" id="cb47-14" data-line-number="14"></a>
<a class="sourceLine" id="cb47-15" data-line-number="15"><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</a>
<a class="sourceLine" id="cb47-16" data-line-number="16">    scanner := bufio.NewScanner(in)</a>
<a class="sourceLine" id="cb47-17" data-line-number="17"></a>
<a class="sourceLine" id="cb47-18" data-line-number="18">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb47-19" data-line-number="19">        fmt.Printf(PROMPT)</a>
<a class="sourceLine" id="cb47-20" data-line-number="20">        scanned := scanner.Scan()</a>
<a class="sourceLine" id="cb47-21" data-line-number="21">        <span class="kw">if</span> !scanned {</a>
<a class="sourceLine" id="cb47-22" data-line-number="22">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb47-23" data-line-number="23">        }</a>
<a class="sourceLine" id="cb47-24" data-line-number="24"></a>
<a class="sourceLine" id="cb47-25" data-line-number="25">        line := scanner.Text()</a>
<a class="sourceLine" id="cb47-26" data-line-number="26">        l := lexer.New(line)</a>
<a class="sourceLine" id="cb47-27" data-line-number="27"></a>
<a class="sourceLine" id="cb47-28" data-line-number="28">        <span class="kw">for</span> tok := l.NextToken(); tok.Type != token.EOF; tok = l.NextToken() {</a>
<a class="sourceLine" id="cb47-29" data-line-number="29">            fmt.Printf(<span class="st">&quot;%+v</span><span class="ch">\n</span><span class="st">&quot;</span>, tok)</a>
<a class="sourceLine" id="cb47-30" data-line-number="30">        }</a>
<a class="sourceLine" id="cb47-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb47-32" data-line-number="32">}</a></code></pre></div>
<p>This is all pretty straightforward: read from the input source until encountering a newline, take the just read line and pass it to an instance of our lexer and finally print all the tokens the lexer gives us until we encounter EOF.</p>
<p>In a <code>main.go</code> file (which we’ve been missing until now!) we welcome the user of the REPL and start it:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">// main.go</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"></a>
<a class="sourceLine" id="cb48-3" data-line-number="3"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb48-4" data-line-number="4"></a>
<a class="sourceLine" id="cb48-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">    <span class="st">&quot;os&quot;</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">    <span class="st">&quot;os/user&quot;</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9">    <span class="st">&quot;monkey/repl&quot;</span></a>
<a class="sourceLine" id="cb48-10" data-line-number="10">)</a>
<a class="sourceLine" id="cb48-11" data-line-number="11"></a>
<a class="sourceLine" id="cb48-12" data-line-number="12"><span class="kw">func</span> main() {</a>
<a class="sourceLine" id="cb48-13" data-line-number="13">    user, err := user.Current()</a>
<a class="sourceLine" id="cb48-14" data-line-number="14">    <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb48-15" data-line-number="15">        <span class="bu">panic</span>(err)</a>
<a class="sourceLine" id="cb48-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb48-17" data-line-number="17">    fmt.Printf(<span class="st">&quot;Hello %s! This is the Monkey programming language!</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb48-18" data-line-number="18">        user.Username)</a>
<a class="sourceLine" id="cb48-19" data-line-number="19">    fmt.Printf(<span class="st">&quot;Feel free to type in commands</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb48-20" data-line-number="20">    repl.Start(os.Stdin, os.Stdout)</a>
<a class="sourceLine" id="cb48-21" data-line-number="21">}</a></code></pre></div>
<p>And with that we can now interactively produce tokens:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb49-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">&gt;&gt; let add = fn(x, y) { x + y; };</a>
<a class="sourceLine" id="cb49-5" data-line-number="5">{Type:let Literal:let}</a>
<a class="sourceLine" id="cb49-6" data-line-number="6">{Type:IDENT Literal:add}</a>
<a class="sourceLine" id="cb49-7" data-line-number="7">{Type:= Literal:=}</a>
<a class="sourceLine" id="cb49-8" data-line-number="8">{Type:fn Literal:fn}</a>
<a class="sourceLine" id="cb49-9" data-line-number="9">{Type:( Literal:(}</a>
<a class="sourceLine" id="cb49-10" data-line-number="10">{Type:IDENT Literal:x}</a>
<a class="sourceLine" id="cb49-11" data-line-number="11">{Type:, Literal:,}</a>
<a class="sourceLine" id="cb49-12" data-line-number="12">{Type:IDENT Literal:y}</a>
<a class="sourceLine" id="cb49-13" data-line-number="13">{Type:) Literal:)}</a>
<a class="sourceLine" id="cb49-14" data-line-number="14">{Type:{ Literal:{}</a>
<a class="sourceLine" id="cb49-15" data-line-number="15">{Type:IDENT Literal:x}</a>
<a class="sourceLine" id="cb49-16" data-line-number="16">{Type:+ Literal:+}</a>
<a class="sourceLine" id="cb49-17" data-line-number="17">{Type:IDENT Literal:y}</a>
<a class="sourceLine" id="cb49-18" data-line-number="18">{Type:; Literal:;}</a>
<a class="sourceLine" id="cb49-19" data-line-number="19">{Type:} Literal:}}</a>
<a class="sourceLine" id="cb49-20" data-line-number="20">{Type:; Literal:;}</a>
<a class="sourceLine" id="cb49-21" data-line-number="21">&gt;&gt;</a></code></pre></div>
<p>Perfect! And <strong>now</strong> it’s time to start parsing these tokens.</p>
<h1 id="parsing">Parsing</h1>
<h2 id="parsers">2.1 - Parsers</h2>
<p>Everyone who has ever programmed has probably heard about parsers, mostly by encountering a “parser error”. Or maybe heard or even said something like “we need to parse this”, “after it’s parsed”, “the parser blows up with this input”. The word “parser” is as common as “compiler”, “interpreter” and “programming language”. Everyone knows that parsers <em>exist</em>. They have to, right? Because who else would be responsible for “parser errors”?</p>
<p>But what is a parser exactly? What is its job and how does it do it? This is what <a href="https://en.wikipedia.org/wiki/Parsing#Parser">Wikipedia has to say</a>:</p>
<blockquote>
<p>A parser is a software component that takes input data (frequently text) and builds a data structure – often some kind of parse tree, abstract syntax tree or other hierarchical structure – giving a structural representation of the input, checking for correct syntax in the process. […] The parser is often preceded by a separate lexical analyser, which creates tokens from the sequence of input characters;</p>
</blockquote>
<p>For a Wikipedia article about a computer science topic this excerpt is remarkably easy to understand. We can even recognize our lexer in there!</p>
<p>A parser turns its input into a data structure that represents the input. That sounds pretty abstract, so let me illustrate this with an example. Here is a little bit of JavaScript:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="op">&gt;</span> <span class="kw">var</span> input <span class="op">=</span> <span class="st">&#39;{&quot;name&quot;: &quot;Thorsten&quot;, &quot;age&quot;: 28}&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="op">&gt;</span> <span class="kw">var</span> output <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(input)<span class="op">;</span></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="op">&gt;</span> output</a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="op">{</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;Thorsten&#39;</span><span class="op">,</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">28</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"><span class="op">&gt;</span> <span class="va">output</span>.<span class="at">name</span></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"><span class="st">&#39;Thorsten&#39;</span></a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="op">&gt;</span> <span class="va">output</span>.<span class="at">age</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8"><span class="dv">28</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"><span class="op">&gt;</span></a></code></pre></div>
<p>Our <code>input</code> is just some text, a string. We then pass it to a parser hidden behind the <code>JSON.parse</code> function and receive an output value. This output is the data structure that represents the input: a JavaScript object with two fields named <code>name</code> and <code>age</code>, their values also corresponding to the input. We can now easily work with this data structure as demonstrated by accessing the <code>name</code> and <code>age</code> fields.</p>
<p>“But”, I hear you say, “a JSON parser isn’t the same as a parser for a programming language! They’re different!” I can see where you’re coming from with this, but no, they are not different. At least not on a conceptual level. A JSON parser takes text as input and builds a data structure that represents the input. That’s exactly what the parser of a programming language does. The difference is that in the case of a JSON parser you can <em>see</em> the data structure when looking at the input. Whereas if you look at this</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="cf">if</span> ((<span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span>) <span class="op">==</span> <span class="dv">91</span>) <span class="op">{</span> <span class="cf">return</span> <span class="at">computeStuff</span>(input1<span class="op">,</span> input2)<span class="op">;</span> <span class="op">}</span></a></code></pre></div>
<p>it’s not immediately obvious how this could be represented with a data structure. This is why, at least for me, they seemed different on a deeper, conceptional level. My guess is that this perception of conceptional difference is mainly due to a lack of familiarity with programming language parsers and the data structures they produce. I have a lot more experience with writing JSON, parsing it with a parser and inspecting the output of the parser than with parsing programming languages. As users of programming languages we seldom get to see or interact with the parsed source code, with its internal representation. Lisp programmers are the exception to the rule – in Lisp the data structures used to represent the source code are the ones used by a Lisp user. The parsed source code is easily accessible as data in the program. “Code is data, data is code” is something you hear a lot from Lisp programmers.</p>
<p>So, in order to bring our conceptual understanding of programming language parsers up to the level of our familiarity and intuitiveness with parsers of serialization languages (like JSON, YAML, TOML, INI, and so on) we need to understand the data structures they produce.</p>
<p>In most interpreters and compilers the data structure used for the internal representation of the source code is called a “syntax tree” or an “abstract syntax tree” (AST for short). The “abstract” is based on the fact that certain details visible in the source code are omitted in the AST. Semicolons, newlines, whitespace, comments, braces, bracket and parentheses – depending on the language and the parser these details are not represented in the AST, but merely guide the parser when constructing it.</p>
<p>A fact to note is that there is not one true, universal AST format that’s used by every parser. Their implementations are all pretty similar, the concept is the same, but they differ in details. The concrete implementation depends on the programming language being parsed.</p>
<p>A small example should make things clearer. Let’s say that we have the following source code:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="cf">if</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">10</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">  <span class="cf">return</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-4" data-line-number="4">  <span class="cf">return</span>  <span class="st">&quot;goodbye&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>And let’s say we are using JavaScript, have a <code>MagicLexer</code>, a <code>MagicParser</code> and the AST is built out of JavaScript objects, then the parsing step might produce something like this:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="op">&gt;</span> <span class="kw">var</span> input <span class="op">=</span> <span class="st">&#39;if (3 * 5 &gt; 10) { return &quot;hello&quot;; } else { return &quot;goodbye&quot;; }&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="op">&gt;</span> <span class="kw">var</span> tokens <span class="op">=</span> <span class="va">MagicLexer</span>.<span class="at">parse</span>(input)<span class="op">;</span></a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="op">&gt;</span> <span class="va">MagicParser</span>.<span class="at">parse</span>(tokens)<span class="op">;</span></a>
<a class="sourceLine" id="cb53-4" data-line-number="4"><span class="op">{</span></a>
<a class="sourceLine" id="cb53-5" data-line-number="5">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;if-statement&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-6" data-line-number="6">  <span class="dt">condition</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-7" data-line-number="7">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;operator-expression&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-8" data-line-number="8">    <span class="dt">operator</span><span class="op">:</span> <span class="st">&quot;&gt;&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-9" data-line-number="9">    <span class="dt">left</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-10" data-line-number="10">      <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;operator-expression&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-11" data-line-number="11">      <span class="dt">operator</span><span class="op">:</span> <span class="st">&quot;*&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-12" data-line-number="12">      <span class="dt">left</span><span class="op">:</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;integer-literal&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">3</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb53-13" data-line-number="13">      <span class="dt">right</span><span class="op">:</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;integer-literal&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">5</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb53-14" data-line-number="14">    <span class="op">},</span></a>
<a class="sourceLine" id="cb53-15" data-line-number="15">    <span class="dt">right</span><span class="op">:</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;integer-literal&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">10</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb53-16" data-line-number="16">  <span class="op">},</span></a>
<a class="sourceLine" id="cb53-17" data-line-number="17">  <span class="dt">consequence</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-18" data-line-number="18">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;return-statement&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-19" data-line-number="19">    <span class="dt">returnValue</span><span class="op">:</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;string-literal&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&quot;hello&quot;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb53-20" data-line-number="20">  <span class="op">},</span></a>
<a class="sourceLine" id="cb53-21" data-line-number="21">  <span class="dt">alternative</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-22" data-line-number="22">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;return-statement&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb53-23" data-line-number="23">    <span class="dt">returnValue</span><span class="op">:</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;string-literal&quot;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&quot;goodbye&quot;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb53-24" data-line-number="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb53-25" data-line-number="25"><span class="op">}</span></a></code></pre></div>
<p>As you can see, the output of the parser, the AST, <em>is</em> pretty abstract: there are no parentheses, no semicolons and no braces. But it does represent the source code pretty accurately, don’t you think? I bet that you can now “see” the AST structure when looking back at the source code!</p>
<p>So, this is what parsers do. They take source code as input (either as text or tokens) and produce a data structure which represents this source code. While building up the data structure, they unavoidably analyse the input, checking that it conforms to the expected structure. Thus the process of parsing is also called syntactic analysis.</p>
<p>In this chapter, we’re going to write our parser for the Monkey programming language. Its input will be the tokens we defined in the previous chapter, produced by the lexer we already wrote. We will define our own AST, suited to our needs as interpreters of the Monkey programming language, and construct instances of this AST while recursively parsing tokens.</p>
<h2 id="why-not-a-parser-generator">2.2 - Why not a parser generator?</h2>
<p>Maybe you’ve already heard about parser generators, like the tools yacc, bison or ANTLR. Parser generators are tools that, when fed with a formal description of a language, produce parsers as their output. This output is code that can then be compiled/interpreted and itself fed with source code as input to produce a syntax tree.</p>
<p>There are a lot of parser generators, differing in the format of the input they accept and the language of the output they produce. The majority of them use a <em>context-free grammar</em> (CFG) as their input. A CFG is a set of rules that describe how to form correct (valid according to the syntax) sentences in a language. The most common notational formats of CFGs are the Backus-Naur Form (BNF) or the Extended Backus-Naur Form (EBNF).</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb54-1" data-line-number="1">PrimaryExpression ::= &quot;this&quot;</a>
<a class="sourceLine" id="cb54-2" data-line-number="2">                    | ObjectLiteral</a>
<a class="sourceLine" id="cb54-3" data-line-number="3">                    | ( &quot;(&quot; Expression &quot;)&quot; )</a>
<a class="sourceLine" id="cb54-4" data-line-number="4">                    | Identifier</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">                    | ArrayLiteral</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">                    | Literal</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">Literal ::= ( &lt;DECIMAL_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-8" data-line-number="8">            | &lt;HEX_INTEGER_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-9" data-line-number="9">            | &lt;STRING_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-10" data-line-number="10">            | &lt;BOOLEAN_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">            | &lt;NULL_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">            | &lt;REGULAR_EXPRESSION_LITERAL&gt; )</a>
<a class="sourceLine" id="cb54-13" data-line-number="13">Identifier ::= &lt;IDENTIFIER_NAME&gt;</a>
<a class="sourceLine" id="cb54-14" data-line-number="14">ArrayLiteral ::= &quot;[&quot; ( ( Elision )? &quot;]&quot;</a>
<a class="sourceLine" id="cb54-15" data-line-number="15">                 | ElementList Elision &quot;]&quot;</a>
<a class="sourceLine" id="cb54-16" data-line-number="16">                 | ( ElementList )? &quot;]&quot; )</a>
<a class="sourceLine" id="cb54-17" data-line-number="17">ElementList ::= ( Elision )? AssignmentExpression</a>
<a class="sourceLine" id="cb54-18" data-line-number="18">                ( Elision AssignmentExpression )*</a>
<a class="sourceLine" id="cb54-19" data-line-number="19">Elision ::= ( &quot;,&quot; )+</a>
<a class="sourceLine" id="cb54-20" data-line-number="20">ObjectLiteral ::= &quot;{&quot; ( PropertyNameAndValueList )? &quot;}&quot;</a>
<a class="sourceLine" id="cb54-21" data-line-number="21">PropertyNameAndValueList ::= PropertyNameAndValue ( &quot;,&quot; PropertyNameAndValue</a>
<a class="sourceLine" id="cb54-22" data-line-number="22">                                                  | &quot;,&quot; )*</a>
<a class="sourceLine" id="cb54-23" data-line-number="23">PropertyNameAndValue ::= PropertyName &quot;:&quot; AssignmentExpression</a>
<a class="sourceLine" id="cb54-24" data-line-number="24">PropertyName ::= Identifier</a>
<a class="sourceLine" id="cb54-25" data-line-number="25">              | &lt;STRING_LITERAL&gt;</a>
<a class="sourceLine" id="cb54-26" data-line-number="26">              | &lt;DECIMAL_LITERAL&gt;</a></code></pre></div>
<p>This is part of <a href="http://tomcopeland.blogs.com/EcmaScript.html">a full description</a> of the EcmaScript syntax, in BNF. A parser generator would take something like this and turn it into compilable C code, for example.</p>
<p>Maybe you’ve also heard that you should use a parser generator instead of writing a parser by hand. “Just skip this part”, they say, “it’s a solved problem.” The reason for this recommendation is that parsers are exceptionally well suited to being automatically generated. Parsing is one of the most well-understood branches of computer science and really smart people have already invested a lot of time into the problems of parsing. The results of their work are CFG, BNF, EBNF, parser generators and advanced parsing techniques used in them. Why shouldn’t you take advantage of that?</p>
<p>I don’t think that learning to write your own parser is a waste of time. I actually think it’s immensely valuable. Only after having written your own parser, or at least attempted to, will you see the benefits parser generators provide, the drawbacks they have and the problems they solve. For me the concept of a parser generator only “clicked” after I wrote my first parser. I looked at it and only then really and truly understood how it’s possible to generate this code automatically.</p>
<p>Most people that recommend using a parser generator, when others want to get started with interpreters and compilers, only do so because they’ve written a parser themselves before. They’ve seen the problems and solutions available and decided it’s better to use an existing tool for the job. And they’re correct - when you want to get something done and are in a production environment, where correctness and robustness are priorities. Of course you shouldn’t try to write your own parser then, especially not if you’ve never written one before.</p>
<p>But we are here to learn, we want to understand how parsers work. And it’s my opinion that the best way to do that is by getting our hands dirty and writing a parser ourselves. Also, I think it’s immense fun.</p>
<h2 id="writing-a-parser-for-the-monkey-programming-language">2.3 - Writing a Parser for the Monkey Programming Language</h2>
<p>There are two main strategies when parsing a programming language: top-down parsing or bottom-up parsing. A lot of slightly different forms of each strategy exist. For example, “recursive descent parsing”, “Early parsing” or “predictive parsing” are all variations of top down parsing.</p>
<p>The parser we are going to write is a recursive descent parser. And in particular, it’s a “top down operator precedence” parser, sometimes called “Pratt parser”, after its inventor Vaughan Pratt.</p>
<p>I won’t go into the details of different parsing strategies here, because this is neither the place nor am I qualified enough to accurately describe them. Instead, let me just say, that the difference between top down and bottom up parsers is that the former starts with constructing root node of the AST and then descends while the latter does it the other way around. A recursive descent parser, which works from the top down, is often recommended for newcomers to parsing, since it closely mirrors the way we think about ASTs and their construction. I personally found the recursive approach starting at the root node really nice, even though it took writing some code before the concept really clicked. Which is another reason to get started with the code instead of delving into parsing strategies.</p>
<p>Now, when writing a parser ourselves, we have to make some trade-offs, yes. Our parser won’t be the fastest of all time, we won’t have formal proof of its correctness and its error-recovery process and detection of erroneous syntax won’t be bullet proof. The last one is especially hard to get right without extensive study of the theory surrounding parsing. But what we’re going to have is a fully working parser for the Monkey programming language that’s open for extensions and improvements, easy to understand and a great start to further dive into the topic of parsing, if one were so inclined.</p>
<p>We’re going to start by parsing statements: let and return statements. When we can parse statements and the basic structure of our parser stands, we will look at expressions and how to parse these (this is where Vaughan Pratt will come into play). Afterwards we extend the parser to make it capable of parsing a large subset of the Monkey programming language. As we go along we build up the necessary structures for our AST.</p>
<h2 id="parsers-first-steps-parsing-let-statements">2.4 - Parser’s first steps: parsing let statements</h2>
<p>In Monkey, variable bindings are statements of the following form:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2"><span class="kw">let</span> y <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3"><span class="kw">let</span> foobar <span class="op">=</span> <span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="kw">let</span> barfoo <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> / <span class="dv">10</span> <span class="op">+</span> <span class="dv">18</span> <span class="op">-</span> <span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">5</span>) <span class="op">+</span> <span class="at">multiply</span>(<span class="dv">124</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5"><span class="kw">let</span> anotherName <span class="op">=</span> barfoo<span class="op">;</span></a></code></pre></div>
<p>These statements are called “let statements” and bind a value to the given name. <code>let x = 5;</code> binds the value <code>5</code> to the name <code>x</code>. Our job in this section is to parse let statements correctly. For now we’re going to skip parsing the expressions that produce the value of a given variable binding and come back to this later - as soon as we know how to parse expressions on their own.</p>
<p>What does it mean to parse let statements correctly? It means that the parser produces an AST that accurately represents the information contained in the original let statement. That sounds reasonable, but we don’t have an AST yet, nor do we know what it should look like. So our first task is to take a close look at Monkey source code and see how it’s structured, so that we can define the necessary parts of an AST that’s able to accurately represent let statements.</p>
<p>Here is a fully valid program written in Monkey:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2"><span class="kw">let</span> y <span class="op">=</span> <span class="dv">15</span><span class="op">;</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3"></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(a<span class="op">,</span> b) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-5" data-line-number="5">  <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6"><span class="op">};</span></a></code></pre></div>
<p>Programs in Monkey are a series of statements. In this example we can see three statements, three variable bindings - let statements - of the following form:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb57-1" data-line-number="1">let &lt;identifier&gt; = &lt;expression&gt;;</a></code></pre></div>
<p>A let statement in Monkey consists of two changing parts: an identifier and an expression. In the example above <code>x</code>, <code>y</code> and <code>add</code> are identifiers. <code>10</code>, <code>15</code> and the function literal are expressions.</p>
<p>Before we go on, a few words about the difference between statements and expressions are needed. Expressions produce values, statements don’t. <code>let x = 5</code> doesn’t produce a value, whereas <code>5</code> does (the value it produces is <code>5</code>). A <code>return 5;</code> statement doesn’t produce a value, but <code>add(5, 5)</code> does. This distinction - expressions produce values, statements don’t - changes depending on who you ask, but it’s good enough for our needs.</p>
<p>What exactly an expression is or a statement, what produces values and what doesn’t, depends on the programming language. In some languages function literals (e.g.: <code>fn(x, y) { return x + y; }</code>) are expressions and can be used in any place where any other expression is allowed. In other programming languages though function literals can only be part of a function declaration statement, in the top level of the program. Some languages also have “if expressions”, where conditionals are expressions and produce a value. This is entirely dependent on the choices the language designers made. As you’ll see, a lot of things in Monkey are expressions, including function literals.</p>
<p>Back to our AST. Looking at the example above, we can see that it needs two different types of nodes: expressions and statements. Take a look at the start of our AST:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="kw">package</span> ast</a>
<a class="sourceLine" id="cb58-4" data-line-number="4"></a>
<a class="sourceLine" id="cb58-5" data-line-number="5"><span class="kw">type</span> Node <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb58-6" data-line-number="6">    TokenLiteral() <span class="dt">string</span></a>
<a class="sourceLine" id="cb58-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb58-8" data-line-number="8"></a>
<a class="sourceLine" id="cb58-9" data-line-number="9"><span class="kw">type</span> Statement <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb58-10" data-line-number="10">    Node</a>
<a class="sourceLine" id="cb58-11" data-line-number="11">    statementNode()</a>
<a class="sourceLine" id="cb58-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb58-13" data-line-number="13"></a>
<a class="sourceLine" id="cb58-14" data-line-number="14"><span class="kw">type</span> Expression <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb58-15" data-line-number="15">    Node</a>
<a class="sourceLine" id="cb58-16" data-line-number="16">    expressionNode()</a>
<a class="sourceLine" id="cb58-17" data-line-number="17">}</a></code></pre></div>
<p>Here we have three interfaces called <code>Node</code>, <code>Statement</code> and <code>Expression</code>. Every node in our AST has to implement the <code>Node</code> interface, meaning it has to provide a <code>TokenLiteral()</code> method that returns the literal value of the token it’s associated with. <code>TokenLiteral()</code> will be used only for debugging and testing. The AST we are going to construct consists solely of <code>Node</code>s that are connected to each other - it’s a tree after all. Some of these nodes implement the <code>Statement</code> and some the <code>Expression</code> interface. These interfaces only contain dummy methods called <code>statementNode</code> and <code>expressionNode</code> respectively. They are not strictly necessary but help us by guiding the Go compiler and possibly causing it to throw errors when we use a <code>Statement</code> where an <code>Expression</code> should’ve been used, and vice versa.</p>
<p>And here is our first implementation of <code>Node</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"><span class="kw">type</span> Program <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb59-4" data-line-number="4">    Statements []Statement</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb59-6" data-line-number="6"></a>
<a class="sourceLine" id="cb59-7" data-line-number="7"><span class="kw">func</span> (p *Program) TokenLiteral() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb59-8" data-line-number="8">    <span class="kw">if</span> <span class="bu">len</span>(p.Statements) &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb59-9" data-line-number="9">        <span class="kw">return</span> p.Statements[<span class="dv">0</span>].TokenLiteral()</a>
<a class="sourceLine" id="cb59-10" data-line-number="10">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb59-11" data-line-number="11">        <span class="kw">return</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb59-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb59-13" data-line-number="13">}</a></code></pre></div>
<p>This <code>Program</code> node is going to be the root node of every AST our parser produces. Every valid Monkey program is a series of statements. These statements are contained in the <code>Program.Statements</code>, which is just a slice of AST nodes that implement the <code>Statement</code> interface.</p>
<p>With these basic building blocks for our AST construction defined, let’s think about what a node for a variable binding in the form of <code>let x = 5;</code> might look like. Which fields should it have? Definitely one for the name of the variable. And it also needs a field that points to the expression on the right side of the equal sign. It needs to be able to point to any expression. It can’t just point to a literal value (the integer literal <code>5</code> in this case), since every expression is valid after the equal sign: <code>let x = 5 * 5</code> is as valid as <code>let y = add(2, 2) * 5 / 10;</code>. And then the node also needs to keep track of the token the AST node is associated with, so we can implement the <code>TokenLiteral()</code> method. That makes three fields: one for the identifier, one for the expression that produces the value in the let statement and one for the token.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"></a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="kw">import</span> <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb60-4" data-line-number="4"></a>
<a class="sourceLine" id="cb60-5" data-line-number="5"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb60-6" data-line-number="6"></a>
<a class="sourceLine" id="cb60-7" data-line-number="7"><span class="kw">type</span> LetStatement <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb60-8" data-line-number="8">    Token token.Token <span class="co">// the token.LET token</span></a>
<a class="sourceLine" id="cb60-9" data-line-number="9">    Name  *Identifier</a>
<a class="sourceLine" id="cb60-10" data-line-number="10">    Value Expression</a>
<a class="sourceLine" id="cb60-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb60-12" data-line-number="12"></a>
<a class="sourceLine" id="cb60-13" data-line-number="13"><span class="kw">func</span> (ls *LetStatement) statementNode()       {}</a>
<a class="sourceLine" id="cb60-14" data-line-number="14"><span class="kw">func</span> (ls *LetStatement) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> ls.Token.Literal }</a>
<a class="sourceLine" id="cb60-15" data-line-number="15"></a>
<a class="sourceLine" id="cb60-16" data-line-number="16"><span class="kw">type</span> Identifier <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb60-17" data-line-number="17">    Token token.Token <span class="co">// the token.IDENT token</span></a>
<a class="sourceLine" id="cb60-18" data-line-number="18">    Value <span class="dt">string</span></a>
<a class="sourceLine" id="cb60-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb60-20" data-line-number="20"></a>
<a class="sourceLine" id="cb60-21" data-line-number="21"><span class="kw">func</span> (i *Identifier) expressionNode()      {}</a>
<a class="sourceLine" id="cb60-22" data-line-number="22"><span class="kw">func</span> (i *Identifier) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> i.Token.Literal }</a></code></pre></div>
<p><code>LetStatement</code> has the fields we need: <code>Name</code> to hold the identifier of the binding and <code>Value</code> for the expression that produces the value. The two methods <code>statementNode</code> and <code>TokenLiteral</code> satisfy the <code>Statement</code> and <code>Node</code> interfaces respectively.</p>
<p>To hold the identifier of the binding, the <code>x</code> in <code>let x = 5;</code>, we have the <code>Identifier</code> struct type, which implements the <code>Expression</code> interface. But the identifier in a let statement doesn’t produce a value, right? So why is it an <code>Expression</code>? It’s to keep things simple. Identifiers in other parts of a Monkey program <strong>do</strong> produce values, e.g.: <code>let x = valueProducingIdentifier;</code>. And to keep the number of different node types small, we’ll use <code>Identifier</code> here to represent the name in a variable binding and later reuse it, to represent an identifier as part of or as a complete expression.</p>
<p>With <code>Program</code>, <code>LetStatement</code> and <code>Identifier</code> defined this piece of Monkey source code</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>could be represented by an AST looking like this:</p>
<figure>
<img src="./images/let_statement.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>Now that we know what it’s supposed to look like, the next task is to construct such an AST. So, without further ado here is the beginning of our parser:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"></a>
<a class="sourceLine" id="cb62-3" data-line-number="3"><span class="kw">package</span> parser</a>
<a class="sourceLine" id="cb62-4" data-line-number="4"></a>
<a class="sourceLine" id="cb62-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb62-6" data-line-number="6">    <span class="st">&quot;monkey/ast&quot;</span></a>
<a class="sourceLine" id="cb62-7" data-line-number="7">    <span class="st">&quot;monkey/lexer&quot;</span></a>
<a class="sourceLine" id="cb62-8" data-line-number="8">    <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb62-9" data-line-number="9">)</a>
<a class="sourceLine" id="cb62-10" data-line-number="10"></a>
<a class="sourceLine" id="cb62-11" data-line-number="11"><span class="kw">type</span> Parser <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb62-12" data-line-number="12">    l *lexer.Lexer</a>
<a class="sourceLine" id="cb62-13" data-line-number="13"></a>
<a class="sourceLine" id="cb62-14" data-line-number="14">    curToken  token.Token</a>
<a class="sourceLine" id="cb62-15" data-line-number="15">    peekToken token.Token</a>
<a class="sourceLine" id="cb62-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb62-17" data-line-number="17"></a>
<a class="sourceLine" id="cb62-18" data-line-number="18"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb62-19" data-line-number="19">    p := &amp;Parser{l: l}</a>
<a class="sourceLine" id="cb62-20" data-line-number="20"></a>
<a class="sourceLine" id="cb62-21" data-line-number="21">    <span class="co">// Read two tokens, so curToken and peekToken are both set</span></a>
<a class="sourceLine" id="cb62-22" data-line-number="22">    p.nextToken()</a>
<a class="sourceLine" id="cb62-23" data-line-number="23">    p.nextToken()</a>
<a class="sourceLine" id="cb62-24" data-line-number="24"></a>
<a class="sourceLine" id="cb62-25" data-line-number="25">    <span class="kw">return</span> p</a>
<a class="sourceLine" id="cb62-26" data-line-number="26">}</a>
<a class="sourceLine" id="cb62-27" data-line-number="27"></a>
<a class="sourceLine" id="cb62-28" data-line-number="28"><span class="kw">func</span> (p *Parser) nextToken() {</a>
<a class="sourceLine" id="cb62-29" data-line-number="29">    p.curToken = p.peekToken</a>
<a class="sourceLine" id="cb62-30" data-line-number="30">    p.peekToken = p.l.NextToken()</a>
<a class="sourceLine" id="cb62-31" data-line-number="31">}</a>
<a class="sourceLine" id="cb62-32" data-line-number="32"></a>
<a class="sourceLine" id="cb62-33" data-line-number="33"><span class="kw">func</span> (p *Parser) ParseProgram() *ast.Program {</a>
<a class="sourceLine" id="cb62-34" data-line-number="34">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb62-35" data-line-number="35">}</a></code></pre></div>
<p>The <code>Parser</code> has three fields: <code>l</code>, <code>curToken</code> and <code>peekToken</code>. <code>l</code> is a pointer to an instance of the lexer, on which we repeatedly call <code>NextToken()</code> to get the next token in the input. <code>curToken</code> and <code>peekToken</code> act exactly like the two “pointers” our lexer has: <code>position</code> and <code>readPosition</code>. But instead of pointing to a character in the input, they point to the current and the next token. Both are important: we need to look at the <code>curToken</code>, which is the current token under examination, to decide what to do next, and we also need <code>peekToken</code> for this decision if <code>curToken</code> doesn’t give us enough information. Think of a single line only containing <code>5;</code>. Then <code>curToken</code> is a <code>token.INT</code> and we need <code>peekToken</code> to decide whether we are at the end of the line or if we are at just the start of an arithmetic expression.</p>
<p>The <code>New</code> function is pretty self-explanatory and the <code>nextToken</code> method is a small helper that advances both <code>curToken</code> and <code>peekToken</code>. But <code>ParseProgram</code> is empty, for now.</p>
<p>Now before we start writing tests and filling out the <code>ParseProgram</code> method I want to show you the basic idea and structure behind a recursive descent parser. That makes it a lot easier to understand our own parser later on. What follows are the major parts of such a parser in pseudocode. Read this carefully and try to understand what happens in the <code>parseProgram</code> function:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="kw">function</span> <span class="at">parseProgram</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2">  program <span class="op">=</span> <span class="at">newProgramASTNode</span>()</a>
<a class="sourceLine" id="cb63-3" data-line-number="3"></a>
<a class="sourceLine" id="cb63-4" data-line-number="4">  <span class="at">advanceTokens</span>()</a>
<a class="sourceLine" id="cb63-5" data-line-number="5"></a>
<a class="sourceLine" id="cb63-6" data-line-number="6">  <span class="cf">for</span> (<span class="at">currentToken</span>() <span class="op">!=</span> EOF_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-7" data-line-number="7">    statement <span class="op">=</span> <span class="kw">null</span></a>
<a class="sourceLine" id="cb63-8" data-line-number="8"></a>
<a class="sourceLine" id="cb63-9" data-line-number="9">    <span class="cf">if</span> (<span class="at">currentToken</span>() <span class="op">==</span> LET_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-10" data-line-number="10">      statement <span class="op">=</span> <span class="at">parseLetStatement</span>()</a>
<a class="sourceLine" id="cb63-11" data-line-number="11">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="at">currentToken</span>() <span class="op">==</span> RETURN_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-12" data-line-number="12">      statement <span class="op">=</span> <span class="at">parseReturnStatement</span>()</a>
<a class="sourceLine" id="cb63-13" data-line-number="13">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="at">currentToken</span>() <span class="op">==</span> IF_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-14" data-line-number="14">      statement <span class="op">=</span> <span class="at">parseIfStatement</span>()</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb63-16" data-line-number="16"></a>
<a class="sourceLine" id="cb63-17" data-line-number="17">    <span class="cf">if</span> (statement <span class="op">!=</span> <span class="kw">null</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-18" data-line-number="18">      <span class="va">program</span>.<span class="va">Statements</span>.<span class="at">push</span>(statement)</a>
<a class="sourceLine" id="cb63-19" data-line-number="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb63-20" data-line-number="20"></a>
<a class="sourceLine" id="cb63-21" data-line-number="21">    <span class="at">advanceTokens</span>()</a>
<a class="sourceLine" id="cb63-22" data-line-number="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-23" data-line-number="23"></a>
<a class="sourceLine" id="cb63-24" data-line-number="24">  <span class="cf">return</span> program</a>
<a class="sourceLine" id="cb63-25" data-line-number="25"><span class="op">}</span></a>
<a class="sourceLine" id="cb63-26" data-line-number="26"></a>
<a class="sourceLine" id="cb63-27" data-line-number="27"><span class="kw">function</span> <span class="at">parseLetStatement</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb63-28" data-line-number="28">  <span class="at">advanceTokens</span>()</a>
<a class="sourceLine" id="cb63-29" data-line-number="29"></a>
<a class="sourceLine" id="cb63-30" data-line-number="30">  identifier <span class="op">=</span> <span class="at">parseIdentifier</span>()</a>
<a class="sourceLine" id="cb63-31" data-line-number="31"></a>
<a class="sourceLine" id="cb63-32" data-line-number="32">  <span class="at">advanceTokens</span>()</a>
<a class="sourceLine" id="cb63-33" data-line-number="33"></a>
<a class="sourceLine" id="cb63-34" data-line-number="34">  <span class="cf">if</span> <span class="at">currentToken</span>() <span class="op">!=</span> EQUAL_TOKEN <span class="op">{</span></a>
<a class="sourceLine" id="cb63-35" data-line-number="35">    <span class="at">parseError</span>(<span class="st">&quot;no equal sign!&quot;</span>)</a>
<a class="sourceLine" id="cb63-36" data-line-number="36">    <span class="cf">return</span> <span class="kw">null</span></a>
<a class="sourceLine" id="cb63-37" data-line-number="37">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-38" data-line-number="38"></a>
<a class="sourceLine" id="cb63-39" data-line-number="39">  <span class="at">advanceTokens</span>()</a>
<a class="sourceLine" id="cb63-40" data-line-number="40"></a>
<a class="sourceLine" id="cb63-41" data-line-number="41">  value <span class="op">=</span> <span class="at">parseExpression</span>()</a>
<a class="sourceLine" id="cb63-42" data-line-number="42"></a>
<a class="sourceLine" id="cb63-43" data-line-number="43">  variableStatement <span class="op">=</span> <span class="at">newVariableStatementASTNode</span>()</a>
<a class="sourceLine" id="cb63-44" data-line-number="44">  <span class="va">variableStatement</span>.<span class="at">identifier</span> <span class="op">=</span> identifier</a>
<a class="sourceLine" id="cb63-45" data-line-number="45">  <span class="va">variableStatement</span>.<span class="at">value</span> <span class="op">=</span> value</a>
<a class="sourceLine" id="cb63-46" data-line-number="46">  <span class="cf">return</span> variableStatement</a>
<a class="sourceLine" id="cb63-47" data-line-number="47"><span class="op">}</span></a>
<a class="sourceLine" id="cb63-48" data-line-number="48"></a>
<a class="sourceLine" id="cb63-49" data-line-number="49"><span class="kw">function</span> <span class="at">parseIdentifier</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb63-50" data-line-number="50">  identifier <span class="op">=</span> <span class="at">newIdentifierASTNode</span>()</a>
<a class="sourceLine" id="cb63-51" data-line-number="51">  <span class="va">identifier</span>.<span class="at">token</span> <span class="op">=</span> <span class="at">currentToken</span>()</a>
<a class="sourceLine" id="cb63-52" data-line-number="52">  <span class="cf">return</span> identifier</a>
<a class="sourceLine" id="cb63-53" data-line-number="53"><span class="op">}</span></a>
<a class="sourceLine" id="cb63-54" data-line-number="54"></a>
<a class="sourceLine" id="cb63-55" data-line-number="55"><span class="kw">function</span> <span class="at">parseExpression</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb63-56" data-line-number="56">  <span class="cf">if</span> (<span class="at">currentToken</span>() <span class="op">==</span> INTEGER_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-57" data-line-number="57">    <span class="cf">if</span> (<span class="at">nextToken</span>() <span class="op">==</span> PLUS_TOKEN)  <span class="op">{</span></a>
<a class="sourceLine" id="cb63-58" data-line-number="58">      <span class="cf">return</span> <span class="at">parseOperatorExpression</span>()</a>
<a class="sourceLine" id="cb63-59" data-line-number="59">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="at">nextToken</span>() <span class="op">==</span> SEMICOLON_TOKEN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-60" data-line-number="60">      <span class="cf">return</span> <span class="at">parseIntegerLiteral</span>()</a>
<a class="sourceLine" id="cb63-61" data-line-number="61">    <span class="op">}</span></a>
<a class="sourceLine" id="cb63-62" data-line-number="62">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="at">currentToken</span>() <span class="op">==</span> LEFT_PAREN) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-63" data-line-number="63">    <span class="cf">return</span> <span class="at">parseGroupedExpression</span>()</a>
<a class="sourceLine" id="cb63-64" data-line-number="64">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-65" data-line-number="65"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb63-66" data-line-number="66"><span class="op">}</span></a>
<a class="sourceLine" id="cb63-67" data-line-number="67"></a>
<a class="sourceLine" id="cb63-68" data-line-number="68"><span class="kw">function</span> <span class="at">parseOperatorExpression</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb63-69" data-line-number="69">  operatorExpression <span class="op">=</span> <span class="at">newOperatorExpression</span>()</a>
<a class="sourceLine" id="cb63-70" data-line-number="70"></a>
<a class="sourceLine" id="cb63-71" data-line-number="71">  <span class="va">operatorExpression</span>.<span class="at">left</span> <span class="op">=</span> <span class="at">parseIntegerLiteral</span>()</a>
<a class="sourceLine" id="cb63-72" data-line-number="72">  <span class="va">operatorExpression</span>.<span class="at">operator</span> <span class="op">=</span> <span class="at">currentToken</span>()</a>
<a class="sourceLine" id="cb63-73" data-line-number="73">  <span class="va">operatorExpression</span>.<span class="at">right</span> <span class="op">=</span> <span class="at">parseExpression</span>()</a>
<a class="sourceLine" id="cb63-74" data-line-number="74"></a>
<a class="sourceLine" id="cb63-75" data-line-number="75">  <span class="cf">return</span> <span class="at">operatorExpression</span>()</a>
<a class="sourceLine" id="cb63-76" data-line-number="76"><span class="op">}</span></a>
<a class="sourceLine" id="cb63-77" data-line-number="77"><span class="co">// [...]</span></a></code></pre></div>
<p>Since this is pseudocode there are a lot of omissions, of course. But the basic idea behind recursive-descent parsing is there. The entry point is <code>parseProgram</code> and it constructs the root node of the AST (<code>newProgramASTNode()</code>). It then builds the child nodes, the statements, by calling other functions that know which AST node to construct based on the current token. These other functions call each other again, recursively.</p>
<p>The most recursive part of this is in <code>parseExpression</code> and is only hinted at. But we can already see that in order to parse an expression like <code>5 + 5</code>, we need to first parse <code>5 +</code> and then call <code>parseExpression()</code> again to parse the rest, since after the <code>+</code> might be another operator expression, like this: <code>5 + 5 * 10</code>. We will get to this later and look at expression parsing in detail, since it’s probably the most complicated but also the most beautiful part of the parser, making heavy use of “Pratt parsing”.</p>
<p>But for now, we can already see what the parser has to do. It repeatedly advances the tokens and checks the current token to decide what to do next: either call another parsing function or throw an error. Each function then does its job and possibly constructs an AST node so that the “main loop” in <code>parseProgram()</code> can advance the tokens and decide what to do again.</p>
<p>If you looked at that pseudocode and thought “Well, that’s actually pretty easy to understand” I have great news for you: our <code>ParseProgram</code> method and the parser will look pretty similar! Let’s get to work!</p>
<p>Again, we’re starting with a test before we flesh out <code>ParseProgram</code>. Here is a test case to make sure that the parsing of let statements works:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb64-2" data-line-number="2"></a>
<a class="sourceLine" id="cb64-3" data-line-number="3"><span class="kw">package</span> parser</a>
<a class="sourceLine" id="cb64-4" data-line-number="4"></a>
<a class="sourceLine" id="cb64-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb64-6" data-line-number="6">    <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb64-7" data-line-number="7">    <span class="st">&quot;monkey/ast&quot;</span></a>
<a class="sourceLine" id="cb64-8" data-line-number="8">    <span class="st">&quot;monkey/lexer&quot;</span></a>
<a class="sourceLine" id="cb64-9" data-line-number="9">)</a>
<a class="sourceLine" id="cb64-10" data-line-number="10"></a>
<a class="sourceLine" id="cb64-11" data-line-number="11"><span class="kw">func</span> TestLetStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb64-12" data-line-number="12">    input := <span class="st">`</span></a>
<a class="sourceLine" id="cb64-13" data-line-number="13"><span class="st">let x = 5;</span></a>
<a class="sourceLine" id="cb64-14" data-line-number="14"><span class="st">let y = 10;</span></a>
<a class="sourceLine" id="cb64-15" data-line-number="15"><span class="st">let foobar = 838383;</span></a>
<a class="sourceLine" id="cb64-16" data-line-number="16"><span class="st">`</span></a>
<a class="sourceLine" id="cb64-17" data-line-number="17">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb64-18" data-line-number="18">    p := New(l)</a>
<a class="sourceLine" id="cb64-19" data-line-number="19"></a>
<a class="sourceLine" id="cb64-20" data-line-number="20">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb64-21" data-line-number="21">    <span class="kw">if</span> program == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb64-22" data-line-number="22">        t.Fatalf(<span class="st">&quot;ParseProgram() returned nil&quot;</span>)</a>
<a class="sourceLine" id="cb64-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb64-24" data-line-number="24">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb64-25" data-line-number="25">        t.Fatalf(<span class="st">&quot;program.Statements does not contain 3 statements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb64-26" data-line-number="26">            <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb64-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb64-28" data-line-number="28"></a>
<a class="sourceLine" id="cb64-29" data-line-number="29">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb64-30" data-line-number="30">        expectedIdentifier <span class="dt">string</span></a>
<a class="sourceLine" id="cb64-31" data-line-number="31">    }{</a>
<a class="sourceLine" id="cb64-32" data-line-number="32">        {<span class="st">&quot;x&quot;</span>},</a>
<a class="sourceLine" id="cb64-33" data-line-number="33">        {<span class="st">&quot;y&quot;</span>},</a>
<a class="sourceLine" id="cb64-34" data-line-number="34">        {<span class="st">&quot;foobar&quot;</span>},</a>
<a class="sourceLine" id="cb64-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb64-36" data-line-number="36"></a>
<a class="sourceLine" id="cb64-37" data-line-number="37">    <span class="kw">for</span> i, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb64-38" data-line-number="38">        stmt := program.Statements[i]</a>
<a class="sourceLine" id="cb64-39" data-line-number="39">        <span class="kw">if</span> !testLetStatement(t, stmt, tt.expectedIdentifier) {</a>
<a class="sourceLine" id="cb64-40" data-line-number="40">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb64-41" data-line-number="41">        }</a>
<a class="sourceLine" id="cb64-42" data-line-number="42">    }</a>
<a class="sourceLine" id="cb64-43" data-line-number="43">}</a>
<a class="sourceLine" id="cb64-44" data-line-number="44"></a>
<a class="sourceLine" id="cb64-45" data-line-number="45"><span class="kw">func</span> testLetStatement(t *testing.T, s ast.Statement, name <span class="dt">string</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb64-46" data-line-number="46">    <span class="kw">if</span> s.TokenLiteral() != <span class="st">&quot;let&quot;</span> {</a>
<a class="sourceLine" id="cb64-47" data-line-number="47">        t.Errorf(<span class="st">&quot;s.TokenLiteral not &#39;let&#39;. got=%q&quot;</span>, s.TokenLiteral())</a>
<a class="sourceLine" id="cb64-48" data-line-number="48">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb64-49" data-line-number="49">    }</a>
<a class="sourceLine" id="cb64-50" data-line-number="50"></a>
<a class="sourceLine" id="cb64-51" data-line-number="51">    letStmt, ok := s.(*ast.LetStatement)</a>
<a class="sourceLine" id="cb64-52" data-line-number="52">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb64-53" data-line-number="53">        t.Errorf(<span class="st">&quot;s not *ast.LetStatement. got=%T&quot;</span>, s)</a>
<a class="sourceLine" id="cb64-54" data-line-number="54">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb64-55" data-line-number="55">    }</a>
<a class="sourceLine" id="cb64-56" data-line-number="56"></a>
<a class="sourceLine" id="cb64-57" data-line-number="57">    <span class="kw">if</span> letStmt.Name.Value != name {</a>
<a class="sourceLine" id="cb64-58" data-line-number="58">        t.Errorf(<span class="st">&quot;letStmt.Name.Value not &#39;%s&#39;. got=%s&quot;</span>, name, letStmt.Name.Value)</a>
<a class="sourceLine" id="cb64-59" data-line-number="59">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb64-60" data-line-number="60">    }</a>
<a class="sourceLine" id="cb64-61" data-line-number="61"></a>
<a class="sourceLine" id="cb64-62" data-line-number="62">    <span class="kw">if</span> letStmt.Name.TokenLiteral() != name {</a>
<a class="sourceLine" id="cb64-63" data-line-number="63">        t.Errorf(<span class="st">&quot;letStmt.Name.TokenLiteral() not &#39;%s&#39;. got=%s&quot;</span>,</a>
<a class="sourceLine" id="cb64-64" data-line-number="64">            name, letStmt.Name.TokenLiteral())</a>
<a class="sourceLine" id="cb64-65" data-line-number="65">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb64-66" data-line-number="66">    }</a>
<a class="sourceLine" id="cb64-67" data-line-number="67"></a>
<a class="sourceLine" id="cb64-68" data-line-number="68">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb64-69" data-line-number="69">}</a></code></pre></div>
<p>The test case follows the same principle as the test for our lexer and pretty much every other unit test we’re going to write: we provide Monkey source code as input and then set expectations on what we want the AST - that’s produced by the parser - to look like. We do this by checking as many fields of the AST nodes as possible to make sure that nothing is missing. I found that a parser is a breeding ground for off-by-one bugs and the more tests and assertions it has the better.</p>
<p>I choose not to mock or stub out the lexer and provide source code as input instead of tokens, since that makes the tests much more readable and understandable. Of course there’s the problem of bugs in the lexer blowing up tests for the parser and generating unneeded noise, but I deem the risk too minimal, especially judged against the advantages of using readable source code as input.</p>
<p>There are two noteworthy things about this test case. The first one is that we ignore the <code>Value</code> field of the <code>*ast.LetStatement</code>. Why don’t we check if the integer literals (<code>5</code>, <code>10</code>, …) are parsed correctly? Answer: we’re going to! But first we need to make sure that the parsing of let statements works and ignore the <code>Value</code>.</p>
<p>The second one is the helper function <code>testLetStatement</code>. It might seem like over-engineering to use a separate function, but we’re going to need this function soon enough. And then it’s going to make our test cases a lot more readable than lines and lines of type conversions strewn about.</p>
<p>As an aside: we won’t look at all of the parser tests in this chapter, since they are just too long. But the code provided with the book contains all of them.</p>
<p>That being said, the tests fail as expected:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb65-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">--- FAIL: TestLetStatements (0.00s)</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">  parser_test.go:20: ParseProgram() returned nil</a>
<a class="sourceLine" id="cb65-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb65-5" data-line-number="5">FAIL    monkey/parser    0.007s</a></code></pre></div>
<p>It’s time to flesh out the <code>ParseProgram()</code> method of the <code>Parser</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2"></a>
<a class="sourceLine" id="cb66-3" data-line-number="3"><span class="kw">func</span> (p *Parser) ParseProgram() *ast.Program {</a>
<a class="sourceLine" id="cb66-4" data-line-number="4">    program := &amp;ast.Program{}</a>
<a class="sourceLine" id="cb66-5" data-line-number="5">    program.Statements = []ast.Statement{}</a>
<a class="sourceLine" id="cb66-6" data-line-number="6"></a>
<a class="sourceLine" id="cb66-7" data-line-number="7">    <span class="kw">for</span> p.curToken.Type != token.EOF {</a>
<a class="sourceLine" id="cb66-8" data-line-number="8">        stmt := p.parseStatement()</a>
<a class="sourceLine" id="cb66-9" data-line-number="9">        <span class="kw">if</span> stmt != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb66-10" data-line-number="10">            program.Statements = <span class="bu">append</span>(program.Statements, stmt)</a>
<a class="sourceLine" id="cb66-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb66-12" data-line-number="12">        p.nextToken()</a>
<a class="sourceLine" id="cb66-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb66-14" data-line-number="14"></a>
<a class="sourceLine" id="cb66-15" data-line-number="15">    <span class="kw">return</span> program</a>
<a class="sourceLine" id="cb66-16" data-line-number="16">}</a></code></pre></div>
<p>Doesn’t this look really similar to the <code>parseProgram()</code> pseudocode function we saw earlier? See! I told you! And what it does is the same too.</p>
<p>The first thing <code>ParseProgram</code> does is construct the root node of the AST, an <code>*ast.Program</code>. It then iterates over every token in the input until it encounters an <code>token.EOF</code> token. It does this by repeatedly calling <code>nextToken</code>, which advances both <code>p.curToken</code> and <code>p.peekToken</code>. In every iteration it calls <code>parseStatement</code>, whose job it is to parse a statement. If <code>parseStatement</code> returned something other than <code>nil</code>, a <code>ast.Statement</code>, its return value is added to <code>Statements</code> slice of the AST root node. When nothing is left to parse the <code>*ast.Program</code> root node is returned.</p>
<p>The <code>parseStatement</code> method looks like this:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb67-2" data-line-number="2"></a>
<a class="sourceLine" id="cb67-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseStatement() ast.Statement {</a>
<a class="sourceLine" id="cb67-4" data-line-number="4">    <span class="kw">switch</span> p.curToken.Type {</a>
<a class="sourceLine" id="cb67-5" data-line-number="5">    <span class="kw">case</span> token.LET:</a>
<a class="sourceLine" id="cb67-6" data-line-number="6">        <span class="kw">return</span> p.parseLetStatement()</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb67-8" data-line-number="8">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb67-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb67-10" data-line-number="10">}</a></code></pre></div>
<p>Don’t worry, the switch statement will get more branches. But for now, it only calls <code>parseLetStatement</code> when it encounters a <code>token.LET</code> token. And <code>parseLetStatement</code> is the method where we turn our tests from red to green:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb68-2" data-line-number="2"></a>
<a class="sourceLine" id="cb68-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</a>
<a class="sourceLine" id="cb68-4" data-line-number="4">    stmt := &amp;ast.LetStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb68-5" data-line-number="5"></a>
<a class="sourceLine" id="cb68-6" data-line-number="6">    <span class="kw">if</span> !p.expectPeek(token.IDENT) {</a>
<a class="sourceLine" id="cb68-7" data-line-number="7">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb68-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb68-9" data-line-number="9"></a>
<a class="sourceLine" id="cb68-10" data-line-number="10">    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb68-11" data-line-number="11"></a>
<a class="sourceLine" id="cb68-12" data-line-number="12">    <span class="kw">if</span> !p.expectPeek(token.ASSIGN) {</a>
<a class="sourceLine" id="cb68-13" data-line-number="13">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb68-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb68-15" data-line-number="15"></a>
<a class="sourceLine" id="cb68-16" data-line-number="16">    <span class="co">// </span><span class="al">TODO</span><span class="co">: We&#39;re skipping the expressions until we</span></a>
<a class="sourceLine" id="cb68-17" data-line-number="17">    <span class="co">// encounter a semicolon</span></a>
<a class="sourceLine" id="cb68-18" data-line-number="18">    <span class="kw">for</span> !p.curTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb68-19" data-line-number="19">        p.nextToken()</a>
<a class="sourceLine" id="cb68-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb68-21" data-line-number="21"></a>
<a class="sourceLine" id="cb68-22" data-line-number="22">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb68-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb68-24" data-line-number="24"></a>
<a class="sourceLine" id="cb68-25" data-line-number="25"><span class="kw">func</span> (p *Parser) curTokenIs(t token.TokenType) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb68-26" data-line-number="26">    <span class="kw">return</span> p.curToken.Type == t</a>
<a class="sourceLine" id="cb68-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb68-28" data-line-number="28"></a>
<a class="sourceLine" id="cb68-29" data-line-number="29"><span class="kw">func</span> (p *Parser) peekTokenIs(t token.TokenType) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb68-30" data-line-number="30">    <span class="kw">return</span> p.peekToken.Type == t</a>
<a class="sourceLine" id="cb68-31" data-line-number="31">}</a>
<a class="sourceLine" id="cb68-32" data-line-number="32"></a>
<a class="sourceLine" id="cb68-33" data-line-number="33"><span class="kw">func</span> (p *Parser) expectPeek(t token.TokenType) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb68-34" data-line-number="34">    <span class="kw">if</span> p.peekTokenIs(t) {</a>
<a class="sourceLine" id="cb68-35" data-line-number="35">        p.nextToken()</a>
<a class="sourceLine" id="cb68-36" data-line-number="36">        <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb68-37" data-line-number="37">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb68-38" data-line-number="38">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb68-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb68-40" data-line-number="40">}</a></code></pre></div>
<p>It works! The tests are green:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb69-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>We can parse let statements! That’s amazing! But, wait, how?</p>
<p>Let’s start with <code>parseLetStatement</code>. It constructs an <code>*ast.LetStatement</code> node with the token it’s currently sitting on (a <code>token.LET</code> token) and then advances the tokens while making assertions about the next token with calls to <code>expectPeek</code>. First it expects a <code>token.IDENT</code> token, which it then uses to construct an <code>*ast.Identifier</code> node. Then it expects an equal sign and finally it jumps over the expression following the equal sign until it encounters a semicolon. The skipping of expressions will be replaced, of course, as soon as we know how to parse them.</p>
<p>The <code>curTokenIs</code> and <code>peekTokenIs</code> methods do not need much of an explanation. They are useful methods that we will see again and again when fleshing out the parser. Already, we can replace the <code>p.curToken.Type != token.EOF</code> condition of the for-loop in <code>ParseProgram</code> with <code>!p.curTokenIs(token.EOF)</code>.</p>
<p>Instead of dissecting these tiny methods, let’s talk about <code>expectPeek</code>. The <code>expectPeek</code> method is one of the “assertion functions” nearly all parsers share. Their primary purpose is to enforce the correctness of the order of tokens by checking the type of the next token. Our <code>expectPeek</code> here checks the type of the <code>peekToken</code> and only if the type is correct does it advance the tokens by calling <code>nextToken</code>. As you’ll see, this is something a parser does a lot.</p>
<p>But what happens if we encounter a token in <code>expectPeek</code> that’s not of the expected type? At the moment, we just return <code>nil</code>, which gets ignored in <code>ParseProgram</code>, which results in entire statements being ignored because of an error in the input. Silently. You can probably imagine that this makes debugging really tough. And since nobody likes tough debugging we need to add error handling to our parser.</p>
<p>Thankfully, the changes we need to make are minimal:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2"></a>
<a class="sourceLine" id="cb70-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb70-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb70-5" data-line-number="5">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb70-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb70-7" data-line-number="7"></a>
<a class="sourceLine" id="cb70-8" data-line-number="8"><span class="kw">type</span> Parser <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb70-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb70-10" data-line-number="10">    errors []<span class="dt">string</span></a>
<a class="sourceLine" id="cb70-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb70-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb70-13" data-line-number="13"></a>
<a class="sourceLine" id="cb70-14" data-line-number="14"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">    p := &amp;Parser{</a>
<a class="sourceLine" id="cb70-16" data-line-number="16">        l:      l,</a>
<a class="sourceLine" id="cb70-17" data-line-number="17">        errors: []<span class="dt">string</span>{},</a>
<a class="sourceLine" id="cb70-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb70-19" data-line-number="19"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb70-20" data-line-number="20">}</a>
<a class="sourceLine" id="cb70-21" data-line-number="21"></a>
<a class="sourceLine" id="cb70-22" data-line-number="22"><span class="kw">func</span> (p *Parser) Errors() []<span class="dt">string</span> {</a>
<a class="sourceLine" id="cb70-23" data-line-number="23">    <span class="kw">return</span> p.errors</a>
<a class="sourceLine" id="cb70-24" data-line-number="24">}</a>
<a class="sourceLine" id="cb70-25" data-line-number="25"></a>
<a class="sourceLine" id="cb70-26" data-line-number="26"><span class="kw">func</span> (p *Parser) peekError(t token.TokenType) {</a>
<a class="sourceLine" id="cb70-27" data-line-number="27">    msg := fmt.Sprintf(<span class="st">&quot;expected next token to be %s, got %s instead&quot;</span>,</a>
<a class="sourceLine" id="cb70-28" data-line-number="28">        t, p.peekToken.Type)</a>
<a class="sourceLine" id="cb70-29" data-line-number="29">    p.errors = <span class="bu">append</span>(p.errors, msg)</a>
<a class="sourceLine" id="cb70-30" data-line-number="30">}</a></code></pre></div>
<p>The <code>Parser</code> now has an <code>errors</code> field, which is just a slice of strings. This field gets initialized in <code>New</code> and the helper function <code>peekError</code> can now be used to add an error to <code>errors</code> when the type of <code>peekToken</code> doesn’t match the expectation. With the <code>Errors</code> method we can check if the parser encountered any errors.</p>
<p>Extending the test suite to make use of this is as easy as you’d expect:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"></a>
<a class="sourceLine" id="cb71-3" data-line-number="3"><span class="kw">func</span> TestLetStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb71-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb71-5" data-line-number="5"></a>
<a class="sourceLine" id="cb71-6" data-line-number="6">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb71-7" data-line-number="7">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb71-8" data-line-number="8"></a>
<a class="sourceLine" id="cb71-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb71-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb71-11" data-line-number="11"></a>
<a class="sourceLine" id="cb71-12" data-line-number="12"><span class="kw">func</span> checkParserErrors(t *testing.T, p *Parser) {</a>
<a class="sourceLine" id="cb71-13" data-line-number="13">    errors := p.Errors()</a>
<a class="sourceLine" id="cb71-14" data-line-number="14">    <span class="kw">if</span> <span class="bu">len</span>(errors) == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb71-15" data-line-number="15">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb71-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb71-17" data-line-number="17"></a>
<a class="sourceLine" id="cb71-18" data-line-number="18">    t.Errorf(<span class="st">&quot;parser has %d errors&quot;</span>, <span class="bu">len</span>(errors))</a>
<a class="sourceLine" id="cb71-19" data-line-number="19">    <span class="kw">for</span> _, msg := <span class="kw">range</span> errors {</a>
<a class="sourceLine" id="cb71-20" data-line-number="20">        t.Errorf(<span class="st">&quot;parser error: %q&quot;</span>, msg)</a>
<a class="sourceLine" id="cb71-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb71-22" data-line-number="22">    t.FailNow()</a>
<a class="sourceLine" id="cb71-23" data-line-number="23">}</a></code></pre></div>
<p>The new <code>checkParserErrors</code> helper function does nothing more than check the parser for errors and if it has any it prints them as test errors and stops the execution of the current test. Pretty straightforward.</p>
<p>But nothing in our parser creates errors yet. By changing <code>expectPeek</code> we can automatically add an error every time one of our expectations about the next token was wrong:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2"></a>
<a class="sourceLine" id="cb72-3" data-line-number="3"><span class="kw">func</span> (p *Parser) expectPeek(t token.TokenType) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">    <span class="kw">if</span> p.peekTokenIs(t) {</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">        p.nextToken()</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">        <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb72-7" data-line-number="7">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb72-8" data-line-number="8">        p.peekError(t)</a>
<a class="sourceLine" id="cb72-9" data-line-number="9">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb72-11" data-line-number="11">}</a></code></pre></div>
<p>If we now change our test case input from this</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb73-1" data-line-number="1">    input := <span class="st">`</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2"><span class="st">let x = 5;</span></a>
<a class="sourceLine" id="cb73-3" data-line-number="3"><span class="st">let y = 10;</span></a>
<a class="sourceLine" id="cb73-4" data-line-number="4"><span class="st">let foobar = 838383;</span></a>
<a class="sourceLine" id="cb73-5" data-line-number="5"><span class="st">`</span></a></code></pre></div>
<p>to this invalid input where tokens are missing</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb74-1" data-line-number="1">    input := <span class="st">`</span></a>
<a class="sourceLine" id="cb74-2" data-line-number="2"><span class="st">let x 5;</span></a>
<a class="sourceLine" id="cb74-3" data-line-number="3"><span class="st">let = 10;</span></a>
<a class="sourceLine" id="cb74-4" data-line-number="4"><span class="st">let 838383;</span></a>
<a class="sourceLine" id="cb74-5" data-line-number="5"><span class="st">`</span></a></code></pre></div>
<p>we can run our tests to see our new parser errors:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb75-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb75-2" data-line-number="2">--- FAIL: TestLetStatements (0.00s)</a>
<a class="sourceLine" id="cb75-3" data-line-number="3">  parser_test.go:20: parser has 3 errors</a>
<a class="sourceLine" id="cb75-4" data-line-number="4">  parser_test.go:22: parser error: &quot;expected next token to be =,\</a>
<a class="sourceLine" id="cb75-5" data-line-number="5">    got INT instead&quot;</a>
<a class="sourceLine" id="cb75-6" data-line-number="6">  parser_test.go:22: parser error: &quot;expected next token to be IDENT,\</a>
<a class="sourceLine" id="cb75-7" data-line-number="7">    got = instead&quot;</a>
<a class="sourceLine" id="cb75-8" data-line-number="8">  parser_test.go:22: parser error: &quot;expected next token to be IDENT,\</a>
<a class="sourceLine" id="cb75-9" data-line-number="9">    got INT instead&quot;</a>
<a class="sourceLine" id="cb75-10" data-line-number="10">FAIL</a>
<a class="sourceLine" id="cb75-11" data-line-number="11">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>As you can see, our parser showcases a neat little feature here: it gives us errors for each erroneous statement it encounters. It doesn’t exit on the first one, potentially saving us the grunt work of rerunning the parsing process again and again to catch all of the syntax errors. That’s pretty helpful - even with line and column numbers missing.</p>
<h2 id="parsing-return-statements">2.5 - Parsing Return Statements</h2>
<p>I said earlier that we’re going to flesh out our sparse looking <code>ParseProgram</code> method. Now’s the time. We’re going to parse return statements. And the first step, as with let statements before them, is to define the necessary structures in the <code>ast</code> package with which we can represent return statements in our AST.</p>
<p>Here is what return statements look like in Monkey:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="cf">return</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb76-2" data-line-number="2"><span class="cf">return</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb76-3" data-line-number="3"><span class="cf">return</span> <span class="at">add</span>(<span class="dv">15</span>)<span class="op">;</span></a></code></pre></div>
<p>Experienced with let statements, we can easily spot the structure behind these statements:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb77-1" data-line-number="1">return &lt;expression&gt;;</a></code></pre></div>
<p>Return statements consist solely of the keyword <code>return</code> and an expression. That makes the definition of <code>ast.ReturnStatement</code> really simple:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb78-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb78-2" data-line-number="2"></a>
<a class="sourceLine" id="cb78-3" data-line-number="3"><span class="kw">type</span> ReturnStatement <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb78-4" data-line-number="4">    Token       token.Token <span class="co">// the &#39;return&#39; token</span></a>
<a class="sourceLine" id="cb78-5" data-line-number="5">    ReturnValue Expression</a>
<a class="sourceLine" id="cb78-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb78-7" data-line-number="7"></a>
<a class="sourceLine" id="cb78-8" data-line-number="8"><span class="kw">func</span> (rs *ReturnStatement) statementNode()       {}</a>
<a class="sourceLine" id="cb78-9" data-line-number="9"><span class="kw">func</span> (rs *ReturnStatement) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> rs.Token.Literal }</a></code></pre></div>
<p>There is nothing about this node that you haven’t seen before: it has a field for the initial token and a <code>ReturnValue</code> field that will contain the expression that’s to be returned. We will again skip the parsing of the expressions and the semicolon handling for now, but will come back to this later. The <code>statementNode</code> and <code>TokenLiteral</code> methods are there to fulfill the <code>Node</code> and <code>Statement</code> interfaces and look identical to the methods defined on <code>*ast.LetStatement</code>.</p>
<p>The test we write next also looks pretty similar to the one for let statements:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb79-2" data-line-number="2"></a>
<a class="sourceLine" id="cb79-3" data-line-number="3"><span class="kw">func</span> TestReturnStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb79-4" data-line-number="4">    input := <span class="st">`</span></a>
<a class="sourceLine" id="cb79-5" data-line-number="5"><span class="st">return 5;</span></a>
<a class="sourceLine" id="cb79-6" data-line-number="6"><span class="st">return 10;</span></a>
<a class="sourceLine" id="cb79-7" data-line-number="7"><span class="st">return 993322;</span></a>
<a class="sourceLine" id="cb79-8" data-line-number="8"><span class="st">`</span></a>
<a class="sourceLine" id="cb79-9" data-line-number="9">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb79-10" data-line-number="10">    p := New(l)</a>
<a class="sourceLine" id="cb79-11" data-line-number="11"></a>
<a class="sourceLine" id="cb79-12" data-line-number="12">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb79-13" data-line-number="13">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb79-14" data-line-number="14"></a>
<a class="sourceLine" id="cb79-15" data-line-number="15">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb79-16" data-line-number="16">        t.Fatalf(<span class="st">&quot;program.Statements does not contain 3 statements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb79-17" data-line-number="17">            <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb79-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb79-19" data-line-number="19"></a>
<a class="sourceLine" id="cb79-20" data-line-number="20">    <span class="kw">for</span> _, stmt := <span class="kw">range</span> program.Statements {</a>
<a class="sourceLine" id="cb79-21" data-line-number="21">        returnStmt, ok := stmt.(*ast.ReturnStatement)</a>
<a class="sourceLine" id="cb79-22" data-line-number="22">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb79-23" data-line-number="23">            t.Errorf(<span class="st">&quot;stmt not *ast.returnStatement. got=%T&quot;</span>, stmt)</a>
<a class="sourceLine" id="cb79-24" data-line-number="24">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb79-25" data-line-number="25">        }</a>
<a class="sourceLine" id="cb79-26" data-line-number="26">        <span class="kw">if</span> returnStmt.TokenLiteral() != <span class="st">&quot;return&quot;</span> {</a>
<a class="sourceLine" id="cb79-27" data-line-number="27">            t.Errorf(<span class="st">&quot;returnStmt.TokenLiteral not &#39;return&#39;, got %q&quot;</span>,</a>
<a class="sourceLine" id="cb79-28" data-line-number="28">                returnStmt.TokenLiteral())</a>
<a class="sourceLine" id="cb79-29" data-line-number="29">        }</a>
<a class="sourceLine" id="cb79-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb79-31" data-line-number="31">}</a></code></pre></div>
<p>Of course these test cases will also have to be extended as soon as expression parsing is in place. But that’s okay, tests are not immutable. But they are, in fact, failing:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb80-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb80-2" data-line-number="2">--- FAIL: TestReturnStatements (0.00s)</a>
<a class="sourceLine" id="cb80-3" data-line-number="3">  parser_test.go:77: program.Statements does not contain 3 statements. got=0</a>
<a class="sourceLine" id="cb80-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb80-5" data-line-number="5">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>So let’s make them pass by changing our <code>parseStatement</code> method to also take <code>token.RETURN</code> tokens into account:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb81-2" data-line-number="2"></a>
<a class="sourceLine" id="cb81-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseStatement() ast.Statement {</a>
<a class="sourceLine" id="cb81-4" data-line-number="4">    <span class="kw">switch</span> p.curToken.Type {</a>
<a class="sourceLine" id="cb81-5" data-line-number="5">    <span class="kw">case</span> token.LET:</a>
<a class="sourceLine" id="cb81-6" data-line-number="6">        <span class="kw">return</span> p.parseLetStatement()</a>
<a class="sourceLine" id="cb81-7" data-line-number="7">    <span class="kw">case</span> token.RETURN:</a>
<a class="sourceLine" id="cb81-8" data-line-number="8">        <span class="kw">return</span> p.parseReturnStatement()</a>
<a class="sourceLine" id="cb81-9" data-line-number="9">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb81-10" data-line-number="10">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb81-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb81-12" data-line-number="12">}</a></code></pre></div>
<p>I could make a lot of fuss about the <code>parseReturnStatement</code> method before showing it to you, but, well, I won’t. Because it’s tiny. There is nothing to fuss about.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2"></a>
<a class="sourceLine" id="cb82-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseReturnStatement() *ast.ReturnStatement {</a>
<a class="sourceLine" id="cb82-4" data-line-number="4">    stmt := &amp;ast.ReturnStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb82-5" data-line-number="5"></a>
<a class="sourceLine" id="cb82-6" data-line-number="6">    p.nextToken()</a>
<a class="sourceLine" id="cb82-7" data-line-number="7"></a>
<a class="sourceLine" id="cb82-8" data-line-number="8">    <span class="co">// </span><span class="al">TODO</span><span class="co">: We&#39;re skipping the expressions until we</span></a>
<a class="sourceLine" id="cb82-9" data-line-number="9">    <span class="co">// encounter a semicolon</span></a>
<a class="sourceLine" id="cb82-10" data-line-number="10">    <span class="kw">for</span> !p.curTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb82-11" data-line-number="11">        p.nextToken()</a>
<a class="sourceLine" id="cb82-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb82-13" data-line-number="13"></a>
<a class="sourceLine" id="cb82-14" data-line-number="14">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb82-15" data-line-number="15">}</a></code></pre></div>
<p>I told you: it’s tiny. The only thing it does is construct an <code>ast.ReturnStatement</code>, with the current token it’s sitting on as <code>Token</code>. It then brings the parser in place for the expression that comes next by calling <code>nextToken()</code> and finally, there’s the cop-out. It skips over every expression until it encounters a semicolon. That’s it. Our tests pass:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb83-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb83-2" data-line-number="2">ok      monkey/parser   0.009s</a></code></pre></div>
<p>It’s time to celebrate again! We can now parse all of the statements in the Monkey programming language! That’s right: there are only two of them. Let statements and return statements. The rest of the language consists solely of expressions. And that’s what we’re going to parse next.</p>
<h2 id="parsing-expressions">2.6 - Parsing Expressions</h2>
<p>Personally, I think that parsing expressions is the most interesting part of writing a parser. As we just saw, parsing statements is relatively straightforward. We process tokens from “left to right”, expect or reject the next tokens and if everything fits we return an AST node.</p>
<p>Parsing expressions, on the other hand, contains a few more challenges. Operator precedence is probably the first one that comes to mind and is best illustrated with an example. Let’s say we want to parse the following arithmetic expression:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb84-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span></a></code></pre></div>
<p>What we want here is an AST that represents the expression like this:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb85-1" data-line-number="1">((<span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>) <span class="op">+</span> <span class="dv">10</span>)</a></code></pre></div>
<p>That is to say, <code>5 * 5</code> needs to be “deeper” in the AST and evaluated earlier than the addition. In order to produce an AST that looks like this, the parser has to know about operator precedences where the precedence of <code>*</code> is higher than <code>+</code>. That’s the most common example for operator precedence, but there are a lot more cases where it’s important. Consider this expression:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span>)</a></code></pre></div>
<p>Here the parenthesis group together the <code>5 + 10</code> expression and give them a “precedence bump”: the addition now has to be evaluated before the multiplication. That’s because parentheses have a higher precedence than the <code>*</code> operator. As we will soon see, there are a few more cases where precedence is playing a crucial role.</p>
<p>The other big challenge is that in expressions tokens of the same type can appear in multiple positions. In contrast to this, the <code>let</code> token can only appear once at the beginning of a let statement, which makes it easy to determine what the rest of the statement is supposed to be. Now look at this expression:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb87-1" data-line-number="1"><span class="dv">-5</span> <span class="op">-</span> <span class="dv">10</span></a></code></pre></div>
<p>Here the <code>-</code> operator appears at the beginning of the expression, as a prefix operator, and then as an infix operator in the middle. A variation of the same challenge appears here:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> (<span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>) <span class="op">+</span> <span class="dv">10</span>)</a></code></pre></div>
<p>Even though you might not recognize the parentheses as operators yet, they pose the same problem to us as the <code>-</code> in the previous example. The outer pair of parentheses in this example denotes a grouped expression. The inner pair denotes a “call expression”. The validity of a token’s position now depends on the context, the tokens that come before and after, and their precedence.</p>
<h3 id="expressions-in-monkey">Expressions in Monkey</h3>
<p>In the Monkey programming language everything besides let and return statements is an expression. These expressions come in different varieties.</p>
<p>Monkey has expressions involving prefix operators:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb89-1" data-line-number="1"><span class="dv">-5</span></a>
<a class="sourceLine" id="cb89-2" data-line-number="2"><span class="op">!</span><span class="kw">true</span></a>
<a class="sourceLine" id="cb89-3" data-line-number="3"><span class="op">!</span><span class="kw">false</span></a></code></pre></div>
<p>And of course it has infix operators (or “binary operators”):</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb90-2" data-line-number="2"><span class="dv">5</span> <span class="op">-</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb90-3" data-line-number="3"><span class="dv">5</span> / <span class="dv">5</span></a>
<a class="sourceLine" id="cb90-4" data-line-number="4"><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span></a></code></pre></div>
<p>Besides these basic arithmetic operators, there are also the following comparison operators:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb91-1" data-line-number="1">foo <span class="op">==</span> bar</a>
<a class="sourceLine" id="cb91-2" data-line-number="2">foo <span class="op">!=</span> bar</a>
<a class="sourceLine" id="cb91-3" data-line-number="3">foo <span class="op">&lt;</span> bar</a>
<a class="sourceLine" id="cb91-4" data-line-number="4">foo <span class="op">&gt;</span> bar</a></code></pre></div>
<p>And of course, as we previously saw, we can use parentheses to group expressions and influence the order of evaluation:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb92-2" data-line-number="2">((<span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">5</span></a></code></pre></div>
<p>Then there are call expressions:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb93-2" data-line-number="2"><span class="at">add</span>(<span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb93-3" data-line-number="3"><span class="at">max</span>(<span class="dv">5</span><span class="op">,</span> <span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> (<span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>)))</a></code></pre></div>
<p>Identifiers are expressions too:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb94-1" data-line-number="1">foo <span class="op">*</span> bar / foobar</a>
<a class="sourceLine" id="cb94-2" data-line-number="2"><span class="at">add</span>(foo<span class="op">,</span> bar)</a></code></pre></div>
<p>Functions in Monkey are first-class citizens and, yes, function literals are expressions too. We can use a let statement to bind a function to a name. The function literal is just the expression in the statement:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> y <span class="op">};</span></a></code></pre></div>
<p>And here we use a function literal in place of an identifier:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> y <span class="op">}</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb96-2" data-line-number="2">(<span class="at">fn</span>(x) <span class="op">{</span> <span class="cf">return</span> x <span class="op">}</span>(<span class="dv">5</span>) <span class="op">+</span> <span class="dv">10</span> ) <span class="op">*</span> <span class="dv">10</span></a></code></pre></div>
<p>In contrast to a lot of widely used programming languages we also have “if expressions” in Monkey:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="kw">let</span> result <span class="op">=</span> <span class="cf">if</span> (<span class="dv">10</span> <span class="op">&gt;</span> <span class="dv">5</span>) <span class="op">{</span> <span class="kw">true</span> <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="kw">false</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb97-2" data-line-number="2">result <span class="co">// =&gt; true</span></a></code></pre></div>
<p>Looking at all these different forms of expressions it becomes clear that we need a really good approach to parse them correctly and in an understandable and extendable way. Our old approach of deciding what to do based on the current token won’t get us very far - at least not without wanting to tear our hair out. And that is where Vaughan Pratt comes in.</p>
<h3 id="top-down-operator-precedence-or-pratt-parsing">Top Down Operator Precedence (or: Pratt Parsing)</h3>
<p>In his paper “Top Down Operator Precedence” Vaughan Pratt presents an approach to parsing expressions that, in his own words:</p>
<blockquote>
<p>[…] is very simple to understand, trivial to implement, easy to use, extremely efficient in practice if not in theory, yet flexible enough to meet most reasonable syntactic needs of users […]</p>
</blockquote>
<p>The paper was published in 1973 but in the many years since then the ideas presented by Pratt didn’t gain a huge following. Only in recent years, other programmers rediscovered Pratt’s paper, wrote about it and caused Pratt’s approach to parsing to rise in popularity. There’s Douglas Crockford’s (of “JavaScript: The Good Parts” fame) article called <a href="http://javascript.crockford.com/tdop/tdop.html">“Top Down Operator Precedence”</a> that shows how to translate Pratt’s ideas to JavaScript (which Crockford did when building JSLint). And then there’s <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">the highly recommended article by Bob Nystrom</a>, author of the excellent “Game Programming Patterns” book, that makes Pratt’s approach really easy to understand and to follow by providing clean example code in Java.</p>
<p>The parsing approach described by all three, which is called Top Down Operator Precedence Parsing, or Pratt parsing, was invented as an alternative to parsers based on context-free grammars and the Backus-Naur-Form.</p>
<p>And that is also the main difference: instead of associating parsing functions (think of our <code>parseLetStatement</code> method here) with grammar rules (defined in BNF or EBNF), Pratt associates these functions (which he calls “semantic code”) with single token types. A crucial part of this idea is that each token type can have two parsing functions associated with it, depending on the token’s position - infix or prefix.</p>
<p>I guess that doesn’t make a lot of sense yet. We never saw how to associate parsing functions with grammar rules, so the idea of using token types instead of these rules doesn’t register as anything really novel or revelatory. To be completely honest: I was facing a chicken-and-egg problem when writing this section. Is it better to explain this algorithm in abstract terms and then show the implementation, possibly causing you to jump back and forth between pages, or to show the implementation with the explanation following, causing you to probably skip over the implementation and not getting a lot out of the explanation?</p>
<p>The answer, I decided, is neither of these two options. What we’re going to do instead is start implementing the expression parsing part of our parser. Then we’re going to take a closer look at it and its algorithm. Afterwards we will extend and complete it so it’s able to parse all possible expressions in Monkey.</p>
<p>And before we start writing any code, let’s just be clear on the terminology.</p>
<h3 id="terminology">Terminology</h3>
<p>A <strong>prefix operator</strong> is an operator “in front of” its operand. Example:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb98-1" data-line-number="1"><span class="op">--</span><span class="dv">5</span></a></code></pre></div>
<p>Here the operator is <code>--</code> (decrement), the operand is the integer literal <code>5</code> and the operator is in the prefix position.</p>
<p>A <strong>postfix operator</strong> is an operator “after” its operand. Example:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb99-1" data-line-number="1">foobar<span class="op">++</span></a></code></pre></div>
<p>Here the operator is <code>++</code> (increment), the operand is the identifier <code>foobar</code> and the operator is in the postfix position. The Monkey interpreter we’ll build won’t have postfix operators. Not because of some technical limitations, but purely in order to keep the scope of the book limited.</p>
<p>Now, <strong>infix operators</strong> are something we’ve all seen before. An infix operator sits between its operands, like this:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb100-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> <span class="dv">8</span></a></code></pre></div>
<p>The <code>*</code> operator sits in the infix position between the two integer literals <code>5</code> and <code>8</code>. Infix operators appear in <strong>binary expressions</strong> - where the operator has two operands.</p>
<p>The other term we already stumbled upon and will find again later is <strong>operator precedence</strong>. An alternative term for this is <strong>order of operations</strong>, which should make clearer what operator precedence describes: which priority do different operators have. The canonical example is this one, which we saw earlier:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">10</span></a></code></pre></div>
<p>The result of this expression is <code>55</code> and not <code>100</code>. And that’s because the <code>*</code> operator has a higher precedence, a “higher rank”. It’s “more important” than the <code>+</code> operator. It gets evaluated before the other operator. I sometimes think of operator precedence as “operator stickiness”: how much do the operands next to the operator “stick” to it.</p>
<p>These are all basic terms: prefix, postfix, infix operator and precedence. But it’s important that we keep these simple definitions in mind later on, where we’ll use these terms in other places.</p>
<p>But for now: let’s get typing and write some code!</p>
<h3 id="preparing-the-ast">Preparing the AST</h3>
<p>The first thing we need to do for expression parsing is to prepare our AST. As we saw before, a program in Monkey is a series of statements. Some are let statements, others return statements. We need to add a third type of statement to our AST: expression statements.</p>
<p>This may sound confusing, after I told you that let and return statements are the only type of statements in Monkey. But an expression statement is not really a distinct statement; it’s a statement that consists solely of one expression. It’s only a wrapper. We need it because it’s totally legal in Monkey to write the following code:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb102-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-2" data-line-number="2">x <span class="op">+</span> <span class="dv">10</span><span class="op">;</span></a></code></pre></div>
<p>The first line is a let statement, the second line is an expression statement. Other languages don’t have these expression statements, but most scripting languages do. They make it possible to have one line consisting only of an expression. So let’s add this node type to our AST:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb103-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb103-2" data-line-number="2"></a>
<a class="sourceLine" id="cb103-3" data-line-number="3"><span class="kw">type</span> ExpressionStatement <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb103-4" data-line-number="4">    Token      token.Token <span class="co">// the first token of the expression</span></a>
<a class="sourceLine" id="cb103-5" data-line-number="5">    Expression Expression</a>
<a class="sourceLine" id="cb103-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb103-7" data-line-number="7"></a>
<a class="sourceLine" id="cb103-8" data-line-number="8"><span class="kw">func</span> (es *ExpressionStatement) statementNode()       {}</a>
<a class="sourceLine" id="cb103-9" data-line-number="9"><span class="kw">func</span> (es *ExpressionStatement) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> es.Token.Literal }</a></code></pre></div>
<p>The <code>ast.ExpressionStatement</code> type has two fields: the <code>Token</code> field, which every node has, and the <code>Expression</code> field, which holds the expression. <code>ast.ExpressionStatement</code> fulfills the <code>ast.Statement</code> interface, which means we can add it to the <code>Statements</code> slice of <code>ast.Program</code>. And that’s the whole reason why we’re adding <code>ast.ExpressionStatement</code>.</p>
<p>With <code>ast.ExpressionStatement</code> defined we could resume work on the parser. But instead, let’s make our lives much easier by adding a <code>String()</code> method to our AST nodes. This will allow us to print AST nodes for debugging and to compare them with other AST nodes. This is going to be really handy in tests!</p>
<p>We’re going to make this <code>String()</code> method part of the <code>ast.Node</code> interface:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb104-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb104-2" data-line-number="2"></a>
<a class="sourceLine" id="cb104-3" data-line-number="3"><span class="kw">type</span> Node <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb104-4" data-line-number="4">    TokenLiteral() <span class="dt">string</span></a>
<a class="sourceLine" id="cb104-5" data-line-number="5">    String() <span class="dt">string</span></a>
<a class="sourceLine" id="cb104-6" data-line-number="6">}</a></code></pre></div>
<p>Now every node type in our <code>ast</code> package has to implement this method. With that change made, our code won’t compile because the compiler complains about our AST nodes not fully implementing the updated <code>Node</code> interface. Let’s start with <code>*ast.Program</code> and add its <code>String()</code> method first:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb105-2" data-line-number="2"></a>
<a class="sourceLine" id="cb105-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb105-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb105-5" data-line-number="5">    <span class="st">&quot;bytes&quot;</span></a>
<a class="sourceLine" id="cb105-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb105-7" data-line-number="7"></a>
<a class="sourceLine" id="cb105-8" data-line-number="8"><span class="kw">func</span> (p *Program) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb105-9" data-line-number="9">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb105-10" data-line-number="10"></a>
<a class="sourceLine" id="cb105-11" data-line-number="11">    <span class="kw">for</span> _, s := <span class="kw">range</span> p.Statements {</a>
<a class="sourceLine" id="cb105-12" data-line-number="12">        out.WriteString(s.String())</a>
<a class="sourceLine" id="cb105-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb105-14" data-line-number="14"></a>
<a class="sourceLine" id="cb105-15" data-line-number="15">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb105-16" data-line-number="16">}</a></code></pre></div>
<p>This method doesn’t do much. It only creates a buffer and writes the return value of each statement’s <code>String()</code> method to it. And then it returns the buffer as a string. It delegates most of its work to the <code>Statements</code> of <code>*ast.Program</code>.</p>
<p>The “real work” happens in the <code>String()</code> methods of our three statement types <code>ast.LetStatement</code>, <code>ast.ReturnStatement</code> and <code>ast.ExpressionStatement</code>:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb106-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb106-2" data-line-number="2"></a>
<a class="sourceLine" id="cb106-3" data-line-number="3"><span class="kw">func</span> (ls *LetStatement) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb106-4" data-line-number="4">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb106-5" data-line-number="5"></a>
<a class="sourceLine" id="cb106-6" data-line-number="6">    out.WriteString(ls.TokenLiteral() + <span class="st">&quot; &quot;</span>)</a>
<a class="sourceLine" id="cb106-7" data-line-number="7">    out.WriteString(ls.Name.String())</a>
<a class="sourceLine" id="cb106-8" data-line-number="8">    out.WriteString(<span class="st">&quot; = &quot;</span>)</a>
<a class="sourceLine" id="cb106-9" data-line-number="9"></a>
<a class="sourceLine" id="cb106-10" data-line-number="10">    <span class="kw">if</span> ls.Value != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb106-11" data-line-number="11">        out.WriteString(ls.Value.String())</a>
<a class="sourceLine" id="cb106-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb106-13" data-line-number="13"></a>
<a class="sourceLine" id="cb106-14" data-line-number="14">    out.WriteString(<span class="st">&quot;;&quot;</span>)</a>
<a class="sourceLine" id="cb106-15" data-line-number="15"></a>
<a class="sourceLine" id="cb106-16" data-line-number="16">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb106-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb106-18" data-line-number="18"></a>
<a class="sourceLine" id="cb106-19" data-line-number="19"><span class="kw">func</span> (rs *ReturnStatement) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb106-20" data-line-number="20">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb106-21" data-line-number="21"></a>
<a class="sourceLine" id="cb106-22" data-line-number="22">    out.WriteString(rs.TokenLiteral() + <span class="st">&quot; &quot;</span>)</a>
<a class="sourceLine" id="cb106-23" data-line-number="23"></a>
<a class="sourceLine" id="cb106-24" data-line-number="24">    <span class="kw">if</span> rs.ReturnValue != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb106-25" data-line-number="25">        out.WriteString(rs.ReturnValue.String())</a>
<a class="sourceLine" id="cb106-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb106-27" data-line-number="27"></a>
<a class="sourceLine" id="cb106-28" data-line-number="28">    out.WriteString(<span class="st">&quot;;&quot;</span>)</a>
<a class="sourceLine" id="cb106-29" data-line-number="29"></a>
<a class="sourceLine" id="cb106-30" data-line-number="30">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb106-31" data-line-number="31">}</a>
<a class="sourceLine" id="cb106-32" data-line-number="32"></a>
<a class="sourceLine" id="cb106-33" data-line-number="33"><span class="kw">func</span> (es *ExpressionStatement) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb106-34" data-line-number="34">    <span class="kw">if</span> es.Expression != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb106-35" data-line-number="35">        <span class="kw">return</span> es.Expression.String()</a>
<a class="sourceLine" id="cb106-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb106-37" data-line-number="37">    <span class="kw">return</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb106-38" data-line-number="38">}</a></code></pre></div>
<p>The nil-checks will be taken out, later on, when we can fully build expressions.</p>
<p>Now we only need to add a last <code>String()</code> method to <code>ast.Identifier</code>:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb107-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb107-2" data-line-number="2"></a>
<a class="sourceLine" id="cb107-3" data-line-number="3"><span class="kw">func</span> (i *Identifier) String() <span class="dt">string</span> { <span class="kw">return</span> i.Value }</a></code></pre></div>
<p>With these methods in place, we can now just call <code>String()</code> on <code>*ast.Program</code> and get our whole program back as a string. That makes the structure of <code>*ast.Program</code> easily testable. Let’s use the following line of Monkey source code as an example:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="kw">let</span> myVar <span class="op">=</span> anotherVar<span class="op">;</span></a></code></pre></div>
<p>If we construct an AST out of this, we can make an assertion about the return value of <code>String()</code> like this:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="co">// ast/ast_test.go</span></a>
<a class="sourceLine" id="cb109-2" data-line-number="2"></a>
<a class="sourceLine" id="cb109-3" data-line-number="3"><span class="kw">package</span> ast</a>
<a class="sourceLine" id="cb109-4" data-line-number="4"></a>
<a class="sourceLine" id="cb109-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb109-6" data-line-number="6">    <span class="st">&quot;monkey/token&quot;</span></a>
<a class="sourceLine" id="cb109-7" data-line-number="7">    <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb109-8" data-line-number="8">)</a>
<a class="sourceLine" id="cb109-9" data-line-number="9"></a>
<a class="sourceLine" id="cb109-10" data-line-number="10"><span class="kw">func</span> TestString(t *testing.T) {</a>
<a class="sourceLine" id="cb109-11" data-line-number="11">    program := &amp;Program{</a>
<a class="sourceLine" id="cb109-12" data-line-number="12">        Statements: []Statement{</a>
<a class="sourceLine" id="cb109-13" data-line-number="13">            &amp;LetStatement{</a>
<a class="sourceLine" id="cb109-14" data-line-number="14">                Token: token.Token{Type: token.LET, Literal: <span class="st">&quot;let&quot;</span>},</a>
<a class="sourceLine" id="cb109-15" data-line-number="15">                Name: &amp;Identifier{</a>
<a class="sourceLine" id="cb109-16" data-line-number="16">                    Token: token.Token{Type: token.IDENT, Literal: <span class="st">&quot;myVar&quot;</span>},</a>
<a class="sourceLine" id="cb109-17" data-line-number="17">                    Value: <span class="st">&quot;myVar&quot;</span>,</a>
<a class="sourceLine" id="cb109-18" data-line-number="18">                },</a>
<a class="sourceLine" id="cb109-19" data-line-number="19">                Value: &amp;Identifier{</a>
<a class="sourceLine" id="cb109-20" data-line-number="20">                    Token: token.Token{Type: token.IDENT, Literal: <span class="st">&quot;anotherVar&quot;</span>},</a>
<a class="sourceLine" id="cb109-21" data-line-number="21">                    Value: <span class="st">&quot;anotherVar&quot;</span>,</a>
<a class="sourceLine" id="cb109-22" data-line-number="22">                },</a>
<a class="sourceLine" id="cb109-23" data-line-number="23">            },</a>
<a class="sourceLine" id="cb109-24" data-line-number="24">        },</a>
<a class="sourceLine" id="cb109-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb109-26" data-line-number="26"></a>
<a class="sourceLine" id="cb109-27" data-line-number="27">    <span class="kw">if</span> program.String() != <span class="st">&quot;let myVar = anotherVar;&quot;</span> {</a>
<a class="sourceLine" id="cb109-28" data-line-number="28">        t.Errorf(<span class="st">&quot;program.String() wrong. got=%q&quot;</span>, program.String())</a>
<a class="sourceLine" id="cb109-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb109-30" data-line-number="30">}</a></code></pre></div>
<p>In this test we construct the AST by hand. When writing tests for the parser we don’t, of course, but make assertions about the AST the parser produces. For demonstration purposes, this test shows us how we can add another easily readable layer of tests for our parser by just comparing the parser output with strings. That’s going to be especially handy when parsing expressions.</p>
<p>So, good news: preparation is done! It’s time to write a Pratt parser.</p>
<h3 id="implementing-the-pratt-parser">Implementing the Pratt Parser</h3>
<p>A Pratt parser’s main idea is the association of parsing functions (which Pratt calls “semantic code”) with token types. Whenever this token type is encountered, the parsing functions are called to parse the appropriate expression and return an AST node that represents it. Each token type can have up to two parsing functions associated with it, depending on whether the token is found in a prefix or an infix position.</p>
<p>The first thing we need to do is to setup these associations. We define two types of functions: a prefix parsing function and an infix parsing function.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb110-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb110-2" data-line-number="2"></a>
<a class="sourceLine" id="cb110-3" data-line-number="3"><span class="kw">type</span> (</a>
<a class="sourceLine" id="cb110-4" data-line-number="4">    prefixParseFn <span class="kw">func</span>() ast.Expression</a>
<a class="sourceLine" id="cb110-5" data-line-number="5">    infixParseFn  <span class="kw">func</span>(ast.Expression) ast.Expression</a>
<a class="sourceLine" id="cb110-6" data-line-number="6">)</a></code></pre></div>
<p>Both function types return an <code>ast.Expression</code>, since that’s what we’re here to parse. But only the <code>infixParseFn</code> takes an argument: another <code>ast.Expression</code>. This argument is “left side” of the infix operator that’s being parsed. A prefix operator doesn’t have a “left side”, per definition. I know that this doesn’t make a lot of sense yet, but bear with me here, you’ll see how this works. For now, just remember that <code>prefixParseFn</code>s gets called when we encounter the associated token type in prefix position and <code>infixParseFn</code> gets called when we encounter the token type in infix position.</p>
<p>In order for our parser to get the correct <code>prefixParseFn</code> or <code>infixParseFn</code> for the current token type, we add two maps to the <code>Parser</code> structure:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb111-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb111-2" data-line-number="2"></a>
<a class="sourceLine" id="cb111-3" data-line-number="3"><span class="kw">type</span> Parser <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb111-4" data-line-number="4">    l      *lexer.Lexer</a>
<a class="sourceLine" id="cb111-5" data-line-number="5">    errors []<span class="dt">string</span></a>
<a class="sourceLine" id="cb111-6" data-line-number="6"></a>
<a class="sourceLine" id="cb111-7" data-line-number="7">    curToken  token.Token</a>
<a class="sourceLine" id="cb111-8" data-line-number="8">    peekToken token.Token</a>
<a class="sourceLine" id="cb111-9" data-line-number="9"></a>
<a class="sourceLine" id="cb111-10" data-line-number="10">    prefixParseFns <span class="kw">map</span>[token.TokenType]prefixParseFn</a>
<a class="sourceLine" id="cb111-11" data-line-number="11">    infixParseFns  <span class="kw">map</span>[token.TokenType]infixParseFn</a>
<a class="sourceLine" id="cb111-12" data-line-number="12">}</a></code></pre></div>
<p>With these maps in place, we can just check if the appropriate map (infix or prefix) has a parsing function associated with <code>curToken.Type</code>.</p>
<p>We also give the <code>Parser</code> two helper methods that add entries to these maps:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb112-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb112-2" data-line-number="2"></a>
<a class="sourceLine" id="cb112-3" data-line-number="3"><span class="kw">func</span> (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {</a>
<a class="sourceLine" id="cb112-4" data-line-number="4">    p.prefixParseFns[tokenType] = fn</a>
<a class="sourceLine" id="cb112-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb112-6" data-line-number="6"></a>
<a class="sourceLine" id="cb112-7" data-line-number="7"><span class="kw">func</span> (p *Parser) registerInfix(tokenType token.TokenType, fn infixParseFn) {</a>
<a class="sourceLine" id="cb112-8" data-line-number="8">    p.infixParseFns[tokenType] = fn</a>
<a class="sourceLine" id="cb112-9" data-line-number="9">}</a></code></pre></div>
<p>Now we are ready to get to the heart of the algorithm.</p>
<h3 id="identifiers">Identifiers</h3>
<p>We’re going to start with possibly the simplest expression type in the Monkey programming language: identifiers. Used in an expression statement an identifier looks like this:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb113-1" data-line-number="1">foobar<span class="op">;</span></a></code></pre></div>
<p>Of course, the <code>foobar</code> is arbitrary and identifiers are expressions in other contexts too, not just in an expression statement:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="at">add</span>(foobar<span class="op">,</span> barfoo)<span class="op">;</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2">foobar <span class="op">+</span> barfoo<span class="op">;</span></a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="cf">if</span> (foobar) <span class="op">{</span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4">  <span class="co">// [...]</span></a>
<a class="sourceLine" id="cb114-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>Here we have identifiers as arguments in a function call, as operands in an infix expression and as a standalone expression as part of a conditional. They can be used in all of these contexts, because identifiers are expressions just like <code>1 + 2</code>. And just like any other expression identifiers produce a value: they evaluate to the value they are bound to.</p>
<p>We start with a test:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb115-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb115-2" data-line-number="2"></a>
<a class="sourceLine" id="cb115-3" data-line-number="3"><span class="kw">func</span> TestIdentifierExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb115-4" data-line-number="4">    input := <span class="st">&quot;foobar;&quot;</span></a>
<a class="sourceLine" id="cb115-5" data-line-number="5"></a>
<a class="sourceLine" id="cb115-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb115-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb115-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb115-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb115-10" data-line-number="10"></a>
<a class="sourceLine" id="cb115-11" data-line-number="11">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb115-12" data-line-number="12">        t.Fatalf(<span class="st">&quot;program has not enough statements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb115-13" data-line-number="13">            <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb115-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb115-15" data-line-number="15">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb115-16" data-line-number="16">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb115-17" data-line-number="17">        t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb115-18" data-line-number="18">            program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb115-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb115-20" data-line-number="20"></a>
<a class="sourceLine" id="cb115-21" data-line-number="21">    ident, ok := stmt.Expression.(*ast.Identifier)</a>
<a class="sourceLine" id="cb115-22" data-line-number="22">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb115-23" data-line-number="23">        t.Fatalf(<span class="st">&quot;exp not *ast.Identifier. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb115-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb115-25" data-line-number="25">    <span class="kw">if</span> ident.Value != <span class="st">&quot;foobar&quot;</span> {</a>
<a class="sourceLine" id="cb115-26" data-line-number="26">        t.Errorf(<span class="st">&quot;ident.Value not %s. got=%s&quot;</span>, <span class="st">&quot;foobar&quot;</span>, ident.Value)</a>
<a class="sourceLine" id="cb115-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb115-28" data-line-number="28">    <span class="kw">if</span> ident.TokenLiteral() != <span class="st">&quot;foobar&quot;</span> {</a>
<a class="sourceLine" id="cb115-29" data-line-number="29">        t.Errorf(<span class="st">&quot;ident.TokenLiteral not %s. got=%s&quot;</span>, <span class="st">&quot;foobar&quot;</span>,</a>
<a class="sourceLine" id="cb115-30" data-line-number="30">            ident.TokenLiteral())</a>
<a class="sourceLine" id="cb115-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb115-32" data-line-number="32">}</a></code></pre></div>
<p>That’s a lot of lines, but it’s mostly just grunt work. We parse our input <code>foobar;</code>, check the parser for errors, make an assertion about the number of statements in the <code>*ast.Program</code> node and then check that the only statement in <code>program.Statements</code> is an <code>*ast.ExpressionStatement</code>. Then we check that the <code>*ast.ExpressionStatement.Expression</code> is an <code>*ast.Identifier</code>. Finally we check that our identifier has the correct value of <code>&quot;foobar&quot;</code>.</p>
<p>Of course, the parser tests fail:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb116-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb116-2" data-line-number="2">--- FAIL: TestIdentifierExpression (0.00s)</a>
<a class="sourceLine" id="cb116-3" data-line-number="3">  parser_test.go:110: program has not enough statements. got=0</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb116-5" data-line-number="5">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>The parser doesn’t know anything about expressions yet. We need to write a <code>parseExpression</code> method.</p>
<p>The first thing we need to do is to extend the <code>parseStatement()</code> method of the parser, so that it parses expression statements. Since the only two real statement types in Monkey are let and return statements, we try to parse expression statements if we don’t encounter one of the other two:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb117-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb117-2" data-line-number="2"></a>
<a class="sourceLine" id="cb117-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseStatement() ast.Statement {</a>
<a class="sourceLine" id="cb117-4" data-line-number="4">    <span class="kw">switch</span> p.curToken.Type {</a>
<a class="sourceLine" id="cb117-5" data-line-number="5">    <span class="kw">case</span> token.LET:</a>
<a class="sourceLine" id="cb117-6" data-line-number="6">        <span class="kw">return</span> p.parseLetStatement()</a>
<a class="sourceLine" id="cb117-7" data-line-number="7">    <span class="kw">case</span> token.RETURN:</a>
<a class="sourceLine" id="cb117-8" data-line-number="8">        <span class="kw">return</span> p.parseReturnStatement()</a>
<a class="sourceLine" id="cb117-9" data-line-number="9">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb117-10" data-line-number="10">        <span class="kw">return</span> p.parseExpressionStatement()</a>
<a class="sourceLine" id="cb117-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb117-12" data-line-number="12">}</a></code></pre></div>
<p>The <code>parseExpressionStatement</code> method looks like this:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb118-2" data-line-number="2"></a>
<a class="sourceLine" id="cb118-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {</a>
<a class="sourceLine" id="cb118-4" data-line-number="4">    stmt := &amp;ast.ExpressionStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb118-5" data-line-number="5"></a>
<a class="sourceLine" id="cb118-6" data-line-number="6">    stmt.Expression = p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb118-7" data-line-number="7"></a>
<a class="sourceLine" id="cb118-8" data-line-number="8">    <span class="kw">if</span> p.peekTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb118-9" data-line-number="9">        p.nextToken()</a>
<a class="sourceLine" id="cb118-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb118-11" data-line-number="11"></a>
<a class="sourceLine" id="cb118-12" data-line-number="12">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb118-13" data-line-number="13">}</a></code></pre></div>
<p>We already know the drill: we build our AST node and then try to fill its field by calling other parsing functions. In this case there are a few differences though: we call <code>parseExpression()</code>, which doesn’t exist yet, with the constant <code>LOWEST</code>, that doesn’t exist yet, and then we check for an optional semicolon. Yes, it’s optional. If the <code>peekToken</code> is a <code>token.SEMICOLON</code>, we advance so it’s the <code>curToken</code>. If it’s not there, that’s okay too, we don’t add an error to the parser if it’s not there. That’s because we want expression statements to have optional semicolons (which makes it easier to type something like <code>5 + 5</code> into the REPL later on).</p>
<p>If we now run the tests we can see that compilation fails, because <code>LOWEST</code> is undefined. That’s alright, let’s add it now, by defining the precedences of the Monkey programming language:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb119-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2"></a>
<a class="sourceLine" id="cb119-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb119-4" data-line-number="4">    _ <span class="dt">int</span> = <span class="ot">iota</span></a>
<a class="sourceLine" id="cb119-5" data-line-number="5">    LOWEST</a>
<a class="sourceLine" id="cb119-6" data-line-number="6">    EQUALS      <span class="co">// ==</span></a>
<a class="sourceLine" id="cb119-7" data-line-number="7">    LESSGREATER <span class="co">// &gt; or &lt;</span></a>
<a class="sourceLine" id="cb119-8" data-line-number="8">    SUM         <span class="co">// +</span></a>
<a class="sourceLine" id="cb119-9" data-line-number="9">    PRODUCT     <span class="co">// *</span></a>
<a class="sourceLine" id="cb119-10" data-line-number="10">    PREFIX      <span class="co">// -X or !X</span></a>
<a class="sourceLine" id="cb119-11" data-line-number="11">    CALL        <span class="co">// myFunction(X)</span></a>
<a class="sourceLine" id="cb119-12" data-line-number="12">)</a></code></pre></div>
<p>Here we use <code>iota</code> to give the following constants incrementing numbers as values. The blank identifier <code>_</code> takes the zero value and the following constants get assigned the values <code>1</code> to <code>7</code>. Which numbers we use doesn’t matter, but the <strong>order</strong> and the relation to each other do. What we want out of these constants is to later be able to answer: “does the <code>*</code> operator have a higher precedence than the <code>==</code> operator? Does a prefix operator have a higher precedence than a call expression?”</p>
<p>In <code>parseExpressionStatement</code> we pass the lowest possible precedence to <code>parseExpression</code>, since we didn’t parse anything yet and we can’t compare precedences. That’s going to make more sense in a short while, I promise. Let’s write <code>parseExpression</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb120-2" data-line-number="2"></a>
<a class="sourceLine" id="cb120-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseExpression(precedence <span class="dt">int</span>) ast.Expression {</a>
<a class="sourceLine" id="cb120-4" data-line-number="4">    prefix := p.prefixParseFns[p.curToken.Type]</a>
<a class="sourceLine" id="cb120-5" data-line-number="5">    <span class="kw">if</span> prefix == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb120-6" data-line-number="6">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb120-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb120-8" data-line-number="8">    leftExp := prefix()</a>
<a class="sourceLine" id="cb120-9" data-line-number="9"></a>
<a class="sourceLine" id="cb120-10" data-line-number="10">    <span class="kw">return</span> leftExp</a>
<a class="sourceLine" id="cb120-11" data-line-number="11">}</a></code></pre></div>
<p>That’s the first version. All it does is checking whether we have a parsing function associated with <code>p.curToken.Type</code> in the prefix position. If we do, it calls this parsing function, if not, it returns nil. Which it does at the moment, since we haven’t associated any tokens with any parsing functions yet. That’s our next step:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb121-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb121-2" data-line-number="2"></a>
<a class="sourceLine" id="cb121-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb121-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb121-5" data-line-number="5"></a>
<a class="sourceLine" id="cb121-6" data-line-number="6">    p.prefixParseFns = <span class="bu">make</span>(<span class="kw">map</span>[token.TokenType]prefixParseFn)</a>
<a class="sourceLine" id="cb121-7" data-line-number="7">    p.registerPrefix(token.IDENT, p.parseIdentifier)</a>
<a class="sourceLine" id="cb121-8" data-line-number="8"></a>
<a class="sourceLine" id="cb121-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb121-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb121-11" data-line-number="11"></a>
<a class="sourceLine" id="cb121-12" data-line-number="12"><span class="kw">func</span> (p *Parser) parseIdentifier() ast.Expression {</a>
<a class="sourceLine" id="cb121-13" data-line-number="13">    <span class="kw">return</span> &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb121-14" data-line-number="14">}</a></code></pre></div>
<p>We modified the <code>New()</code> function to initialize the <code>prefixParseFns</code> map on <code>Parser</code> and register a parsing function: if we encounter a token of type <code>token.IDENT</code> the parsing function to call is <code>parseIdentifier</code>, a method we defined on <code>*Parser</code>.</p>
<p>The <code>parseIdentifier</code> method doesn’t do a lot. It only returns a <code>*ast.Identifier</code> with the current token in the <code>Token</code> field and the literal value of the token in <code>Value</code>. It doesn’t advance the tokens, it doesn’t call <code>nextToken</code>. That’s important. All of our parsing functions, <code>prefixParseFn</code> or <code>infixParseFn</code>, are going to follow this protocol: start with <code>curToken</code> being the type of token you’re associated with and return with <code>curToken</code> being the last token that’s part of your expression type. Never advance the tokens too far.</p>
<p>Believe it or not, our tests pass:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb122-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb122-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>We successfully parsed an identifier expression! Alright! But, before we get off the computer, find someone and proudly tell them, let’s keep our breath a little longer and write some more parsing functions.</p>
<h3 id="integer-literals">Integer Literals</h3>
<p>Nearly as easy to parse as identifiers are integer literals, which look like this:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb123-1" data-line-number="1"><span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>Yes, that’s it. Integer literals are expressions. The value they produce is the integer itself. Again, imagine in which places integer literals can occur to understand why they are expressions:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb124-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb124-2" data-line-number="2"><span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-3" data-line-number="3"><span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>We can use any other expression instead of integer literals here and it would still be valid: identifiers, call expressions, grouped expressions, function literals and so on. All the expression types are interchangeable and integer literals are one of them.</p>
<p>The test case for integer literals looks really similar to the one for identifiers:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb125-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb125-2" data-line-number="2"></a>
<a class="sourceLine" id="cb125-3" data-line-number="3"><span class="kw">func</span> TestIntegerLiteralExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb125-4" data-line-number="4">    input := <span class="st">&quot;5;&quot;</span></a>
<a class="sourceLine" id="cb125-5" data-line-number="5"></a>
<a class="sourceLine" id="cb125-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb125-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb125-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb125-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb125-10" data-line-number="10"></a>
<a class="sourceLine" id="cb125-11" data-line-number="11">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb125-12" data-line-number="12">        t.Fatalf(<span class="st">&quot;program has not enough statements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb125-13" data-line-number="13">            <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb125-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb125-15" data-line-number="15">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb125-16" data-line-number="16">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb125-17" data-line-number="17">        t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb125-18" data-line-number="18">            program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb125-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb125-20" data-line-number="20"></a>
<a class="sourceLine" id="cb125-21" data-line-number="21">    literal, ok := stmt.Expression.(*ast.IntegerLiteral)</a>
<a class="sourceLine" id="cb125-22" data-line-number="22">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb125-23" data-line-number="23">        t.Fatalf(<span class="st">&quot;exp not *ast.IntegerLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb125-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb125-25" data-line-number="25">    <span class="kw">if</span> literal.Value != <span class="dv">5</span> {</a>
<a class="sourceLine" id="cb125-26" data-line-number="26">        t.Errorf(<span class="st">&quot;literal.Value not %d. got=%d&quot;</span>, <span class="dv">5</span>, literal.Value)</a>
<a class="sourceLine" id="cb125-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb125-28" data-line-number="28">    <span class="kw">if</span> literal.TokenLiteral() != <span class="st">&quot;5&quot;</span> {</a>
<a class="sourceLine" id="cb125-29" data-line-number="29">        t.Errorf(<span class="st">&quot;literal.TokenLiteral not %s. got=%s&quot;</span>, <span class="st">&quot;5&quot;</span>,</a>
<a class="sourceLine" id="cb125-30" data-line-number="30">            literal.TokenLiteral())</a>
<a class="sourceLine" id="cb125-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb125-32" data-line-number="32">}</a></code></pre></div>
<p>And as in the test case for identifiers we use a simple input, feed it to the parser and then check that the parser didn’t encounter any errors and produced the correct number of statements in <code>*ast.Program.Statements</code>. Then we add an assertion that the first statement is an <code>*ast.ExpressionStatement</code>. And finally we expect a well-formed <code>*ast.IntegerLiteral</code>.</p>
<p>The tests do not compile, since <code>*ast.IntegerLiteral</code> doesn’t exist yet. Defining it is easy though:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb126-2" data-line-number="2"></a>
<a class="sourceLine" id="cb126-3" data-line-number="3"><span class="kw">type</span> IntegerLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb126-4" data-line-number="4">    Token token.Token</a>
<a class="sourceLine" id="cb126-5" data-line-number="5">    Value <span class="dt">int64</span></a>
<a class="sourceLine" id="cb126-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb126-7" data-line-number="7"></a>
<a class="sourceLine" id="cb126-8" data-line-number="8"><span class="kw">func</span> (il *IntegerLiteral) expressionNode()      {}</a>
<a class="sourceLine" id="cb126-9" data-line-number="9"><span class="kw">func</span> (il *IntegerLiteral) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> il.Token.Literal }</a>
<a class="sourceLine" id="cb126-10" data-line-number="10"><span class="kw">func</span> (il *IntegerLiteral) String() <span class="dt">string</span>       { <span class="kw">return</span> il.Token.Literal }</a></code></pre></div>
<p><code>*ast.IntegerLiteral</code> fulfills the <code>ast.Expression</code> interface, just like <code>*ast.Identifier</code> does, but there’s a notable difference to <code>ast.Identifier</code> in the structure itself: <code>Value</code> is an <code>int64</code> and not a <code>string</code>. This is the field that’s going to contain the actual value the integer literal represents in the source code. When we build an <code>*ast.IntegerLiteral</code> we have to convert the string in <code>*ast.IntegerLiteral.Token.Literal</code> (which is something like <code>&quot;5&quot;</code>) to an <code>int64</code>.</p>
<p>The best place to do this is in the parsing function associated with <code>token.INT</code>, called <code>parseIntegerLiteral</code>:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb127-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb127-2" data-line-number="2"></a>
<a class="sourceLine" id="cb127-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb127-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb127-5" data-line-number="5">    <span class="st">&quot;strconv&quot;</span></a>
<a class="sourceLine" id="cb127-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb127-7" data-line-number="7"></a>
<a class="sourceLine" id="cb127-8" data-line-number="8"><span class="kw">func</span> (p *Parser) parseIntegerLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb127-9" data-line-number="9">    lit := &amp;ast.IntegerLiteral{Token: p.curToken}</a>
<a class="sourceLine" id="cb127-10" data-line-number="10"></a>
<a class="sourceLine" id="cb127-11" data-line-number="11">    value, err := strconv.ParseInt(p.curToken.Literal, <span class="dv">0</span>, <span class="dv">64</span>)</a>
<a class="sourceLine" id="cb127-12" data-line-number="12">    <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb127-13" data-line-number="13">        msg := fmt.Sprintf(<span class="st">&quot;could not parse %q as integer&quot;</span>, p.curToken.Literal)</a>
<a class="sourceLine" id="cb127-14" data-line-number="14">        p.errors = <span class="bu">append</span>(p.errors, msg)</a>
<a class="sourceLine" id="cb127-15" data-line-number="15">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb127-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb127-17" data-line-number="17"></a>
<a class="sourceLine" id="cb127-18" data-line-number="18">    lit.Value = value</a>
<a class="sourceLine" id="cb127-19" data-line-number="19"></a>
<a class="sourceLine" id="cb127-20" data-line-number="20">    <span class="kw">return</span> lit</a>
<a class="sourceLine" id="cb127-21" data-line-number="21">}</a></code></pre></div>
<p>Like <code>parseIdentifier</code> the method is strikingly simple. The only thing that’s really different is a call to <code>strconv.ParseInt</code>, which converts the string in <code>p.curToken.Literal</code> into an <code>int64</code>. The <code>int64</code> then gets saved to the <code>Value</code> field and we return the newly constructed <code>*ast.IntegerLiteral</code> node. If that doesn’t work, we add a new error to the parser’s <code>errors</code> field.</p>
<p>But the tests don’t pass yet:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb128-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb128-2" data-line-number="2">--- FAIL: TestIntegerLiteralExpression (0.00s)</a>
<a class="sourceLine" id="cb128-3" data-line-number="3">  parser_test.go:162: exp not *ast.IntegerLiteral. got=&lt;nil&gt;</a>
<a class="sourceLine" id="cb128-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb128-5" data-line-number="5">FAIL    monkey/parser   0.008s</a></code></pre></div>
<p>We have a <code>nil</code> instead of an <code>*ast.IntegerLiteral</code> in our AST. The reason is that <code>parseExpression</code> can’t find a <code>prefixParseFn</code> for a token of type <code>token.INT</code>. All we have to do to make the tests pass is to register our <code>parseIntegerLiteral</code> method:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb129-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"></a>
<a class="sourceLine" id="cb129-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb129-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb129-5" data-line-number="5">    p.prefixParseFns = <span class="bu">make</span>(<span class="kw">map</span>[token.TokenType]prefixParseFn)</a>
<a class="sourceLine" id="cb129-6" data-line-number="6">    p.registerPrefix(token.IDENT, p.parseIdentifier)</a>
<a class="sourceLine" id="cb129-7" data-line-number="7">    p.registerPrefix(token.INT, p.parseIntegerLiteral)</a>
<a class="sourceLine" id="cb129-8" data-line-number="8"></a>
<a class="sourceLine" id="cb129-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb129-10" data-line-number="10">}</a></code></pre></div>
<p>With <code>parseIntegerLiteral</code> registered, <code>parseExpression</code> now knows what to do with a <code>token.INT</code> token, calls <code>parseIntegerLiteral</code> and returns its return value, an <code>*ast.IntegerLiteral</code>. The tests pass:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb130-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb130-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>I think it’s time to say: we are on a roll here! Identifiers and integer literals are in the bag, let’s step it up a notch and parse prefix operators.</p>
<h3 id="prefix-operators">Prefix Operators</h3>
<p>There are two prefix operators in the Monkey programming language: <code>!</code> and <code>-</code>. Their usage is pretty much what you’d expect from other languages:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb131-1" data-line-number="1"><span class="dv">-5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb131-2" data-line-number="2"><span class="op">!</span>foobar<span class="op">;</span></a>
<a class="sourceLine" id="cb131-3" data-line-number="3"><span class="dv">5</span> <span class="op">+</span> <span class="dv">-10</span><span class="op">;</span></a></code></pre></div>
<p>The structure of their usage is the following:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb132-1" data-line-number="1">&lt;prefix operator&gt;&lt;expression&gt;;</a></code></pre></div>
<p>Yes, that’s right. Any expression can follow a prefix operator as operand. These are valid:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb133-1" data-line-number="1"><span class="op">!</span><span class="at">isGreaterThanZero</span>(<span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb133-2" data-line-number="2"><span class="dv">5</span> <span class="op">+</span> <span class="op">-</span><span class="at">add</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></a></code></pre></div>
<p>That means that an AST node for a prefix operator expression has to be flexible enough to point to any expression as its operand.</p>
<p>But first things first, here is the test case for prefix operators, or “prefix expressions”:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb134-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb134-2" data-line-number="2"></a>
<a class="sourceLine" id="cb134-3" data-line-number="3"><span class="kw">func</span> TestParsingPrefixExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb134-4" data-line-number="4">    prefixTests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb134-5" data-line-number="5">        input        <span class="dt">string</span></a>
<a class="sourceLine" id="cb134-6" data-line-number="6">        operator     <span class="dt">string</span></a>
<a class="sourceLine" id="cb134-7" data-line-number="7">        integerValue <span class="dt">int64</span></a>
<a class="sourceLine" id="cb134-8" data-line-number="8">    }{</a>
<a class="sourceLine" id="cb134-9" data-line-number="9">        {<span class="st">&quot;!5;&quot;</span>, <span class="st">&quot;!&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb134-10" data-line-number="10">        {<span class="st">&quot;-15;&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="dv">15</span>},</a>
<a class="sourceLine" id="cb134-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb134-12" data-line-number="12"></a>
<a class="sourceLine" id="cb134-13" data-line-number="13">    <span class="kw">for</span> _, tt := <span class="kw">range</span> prefixTests {</a>
<a class="sourceLine" id="cb134-14" data-line-number="14">        l := lexer.New(tt.input)</a>
<a class="sourceLine" id="cb134-15" data-line-number="15">        p := New(l)</a>
<a class="sourceLine" id="cb134-16" data-line-number="16">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb134-17" data-line-number="17">        checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb134-18" data-line-number="18"></a>
<a class="sourceLine" id="cb134-19" data-line-number="19">        <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb134-20" data-line-number="20">            t.Fatalf(<span class="st">&quot;program.Statements does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb134-21" data-line-number="21">                <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb134-22" data-line-number="22">        }</a>
<a class="sourceLine" id="cb134-23" data-line-number="23"></a>
<a class="sourceLine" id="cb134-24" data-line-number="24">        stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb134-25" data-line-number="25">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb134-26" data-line-number="26">            t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb134-27" data-line-number="27">                program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb134-28" data-line-number="28">        }</a>
<a class="sourceLine" id="cb134-29" data-line-number="29"></a>
<a class="sourceLine" id="cb134-30" data-line-number="30">        exp, ok := stmt.Expression.(*ast.PrefixExpression)</a>
<a class="sourceLine" id="cb134-31" data-line-number="31">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb134-32" data-line-number="32">            t.Fatalf(<span class="st">&quot;stmt is not ast.PrefixExpression. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb134-33" data-line-number="33">        }</a>
<a class="sourceLine" id="cb134-34" data-line-number="34">        <span class="kw">if</span> exp.Operator != tt.operator {</a>
<a class="sourceLine" id="cb134-35" data-line-number="35">            t.Fatalf(<span class="st">&quot;exp.Operator is not &#39;%s&#39;. got=%s&quot;</span>,</a>
<a class="sourceLine" id="cb134-36" data-line-number="36">                tt.operator, exp.Operator)</a>
<a class="sourceLine" id="cb134-37" data-line-number="37">        }</a>
<a class="sourceLine" id="cb134-38" data-line-number="38">        <span class="kw">if</span> !testIntegerLiteral(t, exp.Right, tt.integerValue) {</a>
<a class="sourceLine" id="cb134-39" data-line-number="39">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb134-40" data-line-number="40">        }</a>
<a class="sourceLine" id="cb134-41" data-line-number="41">    }</a>
<a class="sourceLine" id="cb134-42" data-line-number="42">}</a></code></pre></div>
<p>This test function, again, has a lot of lines. For two reasons: manually creating error messages with <code>t.Errorf</code> takes up some space and we’re using a table-driven testing approach. The reason for this approach is that it saves us a lot of test code. Yes, it’s only two test cases, but duplicating the complete test setup for each case would mean a lot more lines. And since the logic behind the test assertions is the same, we share the test setup. Both test cases (<code>!5</code> and <code>-15</code> as input) differ only in the expected operators and integer values (which we define here in <code>prefixTests</code>).</p>
<p>In the test function we iterate through our slice of test inputs and make assertions about the produced AST based on the values defined in the <code>prefixTests</code> slice of structs. As you can see, at the end we use a new helper function called <code>testIntegerLiteral</code> to test that the <code>Right</code> value of <code>*ast.PrefixExpression</code> is the correct integer literal. We introduce this helper function here, so the focus of the test case is on <code>*ast.PrefixExpression</code> and its fields and we will soon enough need it again. It looks like this:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb135-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb135-2" data-line-number="2"></a>
<a class="sourceLine" id="cb135-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb135-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb135-5" data-line-number="5">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb135-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb135-7" data-line-number="7"></a>
<a class="sourceLine" id="cb135-8" data-line-number="8"><span class="kw">func</span> testIntegerLiteral(t *testing.T, il ast.Expression, value <span class="dt">int64</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb135-9" data-line-number="9">    integ, ok := il.(*ast.IntegerLiteral)</a>
<a class="sourceLine" id="cb135-10" data-line-number="10">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb135-11" data-line-number="11">        t.Errorf(<span class="st">&quot;il not *ast.IntegerLiteral. got=%T&quot;</span>, il)</a>
<a class="sourceLine" id="cb135-12" data-line-number="12">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb135-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb135-14" data-line-number="14"></a>
<a class="sourceLine" id="cb135-15" data-line-number="15">    <span class="kw">if</span> integ.Value != value {</a>
<a class="sourceLine" id="cb135-16" data-line-number="16">        t.Errorf(<span class="st">&quot;integ.Value not %d. got=%d&quot;</span>, value, integ.Value)</a>
<a class="sourceLine" id="cb135-17" data-line-number="17">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb135-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb135-19" data-line-number="19"></a>
<a class="sourceLine" id="cb135-20" data-line-number="20">    <span class="kw">if</span> integ.TokenLiteral() != fmt.Sprintf(<span class="st">&quot;%d&quot;</span>, value) {</a>
<a class="sourceLine" id="cb135-21" data-line-number="21">        t.Errorf(<span class="st">&quot;integ.TokenLiteral not %d. got=%s&quot;</span>, value,</a>
<a class="sourceLine" id="cb135-22" data-line-number="22">            integ.TokenLiteral())</a>
<a class="sourceLine" id="cb135-23" data-line-number="23">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb135-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb135-25" data-line-number="25"></a>
<a class="sourceLine" id="cb135-26" data-line-number="26">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb135-27" data-line-number="27">}</a></code></pre></div>
<p>There is nothing new here, we’ve seen this before in <code>TestIntegerLiteralExpression</code>. But now it’s hidden behind a small helper function that makes these new tests more readable.</p>
<p>As expected the tests don’t even compile:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb136-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb136-2" data-line-number="2"># monkey/parser</a>
<a class="sourceLine" id="cb136-3" data-line-number="3">parser/parser_test.go:210: undefined: ast.PrefixExpression</a>
<a class="sourceLine" id="cb136-4" data-line-number="4">FAIL    monkey/parser [build failed]</a></code></pre></div>
<p>We need to define the <code>ast.PrefixExpression</code> node:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb137-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb137-2" data-line-number="2"></a>
<a class="sourceLine" id="cb137-3" data-line-number="3"><span class="kw">type</span> PrefixExpression <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb137-4" data-line-number="4">    Token    token.Token <span class="co">// The prefix token, e.g. !</span></a>
<a class="sourceLine" id="cb137-5" data-line-number="5">    Operator <span class="dt">string</span></a>
<a class="sourceLine" id="cb137-6" data-line-number="6">    Right    Expression</a>
<a class="sourceLine" id="cb137-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb137-8" data-line-number="8"></a>
<a class="sourceLine" id="cb137-9" data-line-number="9"><span class="kw">func</span> (pe *PrefixExpression) expressionNode()      {}</a>
<a class="sourceLine" id="cb137-10" data-line-number="10"><span class="kw">func</span> (pe *PrefixExpression) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> pe.Token.Literal }</a>
<a class="sourceLine" id="cb137-11" data-line-number="11"><span class="kw">func</span> (pe *PrefixExpression) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb137-12" data-line-number="12">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb137-13" data-line-number="13"></a>
<a class="sourceLine" id="cb137-14" data-line-number="14">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb137-15" data-line-number="15">    out.WriteString(pe.Operator)</a>
<a class="sourceLine" id="cb137-16" data-line-number="16">    out.WriteString(pe.Right.String())</a>
<a class="sourceLine" id="cb137-17" data-line-number="17">    out.WriteString(<span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb137-18" data-line-number="18"></a>
<a class="sourceLine" id="cb137-19" data-line-number="19">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb137-20" data-line-number="20">}</a></code></pre></div>
<p>This doesn’t contain any surprises. The <code>*ast.PrefixExpression</code> node has two noteworthy fields: <code>Operator</code> and <code>Right</code>. <code>Operator</code> is a string that’s going to contain either <code>&quot;-&quot;</code> or <code>&quot;!&quot;</code>. The <code>Right</code> field contains the expression to the right of the operator.</p>
<p>In the <code>String()</code> method we deliberately add parentheses around the operator and its operand, the expression in <code>Right</code>. That allows us to see which operands belong to which operator.</p>
<p>With <code>*ast.PrefixExpression</code> defined, the tests now fail with a strange error message:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb138-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb138-2" data-line-number="2">--- FAIL: TestParsingPrefixExpressions (0.00s)</a>
<a class="sourceLine" id="cb138-3" data-line-number="3">  parser_test.go:198: program.Statements does not contain 1 statements. got=2</a>
<a class="sourceLine" id="cb138-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb138-5" data-line-number="5">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>Why does <code>program.Statements</code> contain two statements instead of the expected one statement? The reason is that <code>parseExpression</code> doesn’t recognize our prefix operators yet and simply returns <code>nil</code>. <code>program.Statements</code> does not contain one statement but simply two <code>nil</code>s.</p>
<p>We can do better than this, we can extend our parser and the <code>parseExpression</code> method to give us better error messages when this happens:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb139-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb139-2" data-line-number="2"></a>
<a class="sourceLine" id="cb139-3" data-line-number="3"><span class="kw">func</span> (p *Parser) noPrefixParseFnError(t token.TokenType) {</a>
<a class="sourceLine" id="cb139-4" data-line-number="4">    msg := fmt.Sprintf(<span class="st">&quot;no prefix parse function for %s found&quot;</span>, t)</a>
<a class="sourceLine" id="cb139-5" data-line-number="5">    p.errors = <span class="bu">append</span>(p.errors, msg)</a>
<a class="sourceLine" id="cb139-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb139-7" data-line-number="7"></a>
<a class="sourceLine" id="cb139-8" data-line-number="8"><span class="kw">func</span> (p *Parser) parseExpression(precedence <span class="dt">int</span>) ast.Expression {</a>
<a class="sourceLine" id="cb139-9" data-line-number="9">    prefix := p.prefixParseFns[p.curToken.Type]</a>
<a class="sourceLine" id="cb139-10" data-line-number="10">    <span class="kw">if</span> prefix == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb139-11" data-line-number="11">        p.noPrefixParseFnError(p.curToken.Type)</a>
<a class="sourceLine" id="cb139-12" data-line-number="12">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb139-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb139-14" data-line-number="14">    leftExp := prefix()</a>
<a class="sourceLine" id="cb139-15" data-line-number="15"></a>
<a class="sourceLine" id="cb139-16" data-line-number="16">    <span class="kw">return</span> leftExp</a>
<a class="sourceLine" id="cb139-17" data-line-number="17">}</a></code></pre></div>
<p>The small helper method <code>noPrefixParseFnError</code> just adds a formatted error message to our parser’s <code>errors</code> field. But that’s enough to get better error messages in our failing test:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb140-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb140-2" data-line-number="2">--- FAIL: TestParsingPrefixExpressions (0.00s)</a>
<a class="sourceLine" id="cb140-3" data-line-number="3">  parser_test.go:227: parser has 1 errors</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">  parser_test.go:229: parser error: &quot;no prefix parse function for ! found&quot;</a>
<a class="sourceLine" id="cb140-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb140-6" data-line-number="6">FAIL    monkey/parser   0.010s</a></code></pre></div>
<p>Now it’s clear what we have to do: write a parsing function for prefix expressions and register it in our parser.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb141-2" data-line-number="2"></a>
<a class="sourceLine" id="cb141-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb141-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb141-5" data-line-number="5">    p.registerPrefix(token.BANG, p.parsePrefixExpression)</a>
<a class="sourceLine" id="cb141-6" data-line-number="6">    p.registerPrefix(token.MINUS, p.parsePrefixExpression)</a>
<a class="sourceLine" id="cb141-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb141-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb141-9" data-line-number="9"></a>
<a class="sourceLine" id="cb141-10" data-line-number="10"><span class="kw">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</a>
<a class="sourceLine" id="cb141-11" data-line-number="11">    expression := &amp;ast.PrefixExpression{</a>
<a class="sourceLine" id="cb141-12" data-line-number="12">        Token:    p.curToken,</a>
<a class="sourceLine" id="cb141-13" data-line-number="13">        Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb141-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb141-15" data-line-number="15"></a>
<a class="sourceLine" id="cb141-16" data-line-number="16">    p.nextToken()</a>
<a class="sourceLine" id="cb141-17" data-line-number="17"></a>
<a class="sourceLine" id="cb141-18" data-line-number="18">    expression.Right = p.parseExpression(PREFIX)</a>
<a class="sourceLine" id="cb141-19" data-line-number="19"></a>
<a class="sourceLine" id="cb141-20" data-line-number="20">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb141-21" data-line-number="21">}</a></code></pre></div>
<p>For <code>token.BANG</code> and <code>token.MINUS</code> we register the same method as <code>prefixParseFn</code>: the newly created <code>parsePrefixExpression</code>. This method builds an AST node, in this case <code>*ast.PrefixExpression</code>, just like the parsing functions we saw before. But then it does something different: it actually advances our tokens by calling <code>p.nextToken()</code>!</p>
<p>When <code>parsePrefixExpression</code> is called, <code>p.curToken</code> is either of type <code>token.BANG</code> or <code>token.MINUS</code>, because otherwise it wouldn’t have been called. But in order to correctly parse a prefix expression like <code>-5</code> more than one token has to be “consumed”. So after using <code>p.curToken</code> to build a <code>*ast.PrefixExpression</code> node, the method advances the tokens and calls <code>parseExpression</code> again. This time with the precedence of prefix operators as argument. It’s still unused, but we’ll shortly see what it’s good for and how to make use of it.</p>
<p>Now, when <code>parseExpression</code> is called by <code>parsePrefixExpression</code> the tokens have been advanced and the current token is the one after the prefix operator. In the case of <code>-5</code>, when <code>parseExpression</code> is called the <code>p.curToken.Type</code> is <code>token.INT</code>. <code>parseExpression</code> then checks the registered prefix parsing functions and finds <code>parseIntegerLiteral</code>, which builds an <code>*ast.IntegerLiteral</code> node and returns it. <code>parseExpression</code> returns this newly constructed node and <code>parsePrefixExpression</code> uses it to fill the <code>Right</code> field of <code>*ast.PrefixExpression</code>.</p>
<p>Yes, this works, our tests pass:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb142-1" data-line-number="1">$ <span class="kw">go</span> test ./parser</a>
<a class="sourceLine" id="cb142-2" data-line-number="2">ok      monkey/parser   <span class="dv">0</span><span class="fl">.007</span>s</a></code></pre></div>
<p>Note how the “protocol” for our parsing functions plays out here: <code>parsePrefixExpression</code> starts with <code>p.curToken</code> being the token of the prefix operator and it returns with <code>p.curToken</code> being the operand of the prefix expression, which is the last token of the expression. The tokens get advanced just enough, which works beautifully. The neat thing is how few lines of code are needed for this. The power lies in the recursive approach.</p>
<p>Granted, the <code>precedence</code> argument in <code>parseExpression</code> is confusing, since it’s unused. But we’ve already seen something important about its usage: the value changes depending on the caller’s knowledge and its context. <code>parseExpressionStatement</code> (the top-level method that kicks off expression parsing here) knows nothing about a precedence level and just uses <code>LOWEST</code>. But <code>parsePrefixExpression</code> passes the <code>PREFIX</code> precedence to <code>parseExpression</code>, since it’s parsing a prefix expression.</p>
<p>And now we’ll see how <code>precedence</code> in <code>parseExpression</code> is used. Because now we’re going to parse infix expressions.</p>
<h3 id="infix-operators">Infix Operators</h3>
<p>Next up we’re going to parse these eight infix operators:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb143-1" data-line-number="1"><span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-2" data-line-number="2"><span class="dv">5</span> <span class="op">-</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-3" data-line-number="3"><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-4" data-line-number="4"><span class="dv">5</span> / <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-5" data-line-number="5"><span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-6" data-line-number="6"><span class="dv">5</span> <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-7" data-line-number="7"><span class="dv">5</span> <span class="op">==</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb143-8" data-line-number="8"><span class="dv">5</span> <span class="op">!=</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>Don’t be bothered by the <code>5</code> here. As with prefix operator expressions, we can use any expressions to the left and right of the operator.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb144-1" data-line-number="1">&lt;expression&gt; &lt;infix operator&gt; &lt;expression&gt;</a></code></pre></div>
<p>Because of the two operands (left and right) these expressions are sometimes called “binary expressions” (whereas our prefix expressions would be called “unary expressions”). Even though we can use any expressions on either side of the operator, we’re going to start by writing a test that only uses integer literals as operands. As soon as we can get the test to pass, we’ll extend it to incorporate more operand types. Here it is:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb145-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb145-2" data-line-number="2"></a>
<a class="sourceLine" id="cb145-3" data-line-number="3"><span class="kw">func</span> TestParsingInfixExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb145-4" data-line-number="4">    infixTests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb145-5" data-line-number="5">        input      <span class="dt">string</span></a>
<a class="sourceLine" id="cb145-6" data-line-number="6">        leftValue  <span class="dt">int64</span></a>
<a class="sourceLine" id="cb145-7" data-line-number="7">        operator   <span class="dt">string</span></a>
<a class="sourceLine" id="cb145-8" data-line-number="8">        rightValue <span class="dt">int64</span></a>
<a class="sourceLine" id="cb145-9" data-line-number="9">    }{</a>
<a class="sourceLine" id="cb145-10" data-line-number="10">        {<span class="st">&quot;5 + 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-11" data-line-number="11">        {<span class="st">&quot;5 - 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;-&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-12" data-line-number="12">        {<span class="st">&quot;5 * 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;*&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-13" data-line-number="13">        {<span class="st">&quot;5 / 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;/&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-14" data-line-number="14">        {<span class="st">&quot;5 &gt; 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;&gt;&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-15" data-line-number="15">        {<span class="st">&quot;5 &lt; 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;&lt;&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-16" data-line-number="16">        {<span class="st">&quot;5 == 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;==&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-17" data-line-number="17">        {<span class="st">&quot;5 != 5;&quot;</span>, <span class="dv">5</span>, <span class="st">&quot;!=&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb145-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb145-19" data-line-number="19"></a>
<a class="sourceLine" id="cb145-20" data-line-number="20">    <span class="kw">for</span> _, tt := <span class="kw">range</span> infixTests {</a>
<a class="sourceLine" id="cb145-21" data-line-number="21">        l := lexer.New(tt.input)</a>
<a class="sourceLine" id="cb145-22" data-line-number="22">        p := New(l)</a>
<a class="sourceLine" id="cb145-23" data-line-number="23">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb145-24" data-line-number="24">        checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb145-25" data-line-number="25"></a>
<a class="sourceLine" id="cb145-26" data-line-number="26">        <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb145-27" data-line-number="27">            t.Fatalf(<span class="st">&quot;program.Statements does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb145-28" data-line-number="28">                <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb145-29" data-line-number="29">        }</a>
<a class="sourceLine" id="cb145-30" data-line-number="30"></a>
<a class="sourceLine" id="cb145-31" data-line-number="31">        stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb145-32" data-line-number="32">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb145-33" data-line-number="33">            t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb145-34" data-line-number="34">                program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb145-35" data-line-number="35">        }</a>
<a class="sourceLine" id="cb145-36" data-line-number="36"></a>
<a class="sourceLine" id="cb145-37" data-line-number="37">        exp, ok := stmt.Expression.(*ast.InfixExpression)</a>
<a class="sourceLine" id="cb145-38" data-line-number="38">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb145-39" data-line-number="39">            t.Fatalf(<span class="st">&quot;exp is not ast.InfixExpression. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb145-40" data-line-number="40">        }</a>
<a class="sourceLine" id="cb145-41" data-line-number="41"></a>
<a class="sourceLine" id="cb145-42" data-line-number="42">        <span class="kw">if</span> !testIntegerLiteral(t, exp.Left, tt.leftValue) {</a>
<a class="sourceLine" id="cb145-43" data-line-number="43">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb145-44" data-line-number="44">        }</a>
<a class="sourceLine" id="cb145-45" data-line-number="45"></a>
<a class="sourceLine" id="cb145-46" data-line-number="46">        <span class="kw">if</span> exp.Operator != tt.operator {</a>
<a class="sourceLine" id="cb145-47" data-line-number="47">            t.Fatalf(<span class="st">&quot;exp.Operator is not &#39;%s&#39;. got=%s&quot;</span>,</a>
<a class="sourceLine" id="cb145-48" data-line-number="48">                tt.operator, exp.Operator)</a>
<a class="sourceLine" id="cb145-49" data-line-number="49">        }</a>
<a class="sourceLine" id="cb145-50" data-line-number="50"></a>
<a class="sourceLine" id="cb145-51" data-line-number="51">        <span class="kw">if</span> !testIntegerLiteral(t, exp.Right, tt.rightValue) {</a>
<a class="sourceLine" id="cb145-52" data-line-number="52">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb145-53" data-line-number="53">        }</a>
<a class="sourceLine" id="cb145-54" data-line-number="54">    }</a>
<a class="sourceLine" id="cb145-55" data-line-number="55">}</a></code></pre></div>
<p>This test is nearly a straight copy of <code>TestParsingPrefixExpressions</code>, except that we now make assertions about the <code>Right</code> <em>and</em> <code>Left</code> fields of the resulting AST node. Here the table-driven approach gives us great leverage that we’ll soon use when we extend the test to also include identifiers.</p>
<p>The tests fail, of course, because they can’t find a definition of <code>*ast.InfixExpression</code>. And in order to get real failing tests, we define <code>ast.InfixExpression</code>:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb146-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb146-2" data-line-number="2"></a>
<a class="sourceLine" id="cb146-3" data-line-number="3"><span class="kw">type</span> InfixExpression <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb146-4" data-line-number="4">    Token    token.Token <span class="co">// The operator token, e.g. +</span></a>
<a class="sourceLine" id="cb146-5" data-line-number="5">    Left     Expression</a>
<a class="sourceLine" id="cb146-6" data-line-number="6">    Operator <span class="dt">string</span></a>
<a class="sourceLine" id="cb146-7" data-line-number="7">    Right    Expression</a>
<a class="sourceLine" id="cb146-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb146-9" data-line-number="9"></a>
<a class="sourceLine" id="cb146-10" data-line-number="10"><span class="kw">func</span> (ie *InfixExpression) expressionNode()      {}</a>
<a class="sourceLine" id="cb146-11" data-line-number="11"><span class="kw">func</span> (ie *InfixExpression) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> ie.Token.Literal }</a>
<a class="sourceLine" id="cb146-12" data-line-number="12"><span class="kw">func</span> (ie *InfixExpression) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb146-13" data-line-number="13">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb146-14" data-line-number="14"></a>
<a class="sourceLine" id="cb146-15" data-line-number="15">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb146-16" data-line-number="16">    out.WriteString(ie.Left.String())</a>
<a class="sourceLine" id="cb146-17" data-line-number="17">    out.WriteString(<span class="st">&quot; &quot;</span> + ie.Operator + <span class="st">&quot; &quot;</span>)</a>
<a class="sourceLine" id="cb146-18" data-line-number="18">    out.WriteString(ie.Right.String())</a>
<a class="sourceLine" id="cb146-19" data-line-number="19">    out.WriteString(<span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb146-20" data-line-number="20"></a>
<a class="sourceLine" id="cb146-21" data-line-number="21">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb146-22" data-line-number="22">}</a></code></pre></div>
<p>Just like with <code>ast.PrefixExpression</code>, we define <code>ast.InfixExpression</code> to fulfill the <code>ast.Expression</code> and <code>ast.Node</code> interfaces, by defining the <code>expressionNode()</code>, <code>TokenLiteral()</code> and <code>String()</code> methods. The only difference to <code>ast.PrefixExpression</code> is the new field called <code>Left</code>, which can hold any expression.</p>
<p>With that out of the way, we can build and run our tests. And the tests even return one of our own new error messages:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb147-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb147-2" data-line-number="2">--- FAIL: TestParsingInfixExpressions (0.00s)</a>
<a class="sourceLine" id="cb147-3" data-line-number="3">  parser_test.go:246: parser has 1 errors</a>
<a class="sourceLine" id="cb147-4" data-line-number="4">  parser_test.go:248: parser error: &quot;no prefix parse function for + found&quot;</a>
<a class="sourceLine" id="cb147-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb147-6" data-line-number="6">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>But that error message is deceiving. It says “no prefix parse function for + found”. The problem is that we do not want our parser to find a prefix parse function for <code>+</code>. We want it to find an infix parse function.</p>
<p>This is the point where we’re going from “I guess it’s neat” to “Wow, this is beautiful”, because we now need to complete our <code>parseExpression</code> method. And to do that, we first need a precedence table and a few helper methods:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb148-2" data-line-number="2"></a>
<a class="sourceLine" id="cb148-3" data-line-number="3"><span class="kw">var</span> precedences = <span class="kw">map</span>[token.TokenType]<span class="dt">int</span>{</a>
<a class="sourceLine" id="cb148-4" data-line-number="4">    token.EQ:       EQUALS,</a>
<a class="sourceLine" id="cb148-5" data-line-number="5">    token.NOT_EQ:   EQUALS,</a>
<a class="sourceLine" id="cb148-6" data-line-number="6">    token.LT:       LESSGREATER,</a>
<a class="sourceLine" id="cb148-7" data-line-number="7">    token.GT:       LESSGREATER,</a>
<a class="sourceLine" id="cb148-8" data-line-number="8">    token.PLUS:     SUM,</a>
<a class="sourceLine" id="cb148-9" data-line-number="9">    token.MINUS:    SUM,</a>
<a class="sourceLine" id="cb148-10" data-line-number="10">    token.SLASH:    PRODUCT,</a>
<a class="sourceLine" id="cb148-11" data-line-number="11">    token.ASTERISK: PRODUCT,</a>
<a class="sourceLine" id="cb148-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb148-13" data-line-number="13"></a>
<a class="sourceLine" id="cb148-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb148-15" data-line-number="15"></a>
<a class="sourceLine" id="cb148-16" data-line-number="16"><span class="kw">func</span> (p *Parser) peekPrecedence() <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb148-17" data-line-number="17">    <span class="kw">if</span> p, ok := precedences[p.peekToken.Type]; ok {</a>
<a class="sourceLine" id="cb148-18" data-line-number="18">        <span class="kw">return</span> p</a>
<a class="sourceLine" id="cb148-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb148-20" data-line-number="20"></a>
<a class="sourceLine" id="cb148-21" data-line-number="21">    <span class="kw">return</span> LOWEST</a>
<a class="sourceLine" id="cb148-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb148-23" data-line-number="23"></a>
<a class="sourceLine" id="cb148-24" data-line-number="24"><span class="kw">func</span> (p *Parser) curPrecedence() <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb148-25" data-line-number="25">    <span class="kw">if</span> p, ok := precedences[p.curToken.Type]; ok {</a>
<a class="sourceLine" id="cb148-26" data-line-number="26">        <span class="kw">return</span> p</a>
<a class="sourceLine" id="cb148-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb148-28" data-line-number="28"></a>
<a class="sourceLine" id="cb148-29" data-line-number="29">    <span class="kw">return</span> LOWEST</a>
<a class="sourceLine" id="cb148-30" data-line-number="30">}</a></code></pre></div>
<p><code>precedences</code> is our precedence table: it associates token types with their precedence. The precedence values themselves are the constants we defined earlier, the integers with increasing value. This table can now tell us that <code>+</code> (<code>token.PLUS</code>) and <code>-</code> (<code>token.MINUS</code>) have the same precedence, which is lower than the precedence of <code>*</code> (<code>token.ASTERISK</code>) and <code>/</code> (<code>token.SLASH</code>), for example.</p>
<p>The <code>peekPrecedence</code> method returns the precedence associated with the token type of <code>p.peekToken</code>. If it doesn’t find a precedence for <code>p.peekToken</code> it defaults to <code>LOWEST</code>, the lowest possible precedence any operator can have. The <code>curPrecedence</code> method does the same thing, but for <code>p.curToken</code>.</p>
<p>The next step is to register one infix parse function for all of our infix operators:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb149-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb149-2" data-line-number="2"></a>
<a class="sourceLine" id="cb149-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb149-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb149-5" data-line-number="5">    p.infixParseFns = <span class="bu">make</span>(<span class="kw">map</span>[token.TokenType]infixParseFn)</a>
<a class="sourceLine" id="cb149-6" data-line-number="6">    p.registerInfix(token.PLUS, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-7" data-line-number="7">    p.registerInfix(token.MINUS, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-8" data-line-number="8">    p.registerInfix(token.SLASH, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-9" data-line-number="9">    p.registerInfix(token.ASTERISK, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-10" data-line-number="10">    p.registerInfix(token.EQ, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-11" data-line-number="11">    p.registerInfix(token.NOT_EQ, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-12" data-line-number="12">    p.registerInfix(token.LT, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-13" data-line-number="13">    p.registerInfix(token.GT, p.parseInfixExpression)</a>
<a class="sourceLine" id="cb149-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb149-15" data-line-number="15">}</a></code></pre></div>
<p>We already have the <code>registerInfix</code> method in our repertoire and now we finally use it. Every infix operator gets associated with the same parsing function called <code>parseInfixExpression</code>, which looks like this:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb150-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb150-2" data-line-number="2"></a>
<a class="sourceLine" id="cb150-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb150-4" data-line-number="4">    expression := &amp;ast.InfixExpression{</a>
<a class="sourceLine" id="cb150-5" data-line-number="5">        Token:    p.curToken,</a>
<a class="sourceLine" id="cb150-6" data-line-number="6">        Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb150-7" data-line-number="7">        Left:     left,</a>
<a class="sourceLine" id="cb150-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb150-9" data-line-number="9"></a>
<a class="sourceLine" id="cb150-10" data-line-number="10">    precedence := p.curPrecedence()</a>
<a class="sourceLine" id="cb150-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb150-12" data-line-number="12">    expression.Right = p.parseExpression(precedence)</a>
<a class="sourceLine" id="cb150-13" data-line-number="13"></a>
<a class="sourceLine" id="cb150-14" data-line-number="14">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb150-15" data-line-number="15">}</a></code></pre></div>
<p>The notable difference here is that, in contrast to <code>parsePrefixExpression</code>, this new method takes an argument, an <code>ast.Expression</code> called <code>left</code>. It uses this argument to construct an <code>*ast.InfixExpression</code> node, with <code>left</code> being in the <code>Left</code> field. Then it assigns the precedence of the current token (which is the operator of the infix expression) to the local variable <code>precedence</code>, before advancing the tokens by calling <code>nextToken</code> and filling the <code>Right</code> field of the node with another call to <code>parseExpression</code> - this time passing in the precedence of the operator token.</p>
<p>It’s time to lift the curtain. Here is the heart of our Pratt parser, here is the final version of <code>parseExpression</code>:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb151-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb151-2" data-line-number="2"></a>
<a class="sourceLine" id="cb151-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseExpression(precedence <span class="dt">int</span>) ast.Expression {</a>
<a class="sourceLine" id="cb151-4" data-line-number="4">    prefix := p.prefixParseFns[p.curToken.Type]</a>
<a class="sourceLine" id="cb151-5" data-line-number="5">    <span class="kw">if</span> prefix == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb151-6" data-line-number="6">        p.noPrefixParseFnError(p.curToken.Type)</a>
<a class="sourceLine" id="cb151-7" data-line-number="7">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb151-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb151-9" data-line-number="9">    leftExp := prefix()</a>
<a class="sourceLine" id="cb151-10" data-line-number="10"></a>
<a class="sourceLine" id="cb151-11" data-line-number="11">    <span class="kw">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</a>
<a class="sourceLine" id="cb151-12" data-line-number="12">        infix := p.infixParseFns[p.peekToken.Type]</a>
<a class="sourceLine" id="cb151-13" data-line-number="13">        <span class="kw">if</span> infix == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb151-14" data-line-number="14">            <span class="kw">return</span> leftExp</a>
<a class="sourceLine" id="cb151-15" data-line-number="15">        }</a>
<a class="sourceLine" id="cb151-16" data-line-number="16"></a>
<a class="sourceLine" id="cb151-17" data-line-number="17">        p.nextToken()</a>
<a class="sourceLine" id="cb151-18" data-line-number="18"></a>
<a class="sourceLine" id="cb151-19" data-line-number="19">        leftExp = infix(leftExp)</a>
<a class="sourceLine" id="cb151-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb151-21" data-line-number="21"></a>
<a class="sourceLine" id="cb151-22" data-line-number="22">    <span class="kw">return</span> leftExp</a>
<a class="sourceLine" id="cb151-23" data-line-number="23">}</a></code></pre></div>
<p>And, boom! Our tests pass! It’s all green, baby:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb152-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb152-2" data-line-number="2">ok      monkey/parser   0.006s</a></code></pre></div>
<p>We are now officially able to parse infix operator expressions correctly! <em>Wait, what? What the hell did just happen? How does this work?</em></p>
<p>Obviously <code>parseExpression</code> now does a few more things. We already know how it finds an associated <code>prefixParseFn</code> with the current token and calls it. We’ve seen this work with prefix operators, identifiers and integer literals.</p>
<p>What’s new is the loop right in the middle of <code>parseExpression</code>. In the loop’s body the method tries to find <code>infixParseFn</code>s for the next token. If it finds such a function, it calls it, passing in the expression returned by a <code>prefixParseFn</code> as an argument. And it does all this again and again until it encounters a token that has a lower precedence.</p>
<p>This works beautifully. Look at these tests that use multiple operators with different precedences and how the AST in string form correctly represents this:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb153-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb153-2" data-line-number="2"></a>
<a class="sourceLine" id="cb153-3" data-line-number="3"><span class="kw">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb153-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb153-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb153-6" data-line-number="6">        expected <span class="dt">string</span></a>
<a class="sourceLine" id="cb153-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb153-8" data-line-number="8">        {</a>
<a class="sourceLine" id="cb153-9" data-line-number="9">            <span class="st">&quot;-a * b&quot;</span>,</a>
<a class="sourceLine" id="cb153-10" data-line-number="10">            <span class="st">&quot;((-a) * b)&quot;</span>,</a>
<a class="sourceLine" id="cb153-11" data-line-number="11">        },</a>
<a class="sourceLine" id="cb153-12" data-line-number="12">        {</a>
<a class="sourceLine" id="cb153-13" data-line-number="13">            <span class="st">&quot;!-a&quot;</span>,</a>
<a class="sourceLine" id="cb153-14" data-line-number="14">            <span class="st">&quot;(!(-a))&quot;</span>,</a>
<a class="sourceLine" id="cb153-15" data-line-number="15">        },</a>
<a class="sourceLine" id="cb153-16" data-line-number="16">        {</a>
<a class="sourceLine" id="cb153-17" data-line-number="17">            <span class="st">&quot;a + b + c&quot;</span>,</a>
<a class="sourceLine" id="cb153-18" data-line-number="18">            <span class="st">&quot;((a + b) + c)&quot;</span>,</a>
<a class="sourceLine" id="cb153-19" data-line-number="19">        },</a>
<a class="sourceLine" id="cb153-20" data-line-number="20">        {</a>
<a class="sourceLine" id="cb153-21" data-line-number="21">            <span class="st">&quot;a + b - c&quot;</span>,</a>
<a class="sourceLine" id="cb153-22" data-line-number="22">            <span class="st">&quot;((a + b) - c)&quot;</span>,</a>
<a class="sourceLine" id="cb153-23" data-line-number="23">        },</a>
<a class="sourceLine" id="cb153-24" data-line-number="24">        {</a>
<a class="sourceLine" id="cb153-25" data-line-number="25">            <span class="st">&quot;a * b * c&quot;</span>,</a>
<a class="sourceLine" id="cb153-26" data-line-number="26">            <span class="st">&quot;((a * b) * c)&quot;</span>,</a>
<a class="sourceLine" id="cb153-27" data-line-number="27">        },</a>
<a class="sourceLine" id="cb153-28" data-line-number="28">        {</a>
<a class="sourceLine" id="cb153-29" data-line-number="29">            <span class="st">&quot;a * b / c&quot;</span>,</a>
<a class="sourceLine" id="cb153-30" data-line-number="30">            <span class="st">&quot;((a * b) / c)&quot;</span>,</a>
<a class="sourceLine" id="cb153-31" data-line-number="31">        },</a>
<a class="sourceLine" id="cb153-32" data-line-number="32">        {</a>
<a class="sourceLine" id="cb153-33" data-line-number="33">            <span class="st">&quot;a + b / c&quot;</span>,</a>
<a class="sourceLine" id="cb153-34" data-line-number="34">            <span class="st">&quot;(a + (b / c))&quot;</span>,</a>
<a class="sourceLine" id="cb153-35" data-line-number="35">        },</a>
<a class="sourceLine" id="cb153-36" data-line-number="36">        {</a>
<a class="sourceLine" id="cb153-37" data-line-number="37">            <span class="st">&quot;a + b * c + d / e - f&quot;</span>,</a>
<a class="sourceLine" id="cb153-38" data-line-number="38">            <span class="st">&quot;(((a + (b * c)) + (d / e)) - f)&quot;</span>,</a>
<a class="sourceLine" id="cb153-39" data-line-number="39">        },</a>
<a class="sourceLine" id="cb153-40" data-line-number="40">        {</a>
<a class="sourceLine" id="cb153-41" data-line-number="41">            <span class="st">&quot;3 + 4; -5 * 5&quot;</span>,</a>
<a class="sourceLine" id="cb153-42" data-line-number="42">            <span class="st">&quot;(3 + 4)((-5) * 5)&quot;</span>,</a>
<a class="sourceLine" id="cb153-43" data-line-number="43">        },</a>
<a class="sourceLine" id="cb153-44" data-line-number="44">        {</a>
<a class="sourceLine" id="cb153-45" data-line-number="45">            <span class="st">&quot;5 &gt; 4 == 3 &lt; 4&quot;</span>,</a>
<a class="sourceLine" id="cb153-46" data-line-number="46">            <span class="st">&quot;((5 &gt; 4) == (3 &lt; 4))&quot;</span>,</a>
<a class="sourceLine" id="cb153-47" data-line-number="47">        },</a>
<a class="sourceLine" id="cb153-48" data-line-number="48">        {</a>
<a class="sourceLine" id="cb153-49" data-line-number="49">            <span class="st">&quot;5 &lt; 4 != 3 &gt; 4&quot;</span>,</a>
<a class="sourceLine" id="cb153-50" data-line-number="50">            <span class="st">&quot;((5 &lt; 4) != (3 &gt; 4))&quot;</span>,</a>
<a class="sourceLine" id="cb153-51" data-line-number="51">        },</a>
<a class="sourceLine" id="cb153-52" data-line-number="52">        {</a>
<a class="sourceLine" id="cb153-53" data-line-number="53">            <span class="st">&quot;3 + 4 * 5 == 3 * 1 + 4 * 5&quot;</span>,</a>
<a class="sourceLine" id="cb153-54" data-line-number="54">            <span class="st">&quot;((3 + (4 * 5)) == ((3 * 1) + (4 * 5)))&quot;</span>,</a>
<a class="sourceLine" id="cb153-55" data-line-number="55">        },</a>
<a class="sourceLine" id="cb153-56" data-line-number="56">    }</a>
<a class="sourceLine" id="cb153-57" data-line-number="57"></a>
<a class="sourceLine" id="cb153-58" data-line-number="58">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb153-59" data-line-number="59">        l := lexer.New(tt.input)</a>
<a class="sourceLine" id="cb153-60" data-line-number="60">        p := New(l)</a>
<a class="sourceLine" id="cb153-61" data-line-number="61">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb153-62" data-line-number="62">        checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb153-63" data-line-number="63"></a>
<a class="sourceLine" id="cb153-64" data-line-number="64">        actual := program.String()</a>
<a class="sourceLine" id="cb153-65" data-line-number="65">        <span class="kw">if</span> actual != tt.expected {</a>
<a class="sourceLine" id="cb153-66" data-line-number="66">            t.Errorf(<span class="st">&quot;expected=%q, got=%q&quot;</span>, tt.expected, actual)</a>
<a class="sourceLine" id="cb153-67" data-line-number="67">        }</a>
<a class="sourceLine" id="cb153-68" data-line-number="68">    }</a>
<a class="sourceLine" id="cb153-69" data-line-number="69">}</a></code></pre></div>
<p>They’re all passing! That’s pretty amazing, isn’t it?</p>
<p>The different <code>*ast.InfixExpression</code>s are nested correctly, which we can observe thanks to our usage of parentheses in the <code>String()</code> methods of the AST nodes.</p>
<p>If you’re scratching your head and wondering how all of this works, don’t worry. We’re now going to take a really close look at our <code>parseExpression</code> method.</p>
<h2 id="how-pratt-parsing-works">2.7 - How Pratt Parsing Works</h2>
<p>The algorithm behind the <code>parseExpression</code> method and its combination of parsing functions and precedences is fully described by Vaughan Pratt in his “Top Down Operator Precedence” paper. But there are differences between his and our implementation.</p>
<p>Pratt doesn’t use a <code>Parser</code> structure and doesn’t pass around methods defined on <code>*Parser</code>. He also doesn’t use maps and, of course, he didn’t use Go. His paper predates the release of Go by 36 years. And then there are naming differences: what we call <code>prefixParseFn</code>s are “nuds” (for “null denotations”) for Pratt. <code>infixParseFns</code> are “leds” (for “left denotations”).</p>
<p>Formulated in pseudocode though, our <code>parseExpression</code> method looks strikingly similar to the code presented in Pratt’s paper. It uses the same algorithm with barely any changes.</p>
<p>We’re going to skip the theory that answers <em>why</em> it works and just follow <em>how</em> it works and how all the pieces (<code>parseExpression</code>, parsing functions and precedences) fit together by looking at an example. Suppose we’re parsing the following expression statement:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb154-1" data-line-number="1"><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span><span class="op">;</span></a></code></pre></div>
<p>The big challenge here is not to represent every operator and operand in the resulting AST, but to nest the nodes of the AST correctly. What we want is an AST that (serialized as a string) looks like this:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb155-1" data-line-number="1">((<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>The AST needs to have two <code>*ast.InfixExpression</code> nodes. The <code>*ast.InfixExpression</code> higher in the tree should have the integer literal <code>3</code> as its <code>Right</code> child node and its <code>Left</code> child node needs to be the other <code>*ast.InfixExpression</code>. This second <code>*ast.InfixExpression</code> then needs to have the integer literals <code>1</code> and <code>2</code> as its <code>Left</code> and <code>Right</code> child nodes, respectively. Like this:</p>
<figure>
<img src="./images/infix_expression.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>And this is exactly what our parser outputs when it parses <code>1 + 2 + 3;</code>. But how? We’ll answer that question in the following paragraphs. We’re going take a close look at what the parser does as soon as <code>parseExpressionStatement</code> is called for the first time. It’s not a mistake to have the code open while reading the following paragraphs.</p>
<p>So here we go. Here is what happens when we parse <code>1 + 2 + 3;</code>:</p>
<p><code>parseExpressionStatement</code> calls <code>parseExpression(LOWEST)</code>. The <code>p.curToken</code> and <code>p.peekToken</code> are the <code>1</code> and the first <code>+</code>:</p>
<figure>
<img src="./images/curtoken_peektoken_1.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>The first thing <code>parseExpression</code> then does is to check whether there is a <code>prefixParseFn</code> associated with the current <code>p.curToken.Type</code>, which is a <code>token.INT</code>. And, yes, there is: <code>parseIntegerLiteral</code>. So it calls <code>parseIntegerLiteral</code>, which returns an <code>*ast.IntegerLiteral</code>. <code>parseExpression</code> assigns this to <code>leftExp</code>.</p>
<p>Then comes the new for-loop in <code>parseExpression</code>. Its condition evaluates to true:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb156-1" data-line-number="1"><span class="kw">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</a>
<a class="sourceLine" id="cb156-2" data-line-number="2"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb156-3" data-line-number="3">}</a></code></pre></div>
<p><code>p.peekToken</code> is not a <code>token.SEMICOLON</code> and <code>peekPrecedence</code> (which returns the precedence of the <code>+</code> token) is higher than the argument passed to <code>parseExpression</code>, which is <code>LOWEST</code>. Here are our defined precedences again to refresh our memory:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb157-2" data-line-number="2"></a>
<a class="sourceLine" id="cb157-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb157-4" data-line-number="4">    _ <span class="dt">int</span> = <span class="ot">iota</span></a>
<a class="sourceLine" id="cb157-5" data-line-number="5">    LOWEST</a>
<a class="sourceLine" id="cb157-6" data-line-number="6">    EQUALS      <span class="co">// ==</span></a>
<a class="sourceLine" id="cb157-7" data-line-number="7">    LESSGREATER <span class="co">// &gt; or &lt;</span></a>
<a class="sourceLine" id="cb157-8" data-line-number="8">    SUM         <span class="co">// +</span></a>
<a class="sourceLine" id="cb157-9" data-line-number="9">    PRODUCT     <span class="co">// *</span></a>
<a class="sourceLine" id="cb157-10" data-line-number="10">    PREFIX      <span class="co">// -X or !X</span></a>
<a class="sourceLine" id="cb157-11" data-line-number="11">    CALL        <span class="co">// myFunction(X)</span></a>
<a class="sourceLine" id="cb157-12" data-line-number="12">)</a></code></pre></div>
<p>So the condition evaluates to true and <code>parseExpression</code> executes the body of the loop, which looks like this:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb158-1" data-line-number="1">infix := p.infixParseFns[p.peekToken.Type]</a>
<a class="sourceLine" id="cb158-2" data-line-number="2"><span class="kw">if</span> infix == <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb158-3" data-line-number="3">  <span class="kw">return</span> leftExp</a>
<a class="sourceLine" id="cb158-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb158-5" data-line-number="5"></a>
<a class="sourceLine" id="cb158-6" data-line-number="6">p.nextToken()</a>
<a class="sourceLine" id="cb158-7" data-line-number="7"></a>
<a class="sourceLine" id="cb158-8" data-line-number="8">leftExp = infix(leftExp)</a></code></pre></div>
<p>Now it fetches the <code>infixParseFn</code> for <code>p.peekToken.Type</code>, which is <code>parseInfixExpression</code> defined on <code>*Parser</code>. Before calling it and assigning its return value to <code>leftExp</code> (reusing the <code>leftExp</code> variable!) it advances the tokens so they now look like this:</p>
<figure>
<img src="./images/curtoken_peektoken_2.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>With the tokens in this state, it calls <code>parseInfixExpression</code> and passes in the already parsed <code>*ast.IntegerLiteral</code> (assigned to <code>leftExp</code> outside the for-loop). What happens next in <code>parseInfixExpression</code> is where things get interesting. Here is the method again:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb159-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2"></a>
<a class="sourceLine" id="cb159-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb159-4" data-line-number="4">    expression := &amp;ast.InfixExpression{</a>
<a class="sourceLine" id="cb159-5" data-line-number="5">        Token:    p.curToken,</a>
<a class="sourceLine" id="cb159-6" data-line-number="6">        Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb159-7" data-line-number="7">        Left:     left,</a>
<a class="sourceLine" id="cb159-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb159-9" data-line-number="9"></a>
<a class="sourceLine" id="cb159-10" data-line-number="10">    precedence := p.curPrecedence()</a>
<a class="sourceLine" id="cb159-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb159-12" data-line-number="12">    expression.Right = p.parseExpression(precedence)</a>
<a class="sourceLine" id="cb159-13" data-line-number="13"></a>
<a class="sourceLine" id="cb159-14" data-line-number="14">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb159-15" data-line-number="15">}</a></code></pre></div>
<p>It’s important to note that <code>left</code> is our already parsed <code>*ast.IntegerLiteral</code> that represents the <code>1</code>.</p>
<p><code>parseInfixExpression</code> saves the precedence of <code>p.curToken</code> (the first <code>+</code> token!), advances the tokens and calls <code>parseExpression</code> - passing in the just saved precedence. So now <code>parseExpression</code> is called the second time, with the tokens looking like this:</p>
<figure>
<img src="./images/curtoken_peektoken_3.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>The first thing <code>parseExpression</code> does again is to look for a <code>prefixParseFn</code> for <code>p.curToken</code>. And again it’s <code>parseIntegerLiteral</code>. But now the condition of the for-loop doesn’t evaluate to true: <code>precedence</code> (the argument passed to <code>parseExpression</code>) is the precedence of the <em>first</em> <code>+</code> operator in <code>1 + 2 + 3</code>, which is <em>not</em> smaller than the precedence of <code>p.peekToken</code>, the second <code>+</code> operator. They are equal. The body of the for-loop is not executed and the <code>*ast.IntegerLiteral</code> representing the <code>2</code> is returned.</p>
<p>Now back in <code>parseInfixExpression</code> the return-value of <code>parseExpression</code> is assigned to the <code>Right</code> field of the newly constructed <code>*ast.InfixExpression</code>. So now we have this:</p>
<figure>
<img src="./images/first_infix_expression.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>This <code>*ast.InfixExpression</code> gets returned by <code>parseInfixExpression</code> and now we’re back in the outer-most call to <code>parseExpression</code>, where <code>precedence</code> is still <code>LOWEST</code>. We are back where we started and the condition of the for-loop is evaluated again.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb160-1" data-line-number="1"><span class="kw">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</a>
<a class="sourceLine" id="cb160-2" data-line-number="2"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb160-3" data-line-number="3">}</a></code></pre></div>
<p>This still evaluates to true, since <code>precedence</code> is <code>LOWEST</code> and <code>peekPrecedence</code> now returns the precedence of the second <code>+</code> in our expression, which is higher. <code>parseExpression</code> executes the body of the for-loop a second time. The difference is that now <code>leftExp</code> is not an <code>*ast.IntegerLiteral</code> representing the <code>1</code>, but the <code>*ast.InfixExpression</code> returned by <code>parseInfixExpression</code>, representing <code>1 + 2</code>.</p>
<p>In the body of the loop <code>parseExpression</code> fetches <code>parseInfixExpression</code> as the <code>infixParseFn</code> for <code>p.peekToken.Type</code> (which is the second <code>+</code>), advances the tokens and calls <code>parseInfixExpression</code> with <code>leftExp</code> as the argument. <code>parseInfixExpression</code> in turn calls <code>parseExpression</code> again, which returns the last <code>*ast.IntegerLiteral</code> (that represents the <code>3</code> in our expression).</p>
<p>After all this, at the end of the loop-body, <code>leftExp</code> looks like this:</p>
<figure>
<img src="./images/infix_expression.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>That’s exactly what we wanted! The operators and operands are nested correctly! And our tokens look like this:</p>
<figure>
<img src="./images/curtoken_peektoken_4.png" alt=" " width="400" /><figcaption> </figcaption>
</figure>
<p>The condition of the for-loop evaluates to false:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb161-1" data-line-number="1"><span class="kw">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</a>
<a class="sourceLine" id="cb161-2" data-line-number="2"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb161-3" data-line-number="3">}</a></code></pre></div>
<p>Now <code>p.peekTokenIs(token.SEMICOLON)</code> evaluates to true, which stops the body of the loop from being executed again.</p>
<p>(The call to <code>p.peekTokenIs(token.SEMICOLON)</code> is not strictly necessary. Our <code>peekPrecedence</code> method returns <code>LOWEST</code> as the default value if no precedence for <code>p.peekToken.Type</code> can be found - which is the case for <code>token.SEMICOLON</code> tokens. But I think it makes the behaviour of semicolons as expression-ending-delimiters more explicit and easier to understand.)</p>
<p>And that’s it! The for-loop is done and <code>leftExp</code> is returned. We’re back in <code>parseExpressionStatement</code> and have the final and correct <code>*ast.InfixExpression</code> at hand. And that’s used as the <code>Expression</code> in <code>*ast.ExpressionStatement</code>.</p>
<p>Now we know how our parser manages to parse <code>1 + 2 + 3</code> correctly. It’s pretty fascinating, isn’t it? I think the usage of <code>precedence</code> and <code>peekPrecedence</code> is particularly interesting.</p>
<p>But what about “real precedence issues”? In our example every operator (the <code>+</code>) had the same precedence. What do the different precedence levels for operators accomplish? Couldn’t we just use <code>LOWEST</code> per default and something called <code>HIGHEST</code> for all operators?</p>
<p>No, because that would give us a wrong AST. The goal is to have expressions involving operators with a higher precedence to be deeper in the tree than expressions with lower precedence operators. This is accomplished by the <code>precedence</code> value (the argument) in <code>parseExpression</code>.</p>
<p>When <code>parseExpression</code> is called the value of <code>precedence</code> stands for the current “right-binding power” of the current <code>parseExpression</code> invocation. What does “right-binding power” mean? Well, the higher it is, the more tokens/operators/operands to the right of the current expressions (the future peek tokens) can we “bind” to it, or as I like to think, “suck in”.</p>
<p>In case our current right-binding power is of the highest possible value, what we parsed so far (assigned to <code>leftExp</code>) is <em>never</em> passed to an <code>infixParseFn</code> associated with the next operator (or token). It will never end up as a “left” child node. Because the condition of the for-loop never evaluates to true.</p>
<p>A counterpart to right-binding power exists and it’s called (you guessed it!) “left-binding power”. But which value signifies this left-binding power? Since the <code>precedence</code> argument in <code>parseExpression</code> stands for the current right-binding power, where does the left-binding power of the next operator come from? Simply put: from our call to <code>peekPrecedence</code>. The value this call returns stands for the left-binding power of the next operator, of <code>p.peekToken</code>.</p>
<p>It all comes down to the <code>precedence &lt; p.peekPrecedence()</code> condition of our for-loop. This condition checks if the left-binding power of the next operator/token is higher than our current right-binding power. If it is, what we parsed so far gets “sucked in” by the next operator, from left to right, and ends up being passed to the <code>infixParseFn</code> of the next operator.</p>
<p>An example: let’s say we’re parsing the expression statement <code>-1 + 2;</code>. What we want the AST to represent is <code>(-1) + 2</code> and not <code>-(1 + 2)</code>. The first method we end up in (after <code>parseExpressionStatement</code> and <code>parseExpression</code>) is the <code>prefixParseFn</code> we associated with <code>token.MINUS</code>: <code>parsePrefixExpression</code>. To refresh our memory of <code>parsePrefixExpression</code> here it is in its entirety:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb162-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb162-2" data-line-number="2"></a>
<a class="sourceLine" id="cb162-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</a>
<a class="sourceLine" id="cb162-4" data-line-number="4">  expression := &amp;ast.PrefixExpression{</a>
<a class="sourceLine" id="cb162-5" data-line-number="5">    Token:    p.curToken,</a>
<a class="sourceLine" id="cb162-6" data-line-number="6">    Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb162-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb162-8" data-line-number="8">  p.nextToken()</a>
<a class="sourceLine" id="cb162-9" data-line-number="9">  expression.Right = p.parseExpression(PREFIX)</a>
<a class="sourceLine" id="cb162-10" data-line-number="10">  <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb162-11" data-line-number="11">}</a></code></pre></div>
<p>This passes <code>PREFIX</code> to <code>parseExpression</code> as <code>precedence</code>, turning <code>PREFIX</code> into the right-binding power of that <code>parseExpression</code> invocation. <code>PREFIX</code> is a really high precedence, as per our definition. The result of this is that <code>parseExpression(PREFIX)</code> is <em>never</em> going to parse the <code>1</code> in <code>-1</code> and pass it to another <code>infixParseFn</code>. The <code>precedence &lt; p.peekPrecedence()</code> will never be true in this case, meaning that no other <code>infixParseFn</code> is going to get our <code>1</code> as the left arm. Instead the <code>1</code> is returned as the “right” arm of our prefix expression. Just the <code>1</code>, not some other expression that comes after and needs to be parsed.</p>
<p>Back in the outer call to <code>parseExpression</code> (in which we called <code>parsePrefixExpression</code> as a <code>prefixParseFn</code>), right after the first <code>leftExp := prefix()</code>, the value of <code>precedence</code> is still <code>LOWEST</code>. Since that was the value we used in the outer-most call. Our right-binding power is still <code>LOWEST</code>. The <code>p.peekToken</code> is now the <code>+</code> in <code>-1 + 2</code>.</p>
<p>We’re now sitting on the condition of the for-loop and evaluate it to determine whether we should execute the body of the loop. And it turns out that the precedence of the <code>+</code> operator (returned by <code>p.peekPrecedence()</code>) is higher than our current right-binding power. What we parsed so far (the <code>-1</code> prefix expression) is now passed to the <code>infixParseFn</code> associated with <code>+</code>. The left-binding power of the <code>+</code> “sucks in” what we parsed so far and uses it as the “left arm” of the AST node it is constructing.</p>
<p>The <code>infixParseFn</code> for <code>+</code> is <code>parseInfixExpression</code>, which now uses the precedence of <code>+</code> as the right-binding power in its call to <code>parseExpression</code>. It doesn’t use <code>LOWEST</code>, because that would result in another <code>+</code> having a higher left-binding power and “sucking” away our “right arm”. If it did, then an expression like <code>a + b + c</code> would result in <code>(a + (b + c))</code>, which is not what we want. We want <code>((a + b) + c)</code>.</p>
<p>The high precedence of prefix operators worked. And it even works great for infix operators. In the classic example for operator precedences <code>1 + 2 * 3</code>, the left-binding power of <code>*</code> would be higher than the right-binding power of <code>+</code>. Parsing this would result in the <code>2</code> being passed to the <code>infixParseFn</code> associated with the <code>*</code> token.</p>
<p>Notable is that in our parser, every token has the same right- and left-binding power. We simply use one value (in our <code>precedences</code> table) as both. What this value means changes depending on the context.</p>
<p>If an operator should be right-associative instead of left-associative (in the case of <code>+</code> that would result in <code>(a + (b  + c))</code> instead of <code>((a + b) + c)</code>, then we must use a smaller “right-binding power” when parsing the “right arm” of the operator expression. If you think about the <code>++</code> and <code>--</code> operators in other languages, where they can be used in a pre- and a postfix position, you can see why it’s sometimes useful to have differing left- and right-binding powers for operators.</p>
<p>Since we did not define separate right- and left-binding powers for operators, but only use one value, we can’t just change a definition to achieve this. But, as an example, to make <code>+</code> right-associate we can decrement its precedence when calling <code>parseExpression</code>:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb163-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb163-2" data-line-number="2"></a>
<a class="sourceLine" id="cb163-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb163-4" data-line-number="4">    expression := &amp;ast.InfixExpression{</a>
<a class="sourceLine" id="cb163-5" data-line-number="5">        Token:    p.curToken,</a>
<a class="sourceLine" id="cb163-6" data-line-number="6">        Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb163-7" data-line-number="7">        Left:     left,</a>
<a class="sourceLine" id="cb163-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb163-9" data-line-number="9"></a>
<a class="sourceLine" id="cb163-10" data-line-number="10">    precedence := p.curPrecedence()</a>
<a class="sourceLine" id="cb163-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb163-12" data-line-number="12">    expression.Right = p.parseExpression(precedence)</a>
<a class="sourceLine" id="cb163-13" data-line-number="13">    <span class="co">//                                   ^^^ decrement here for right-associativity</span></a>
<a class="sourceLine" id="cb163-14" data-line-number="14"></a>
<a class="sourceLine" id="cb163-15" data-line-number="15">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb163-16" data-line-number="16">}</a></code></pre></div>
<p>For demonstration purposes, let’s change this method for a minute and see what happens:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb164-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb164-2" data-line-number="2"></a>
<a class="sourceLine" id="cb164-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb164-4" data-line-number="4">    expression := &amp;ast.InfixExpression{</a>
<a class="sourceLine" id="cb164-5" data-line-number="5">        Token:    p.curToken,</a>
<a class="sourceLine" id="cb164-6" data-line-number="6">        Operator: p.curToken.Literal,</a>
<a class="sourceLine" id="cb164-7" data-line-number="7">        Left:     left,</a>
<a class="sourceLine" id="cb164-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb164-9" data-line-number="9"></a>
<a class="sourceLine" id="cb164-10" data-line-number="10">    precedence := p.curPrecedence()</a>
<a class="sourceLine" id="cb164-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb164-12" data-line-number="12"></a>
<a class="sourceLine" id="cb164-13" data-line-number="13">    <span class="kw">if</span> expression.Operator == <span class="st">&quot;+&quot;</span> {</a>
<a class="sourceLine" id="cb164-14" data-line-number="14">        expression.Right = p.parseExpression(precedence - <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb164-15" data-line-number="15">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb164-16" data-line-number="16">        expression.Right = p.parseExpression(precedence)</a>
<a class="sourceLine" id="cb164-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb164-18" data-line-number="18"></a>
<a class="sourceLine" id="cb164-19" data-line-number="19">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb164-20" data-line-number="20">}</a></code></pre></div>
<p>With this change made, our tests tell us that <code>+</code> is officially right-associative:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb165-1" data-line-number="1">$ go test -run TestOperatorPrecedenceParsing ./parser</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">--- FAIL: TestOperatorPrecedenceParsing (0.00s)</a>
<a class="sourceLine" id="cb165-3" data-line-number="3">  parser_test.go:359: expected=&quot;((a + b) + c)&quot;, got=&quot;(a + (b + c))&quot;</a>
<a class="sourceLine" id="cb165-4" data-line-number="4">  parser_test.go:359: expected=&quot;((a + b) - c)&quot;, got=&quot;(a + (b - c))&quot;</a>
<a class="sourceLine" id="cb165-5" data-line-number="5">  parser_test.go:359: expected=&quot;(((a + (b * c)) + (d / e)) - f)&quot;,\</a>
<a class="sourceLine" id="cb165-6" data-line-number="6">    got=&quot;(a + ((b * c) + ((d / e) - f)))&quot;</a>
<a class="sourceLine" id="cb165-7" data-line-number="7">FAIL</a></code></pre></div>
<p>And that marks the end of our deep dive into the bowels of <code>parseExpression</code>. If you’re still unsure and can’t grasp how it works, don’t worry, I felt the same. What really helped though was putting tracing statements in the methods of <code>Parser</code> to see what was happening when parsing certain expressions. In the folder of code accompanying this chapter I’ve included a file called <code>./parser/parser_tracing.go</code>, which we haven’t looked at before. The file includes two function definitions that are really helpful when trying to understand what the parser does: <code>trace</code> and <code>untrace</code>. Use them like this:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb166-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb166-2" data-line-number="2"></a>
<a class="sourceLine" id="cb166-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {</a>
<a class="sourceLine" id="cb166-4" data-line-number="4">    <span class="kw">defer</span> untrace(trace(<span class="st">&quot;parseExpressionStatement&quot;</span>))</a>
<a class="sourceLine" id="cb166-5" data-line-number="5"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb166-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb166-7" data-line-number="7"></a>
<a class="sourceLine" id="cb166-8" data-line-number="8"><span class="kw">func</span> (p *Parser) parseExpression(precedence <span class="dt">int</span>) ast.Expression {</a>
<a class="sourceLine" id="cb166-9" data-line-number="9">    <span class="kw">defer</span> untrace(trace(<span class="st">&quot;parseExpression&quot;</span>))</a>
<a class="sourceLine" id="cb166-10" data-line-number="10"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb166-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb166-12" data-line-number="12"></a>
<a class="sourceLine" id="cb166-13" data-line-number="13"><span class="kw">func</span> (p *Parser) parseIntegerLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb166-14" data-line-number="14">    <span class="kw">defer</span> untrace(trace(<span class="st">&quot;parseIntegerLiteral&quot;</span>))</a>
<a class="sourceLine" id="cb166-15" data-line-number="15"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb166-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb166-17" data-line-number="17"></a>
<a class="sourceLine" id="cb166-18" data-line-number="18"><span class="kw">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</a>
<a class="sourceLine" id="cb166-19" data-line-number="19">    <span class="kw">defer</span> untrace(trace(<span class="st">&quot;parsePrefixExpression&quot;</span>))</a>
<a class="sourceLine" id="cb166-20" data-line-number="20"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb166-21" data-line-number="21">}</a>
<a class="sourceLine" id="cb166-22" data-line-number="22"></a>
<a class="sourceLine" id="cb166-23" data-line-number="23"><span class="kw">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb166-24" data-line-number="24">    <span class="kw">defer</span> untrace(trace(<span class="st">&quot;parseInfixExpression&quot;</span>))</a>
<a class="sourceLine" id="cb166-25" data-line-number="25"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb166-26" data-line-number="26">}</a></code></pre></div>
<p>With these tracing statements included we can now use our parser and see what it does. Here is the output when parsing the expression statement <code>-1 * 2 + 3</code> in the test suite:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb167-1" data-line-number="1">$ go test -v -run TestOperatorPrecedenceParsing ./parser</a>
<a class="sourceLine" id="cb167-2" data-line-number="2">=== RUN   TestOperatorPrecedenceParsing</a>
<a class="sourceLine" id="cb167-3" data-line-number="3">BEGIN parseExpressionStatement</a>
<a class="sourceLine" id="cb167-4" data-line-number="4">        BEGIN parseExpression</a>
<a class="sourceLine" id="cb167-5" data-line-number="5">                BEGIN parsePrefixExpression</a>
<a class="sourceLine" id="cb167-6" data-line-number="6">                        BEGIN parseExpression</a>
<a class="sourceLine" id="cb167-7" data-line-number="7">                                BEGIN parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-8" data-line-number="8">                                END parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-9" data-line-number="9">                        END parseExpression</a>
<a class="sourceLine" id="cb167-10" data-line-number="10">                END parsePrefixExpression</a>
<a class="sourceLine" id="cb167-11" data-line-number="11">                BEGIN parseInfixExpression</a>
<a class="sourceLine" id="cb167-12" data-line-number="12">                        BEGIN parseExpression</a>
<a class="sourceLine" id="cb167-13" data-line-number="13">                                BEGIN parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-14" data-line-number="14">                                END parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-15" data-line-number="15">                        END parseExpression</a>
<a class="sourceLine" id="cb167-16" data-line-number="16">                END parseInfixExpression</a>
<a class="sourceLine" id="cb167-17" data-line-number="17">                BEGIN parseInfixExpression</a>
<a class="sourceLine" id="cb167-18" data-line-number="18">                        BEGIN parseExpression</a>
<a class="sourceLine" id="cb167-19" data-line-number="19">                                BEGIN parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-20" data-line-number="20">                                END parseIntegerLiteral</a>
<a class="sourceLine" id="cb167-21" data-line-number="21">                        END parseExpression</a>
<a class="sourceLine" id="cb167-22" data-line-number="22">                END parseInfixExpression</a>
<a class="sourceLine" id="cb167-23" data-line-number="23">        END parseExpression</a>
<a class="sourceLine" id="cb167-24" data-line-number="24">END parseExpressionStatement</a>
<a class="sourceLine" id="cb167-25" data-line-number="25">--- PASS: TestOperatorPrecedenceParsing (0.00s)</a>
<a class="sourceLine" id="cb167-26" data-line-number="26">PASS</a>
<a class="sourceLine" id="cb167-27" data-line-number="27">ok      monkey/parser   0.008s</a></code></pre></div>
<h2 id="extending-the-parser">2.8 - Extending the Parser</h2>
<p>Before we move on and extend our parser, we first need to clean up and extend our existing test suite. I won’t bore you by listing the complete changes, but I will show you a few small helper functions that make the tests easier to understand.</p>
<p>We already have a <code>testIntegerLiteral</code> test helper. A second function called <code>testIdentifier</code> can clean up a lot of other tests:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb168-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb168-2" data-line-number="2"></a>
<a class="sourceLine" id="cb168-3" data-line-number="3"><span class="kw">func</span> testIdentifier(t *testing.T, exp ast.Expression, value <span class="dt">string</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb168-4" data-line-number="4">    ident, ok := exp.(*ast.Identifier)</a>
<a class="sourceLine" id="cb168-5" data-line-number="5">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb168-6" data-line-number="6">        t.Errorf(<span class="st">&quot;exp not *ast.Identifier. got=%T&quot;</span>, exp)</a>
<a class="sourceLine" id="cb168-7" data-line-number="7">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb168-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb168-9" data-line-number="9"></a>
<a class="sourceLine" id="cb168-10" data-line-number="10">    <span class="kw">if</span> ident.Value != value {</a>
<a class="sourceLine" id="cb168-11" data-line-number="11">        t.Errorf(<span class="st">&quot;ident.Value not %s. got=%s&quot;</span>, value, ident.Value)</a>
<a class="sourceLine" id="cb168-12" data-line-number="12">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb168-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb168-14" data-line-number="14"></a>
<a class="sourceLine" id="cb168-15" data-line-number="15">    <span class="kw">if</span> ident.TokenLiteral() != value {</a>
<a class="sourceLine" id="cb168-16" data-line-number="16">        t.Errorf(<span class="st">&quot;ident.TokenLiteral not %s. got=%s&quot;</span>, value,</a>
<a class="sourceLine" id="cb168-17" data-line-number="17">            ident.TokenLiteral())</a>
<a class="sourceLine" id="cb168-18" data-line-number="18">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb168-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb168-20" data-line-number="20"></a>
<a class="sourceLine" id="cb168-21" data-line-number="21">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb168-22" data-line-number="22">}</a></code></pre></div>
<p>The fun part is now using <code>testIntegerLiteral</code> and <code>testIdentifier</code> to build more generic helper functions:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb169-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb169-2" data-line-number="2"></a>
<a class="sourceLine" id="cb169-3" data-line-number="3"><span class="kw">func</span> testLiteralExpression(</a>
<a class="sourceLine" id="cb169-4" data-line-number="4">    t *testing.T,</a>
<a class="sourceLine" id="cb169-5" data-line-number="5">    exp ast.Expression,</a>
<a class="sourceLine" id="cb169-6" data-line-number="6">    expected <span class="kw">interface</span>{},</a>
<a class="sourceLine" id="cb169-7" data-line-number="7">) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb169-8" data-line-number="8">    <span class="kw">switch</span> v := expected.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb169-9" data-line-number="9">    <span class="kw">case</span> <span class="dt">int</span>:</a>
<a class="sourceLine" id="cb169-10" data-line-number="10">        <span class="kw">return</span> testIntegerLiteral(t, exp, <span class="dt">int64</span>(v))</a>
<a class="sourceLine" id="cb169-11" data-line-number="11">    <span class="kw">case</span> <span class="dt">int64</span>:</a>
<a class="sourceLine" id="cb169-12" data-line-number="12">        <span class="kw">return</span> testIntegerLiteral(t, exp, v)</a>
<a class="sourceLine" id="cb169-13" data-line-number="13">    <span class="kw">case</span> <span class="dt">string</span>:</a>
<a class="sourceLine" id="cb169-14" data-line-number="14">        <span class="kw">return</span> testIdentifier(t, exp, v)</a>
<a class="sourceLine" id="cb169-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb169-16" data-line-number="16">    t.Errorf(<span class="st">&quot;type of exp not handled. got=%T&quot;</span>, exp)</a>
<a class="sourceLine" id="cb169-17" data-line-number="17">    <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb169-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb169-19" data-line-number="19"></a>
<a class="sourceLine" id="cb169-20" data-line-number="20"><span class="kw">func</span> testInfixExpression(t *testing.T, exp ast.Expression, left <span class="kw">interface</span>{},</a>
<a class="sourceLine" id="cb169-21" data-line-number="21">    operator <span class="dt">string</span>, right <span class="kw">interface</span>{}) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb169-22" data-line-number="22"></a>
<a class="sourceLine" id="cb169-23" data-line-number="23">    opExp, ok := exp.(*ast.InfixExpression)</a>
<a class="sourceLine" id="cb169-24" data-line-number="24">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb169-25" data-line-number="25">        t.Errorf(<span class="st">&quot;exp is not ast.InfixExpression. got=%T(%s)&quot;</span>, exp, exp)</a>
<a class="sourceLine" id="cb169-26" data-line-number="26">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb169-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb169-28" data-line-number="28"></a>
<a class="sourceLine" id="cb169-29" data-line-number="29">    <span class="kw">if</span> !testLiteralExpression(t, opExp.Left, left) {</a>
<a class="sourceLine" id="cb169-30" data-line-number="30">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb169-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb169-32" data-line-number="32"></a>
<a class="sourceLine" id="cb169-33" data-line-number="33">    <span class="kw">if</span> opExp.Operator != operator {</a>
<a class="sourceLine" id="cb169-34" data-line-number="34">        t.Errorf(<span class="st">&quot;exp.Operator is not &#39;%s&#39;. got=%q&quot;</span>, operator, opExp.Operator)</a>
<a class="sourceLine" id="cb169-35" data-line-number="35">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb169-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb169-37" data-line-number="37"></a>
<a class="sourceLine" id="cb169-38" data-line-number="38">    <span class="kw">if</span> !testLiteralExpression(t, opExp.Right, right) {</a>
<a class="sourceLine" id="cb169-39" data-line-number="39">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb169-40" data-line-number="40">    }</a>
<a class="sourceLine" id="cb169-41" data-line-number="41"></a>
<a class="sourceLine" id="cb169-42" data-line-number="42">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb169-43" data-line-number="43">}</a></code></pre></div>
<p>With these in place it’s possible to write test code like this:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb170-1" data-line-number="1">testInfixExpression(t, stmt.Expression, <span class="dv">5</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb170-2" data-line-number="2">testInfixExpression(t, stmt.Expression, <span class="st">&quot;alice&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;bob&quot;</span>)</a></code></pre></div>
<p>That makes it a lot easier to test properties of the ASTs produced by our parser. I went ahead and changed our existing parser tests to use these new test helpers. In <code>parser/parser_test.go</code> you can see the cleaned up and extended test suite.</p>
<h3 id="boolean-literals">Boolean Literals</h3>
<p>There are a few things in the Monkey programming language that we still need to implement in our parser and AST. Easiest are boolean literals. In Monkey we can use booleans in place of any other expression:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb171-1" data-line-number="1"><span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb171-2" data-line-number="2"><span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb171-3" data-line-number="3"><span class="kw">let</span> foobar <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb171-4" data-line-number="4"><span class="kw">let</span> barfoo <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a></code></pre></div>
<p>Like identifiers and integer literals their AST representation is simple and small:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb172-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb172-2" data-line-number="2"></a>
<a class="sourceLine" id="cb172-3" data-line-number="3"><span class="kw">type</span> Boolean <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb172-4" data-line-number="4">    Token token.Token</a>
<a class="sourceLine" id="cb172-5" data-line-number="5">    Value <span class="dt">bool</span></a>
<a class="sourceLine" id="cb172-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb172-7" data-line-number="7"></a>
<a class="sourceLine" id="cb172-8" data-line-number="8"><span class="kw">func</span> (b *Boolean) expressionNode()      {}</a>
<a class="sourceLine" id="cb172-9" data-line-number="9"><span class="kw">func</span> (b *Boolean) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> b.Token.Literal }</a>
<a class="sourceLine" id="cb172-10" data-line-number="10"><span class="kw">func</span> (b *Boolean) String() <span class="dt">string</span>       { <span class="kw">return</span> b.Token.Literal }</a></code></pre></div>
<p>The <code>Value</code> field can hold values of the type <code>bool</code>, which means that we’re going to save either <code>true</code> or <code>false</code> in there (the Go <code>bool</code> values, not the Monkey literals).</p>
<p>With the AST node defined we can now add our tests. The single <code>TestBooleanExpression</code> test function is so similar to <code>TestIdentifierExpression</code> and <code>TestIntegerLiteralExpression</code> that I won’t show it here. It’s enough to show the error message which points us in the right direction as to how to implement boolean literal parsing:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb173-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb173-2" data-line-number="2">--- FAIL: TestBooleanExpression (0.00s)</a>
<a class="sourceLine" id="cb173-3" data-line-number="3">  parser_test.go:470: parser has 1 errors</a>
<a class="sourceLine" id="cb173-4" data-line-number="4">  parser_test.go:472: parser error: &quot;no prefix parse function for TRUE found&quot;</a>
<a class="sourceLine" id="cb173-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb173-6" data-line-number="6">FAIL    monkey/parser   0.008s</a></code></pre></div>
<p>Of course, yes. We need to register a <code>prefixParseFn</code> for <code>token.TRUE</code> and <code>token.FALSE</code> tokens.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb174-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb174-2" data-line-number="2"></a>
<a class="sourceLine" id="cb174-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb174-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb174-5" data-line-number="5">    p.registerPrefix(token.TRUE, p.parseBoolean)</a>
<a class="sourceLine" id="cb174-6" data-line-number="6">    p.registerPrefix(token.FALSE, p.parseBoolean)</a>
<a class="sourceLine" id="cb174-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb174-8" data-line-number="8">}</a></code></pre></div>
<p>And the <code>parseBoolean</code> method is exactly what you imagine it to be:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb175-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb175-2" data-line-number="2"></a>
<a class="sourceLine" id="cb175-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseBoolean() ast.Expression {</a>
<a class="sourceLine" id="cb175-4" data-line-number="4">    <span class="kw">return</span> &amp;ast.Boolean{Token: p.curToken, Value: p.curTokenIs(token.TRUE)}</a>
<a class="sourceLine" id="cb175-5" data-line-number="5">}</a></code></pre></div>
<p>The only mildly interesting part about this method is the inlining of the <code>p.curTokenIs(token.TRUE)</code> call, which is not really interesting. Other than that it’s straightforward, maybe even boring. Or in other words: the structure of our parser serves us well! That actually is one of the beauties of Pratt’s approach: it’s so easy to extend.</p>
<p>And boom! The tests are green:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb176-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb176-2" data-line-number="2">ok      monkey/parser   0.006s</a></code></pre></div>
<p>But what’s interesting is that we can now extend several tests to incorporate the newly implemented boolean literals. The first candidate is <code>TestOperatorPrecedenceParsing</code>, with its string comparison mechanism:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb177-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb177-2" data-line-number="2"></a>
<a class="sourceLine" id="cb177-3" data-line-number="3"><span class="kw">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb177-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb177-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb177-6" data-line-number="6">        expected <span class="dt">string</span></a>
<a class="sourceLine" id="cb177-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb177-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb177-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb177-10" data-line-number="10">            <span class="st">&quot;true&quot;</span>,</a>
<a class="sourceLine" id="cb177-11" data-line-number="11">            <span class="st">&quot;true&quot;</span>,</a>
<a class="sourceLine" id="cb177-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb177-13" data-line-number="13">        {</a>
<a class="sourceLine" id="cb177-14" data-line-number="14">            <span class="st">&quot;false&quot;</span>,</a>
<a class="sourceLine" id="cb177-15" data-line-number="15">            <span class="st">&quot;false&quot;</span>,</a>
<a class="sourceLine" id="cb177-16" data-line-number="16">        },</a>
<a class="sourceLine" id="cb177-17" data-line-number="17">        {</a>
<a class="sourceLine" id="cb177-18" data-line-number="18">            <span class="st">&quot;3 &gt; 5 == false&quot;</span>,</a>
<a class="sourceLine" id="cb177-19" data-line-number="19">            <span class="st">&quot;((3 &gt; 5) == false)&quot;</span>,</a>
<a class="sourceLine" id="cb177-20" data-line-number="20">        },</a>
<a class="sourceLine" id="cb177-21" data-line-number="21">        {</a>
<a class="sourceLine" id="cb177-22" data-line-number="22">            <span class="st">&quot;3 &lt; 5 == true&quot;</span>,</a>
<a class="sourceLine" id="cb177-23" data-line-number="23">            <span class="st">&quot;((3 &lt; 5) == true)&quot;</span>,</a>
<a class="sourceLine" id="cb177-24" data-line-number="24">        },</a>
<a class="sourceLine" id="cb177-25" data-line-number="25"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb177-26" data-line-number="26">}</a></code></pre></div>
<p>We can test for boolean literals in even more tests by extending our <code>testLiteralExpression</code> helper and providing a new <code>testBooleanLiteral</code> function:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb178-1" data-line-number="1"><span class="co">// parser_test.go</span></a>
<a class="sourceLine" id="cb178-2" data-line-number="2"></a>
<a class="sourceLine" id="cb178-3" data-line-number="3"><span class="kw">func</span> testLiteralExpression(</a>
<a class="sourceLine" id="cb178-4" data-line-number="4">    t *testing.T,</a>
<a class="sourceLine" id="cb178-5" data-line-number="5">    exp ast.Expression,</a>
<a class="sourceLine" id="cb178-6" data-line-number="6">    expected <span class="kw">interface</span>{},</a>
<a class="sourceLine" id="cb178-7" data-line-number="7">) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb178-8" data-line-number="8">    <span class="kw">switch</span> v := expected.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb178-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb178-10" data-line-number="10">    <span class="kw">case</span> <span class="dt">bool</span>:</a>
<a class="sourceLine" id="cb178-11" data-line-number="11">        <span class="kw">return</span> testBooleanLiteral(t, exp, v)</a>
<a class="sourceLine" id="cb178-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb178-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb178-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb178-15" data-line-number="15"></a>
<a class="sourceLine" id="cb178-16" data-line-number="16"><span class="kw">func</span> testBooleanLiteral(t *testing.T, exp ast.Expression, value <span class="dt">bool</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb178-17" data-line-number="17">    bo, ok := exp.(*ast.Boolean)</a>
<a class="sourceLine" id="cb178-18" data-line-number="18">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb178-19" data-line-number="19">        t.Errorf(<span class="st">&quot;exp not *ast.Boolean. got=%T&quot;</span>, exp)</a>
<a class="sourceLine" id="cb178-20" data-line-number="20">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb178-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb178-22" data-line-number="22"></a>
<a class="sourceLine" id="cb178-23" data-line-number="23">    <span class="kw">if</span> bo.Value != value {</a>
<a class="sourceLine" id="cb178-24" data-line-number="24">        t.Errorf(<span class="st">&quot;bo.Value not %t. got=%t&quot;</span>, value, bo.Value)</a>
<a class="sourceLine" id="cb178-25" data-line-number="25">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb178-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb178-27" data-line-number="27"></a>
<a class="sourceLine" id="cb178-28" data-line-number="28">    <span class="kw">if</span> bo.TokenLiteral() != fmt.Sprintf(<span class="st">&quot;%t&quot;</span>, value) {</a>
<a class="sourceLine" id="cb178-29" data-line-number="29">        t.Errorf(<span class="st">&quot;bo.TokenLiteral not %t. got=%s&quot;</span>,</a>
<a class="sourceLine" id="cb178-30" data-line-number="30">            value, bo.TokenLiteral())</a>
<a class="sourceLine" id="cb178-31" data-line-number="31">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb178-32" data-line-number="32">    }</a>
<a class="sourceLine" id="cb178-33" data-line-number="33"></a>
<a class="sourceLine" id="cb178-34" data-line-number="34">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb178-35" data-line-number="35">}</a></code></pre></div>
<p>Nothing surprising here, just another case in a switch statement and a new helper function. But with this in place, it’s easy to extend <code>TestParsingInfixExpressions</code>:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb179-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb179-2" data-line-number="2"></a>
<a class="sourceLine" id="cb179-3" data-line-number="3"><span class="kw">func</span> TestParsingInfixExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb179-4" data-line-number="4">    infixTests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb179-5" data-line-number="5">        input      <span class="dt">string</span></a>
<a class="sourceLine" id="cb179-6" data-line-number="6">        leftValue  <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb179-7" data-line-number="7">        operator   <span class="dt">string</span></a>
<a class="sourceLine" id="cb179-8" data-line-number="8">        rightValue <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb179-9" data-line-number="9">    }{</a>
<a class="sourceLine" id="cb179-10" data-line-number="10"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb179-11" data-line-number="11">        {<span class="st">&quot;true == true&quot;</span>, <span class="ot">true</span>, <span class="st">&quot;==&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb179-12" data-line-number="12">        {<span class="st">&quot;true != false&quot;</span>, <span class="ot">true</span>, <span class="st">&quot;!=&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb179-13" data-line-number="13">        {<span class="st">&quot;false == false&quot;</span>, <span class="ot">false</span>, <span class="st">&quot;==&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb179-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb179-15" data-line-number="15"></a>
<a class="sourceLine" id="cb179-16" data-line-number="16">    <span class="kw">for</span> _, tt := <span class="kw">range</span> infixTests {</a>
<a class="sourceLine" id="cb179-17" data-line-number="17"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb179-18" data-line-number="18"></a>
<a class="sourceLine" id="cb179-19" data-line-number="19">        <span class="kw">if</span> !testInfixExpression(t, stmt.Expression, tt.leftValue,</a>
<a class="sourceLine" id="cb179-20" data-line-number="20">            tt.operator, tt.rightValue) {</a>
<a class="sourceLine" id="cb179-21" data-line-number="21">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb179-22" data-line-number="22">        }</a>
<a class="sourceLine" id="cb179-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb179-24" data-line-number="24">}</a></code></pre></div>
<p>And also <code>TestParsingPrefixExpressions</code> is easy to extend by just adding new entries to the test table:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb180-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb180-2" data-line-number="2"></a>
<a class="sourceLine" id="cb180-3" data-line-number="3"><span class="kw">func</span> TestParsingPrefixExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb180-4" data-line-number="4">    prefixTests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb180-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb180-6" data-line-number="6">        operator <span class="dt">string</span></a>
<a class="sourceLine" id="cb180-7" data-line-number="7">        value    <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb180-8" data-line-number="8">    }{</a>
<a class="sourceLine" id="cb180-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb180-10" data-line-number="10">        {<span class="st">&quot;!true;&quot;</span>, <span class="st">&quot;!&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb180-11" data-line-number="11">        {<span class="st">&quot;!false;&quot;</span>, <span class="st">&quot;!&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb180-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb180-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb180-14" data-line-number="14">}</a></code></pre></div>
<p>It’s time to pat ourselves on the back! We implemented the parsing of booleans and extended our tests in a way that gives us more test coverage now and better tools later on. Good job!</p>
<h3 id="grouped-expressions">Grouped Expressions</h3>
<p>What we’re about to see next is sometimes called “the greatest trick Vaughan Pratt ever pulled”. Actually, no, I just lied there, nobody says that. But they should! I’m talking about parsing grouped expressions, of course. In Monkey we can group expression with parentheses to influence their precedence and thus the order in which they are evaluated in their context. We’ve seen the canonical example for this before:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb181-1" data-line-number="1">(<span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></a></code></pre></div>
<p>The parentheses group the <code>5 + 5</code> expression in order to give them a higher precedence and position them deeper in the AST, resulting in the correct evaluation order for this mathematical expression.</p>
<p>Now you might be thinking <em>“Oh come on, not with the precedence stuff again! My head still hurts! This guy…”</em> and you contemplate whether to skip to the end of this chapter. Don’t! You have to see this!</p>
<p>We’re not going to write a unit test for grouped expressions, since they are not represented by a separate AST node type. Yes, that’s right. We do not need to change our AST in order to parse grouped expressions correctly! What we’re going to do instead is to extend our <code>TestOperatorPrecedenceParsing</code> test function to make sure that parentheses actually group expressions and have an effect on the resulting AST.</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb182-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb182-2" data-line-number="2"></a>
<a class="sourceLine" id="cb182-3" data-line-number="3"><span class="kw">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb182-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb182-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb182-6" data-line-number="6">        expected <span class="dt">string</span></a>
<a class="sourceLine" id="cb182-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb182-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb182-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb182-10" data-line-number="10">            <span class="st">&quot;1 + (2 + 3) + 4&quot;</span>,</a>
<a class="sourceLine" id="cb182-11" data-line-number="11">            <span class="st">&quot;((1 + (2 + 3)) + 4)&quot;</span>,</a>
<a class="sourceLine" id="cb182-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb182-13" data-line-number="13">        {</a>
<a class="sourceLine" id="cb182-14" data-line-number="14">            <span class="st">&quot;(5 + 5) * 2&quot;</span>,</a>
<a class="sourceLine" id="cb182-15" data-line-number="15">            <span class="st">&quot;((5 + 5) * 2)&quot;</span>,</a>
<a class="sourceLine" id="cb182-16" data-line-number="16">        },</a>
<a class="sourceLine" id="cb182-17" data-line-number="17">        {</a>
<a class="sourceLine" id="cb182-18" data-line-number="18">            <span class="st">&quot;2 / (5 + 5)&quot;</span>,</a>
<a class="sourceLine" id="cb182-19" data-line-number="19">            <span class="st">&quot;(2 / (5 + 5))&quot;</span>,</a>
<a class="sourceLine" id="cb182-20" data-line-number="20">        },</a>
<a class="sourceLine" id="cb182-21" data-line-number="21">        {</a>
<a class="sourceLine" id="cb182-22" data-line-number="22">            <span class="st">&quot;-(5 + 5)&quot;</span>,</a>
<a class="sourceLine" id="cb182-23" data-line-number="23">            <span class="st">&quot;(-(5 + 5))&quot;</span>,</a>
<a class="sourceLine" id="cb182-24" data-line-number="24">        },</a>
<a class="sourceLine" id="cb182-25" data-line-number="25">        {</a>
<a class="sourceLine" id="cb182-26" data-line-number="26">            <span class="st">&quot;!(true == true)&quot;</span>,</a>
<a class="sourceLine" id="cb182-27" data-line-number="27">            <span class="st">&quot;(!(true == true))&quot;</span>,</a>
<a class="sourceLine" id="cb182-28" data-line-number="28">        },</a>
<a class="sourceLine" id="cb182-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb182-30" data-line-number="30"></a>
<a class="sourceLine" id="cb182-31" data-line-number="31"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb182-32" data-line-number="32">}</a></code></pre></div>
<p>They fail, as expected:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb183-1" data-line-number="1">$ <span class="kw">go</span> test ./parser</a>
<a class="sourceLine" id="cb183-2" data-line-number="2">--- FAIL: TestOperatorPrecedenceParsing (<span class="dv">0</span><span class="fl">.00</span>s)</a>
<a class="sourceLine" id="cb183-3" data-line-number="3">  parser_test.<span class="kw">go</span>:<span class="dv">531</span>: parser has <span class="dv">3</span> errors</a>
<a class="sourceLine" id="cb183-4" data-line-number="4">  parser_test.<span class="kw">go</span>:<span class="dv">533</span>: parser <span class="dt">error</span>: <span class="st">&quot;no prefix parse function for ( found&quot;</span></a>
<a class="sourceLine" id="cb183-5" data-line-number="5">  parser_test.<span class="kw">go</span>:<span class="dv">533</span>: parser <span class="dt">error</span>: <span class="st">&quot;no prefix parse function for ) found&quot;</span></a>
<a class="sourceLine" id="cb183-6" data-line-number="6">  parser_test.<span class="kw">go</span>:<span class="dv">533</span>: parser <span class="dt">error</span>: <span class="st">&quot;no prefix parse function for + found&quot;</span></a>
<a class="sourceLine" id="cb183-7" data-line-number="7">FAIL</a>
<a class="sourceLine" id="cb183-8" data-line-number="8">FAIL    monkey/parser   <span class="dv">0</span><span class="fl">.007</span>s</a></code></pre></div>
<p>Here comes the mind-blowing part. In order to get these tests to pass, all we need to do is add this:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb184-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb184-2" data-line-number="2"></a>
<a class="sourceLine" id="cb184-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb184-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb184-5" data-line-number="5">    p.registerPrefix(token.LPAREN, p.parseGroupedExpression)</a>
<a class="sourceLine" id="cb184-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb184-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb184-8" data-line-number="8"></a>
<a class="sourceLine" id="cb184-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseGroupedExpression() ast.Expression {</a>
<a class="sourceLine" id="cb184-10" data-line-number="10">    p.nextToken()</a>
<a class="sourceLine" id="cb184-11" data-line-number="11"></a>
<a class="sourceLine" id="cb184-12" data-line-number="12">    exp := p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb184-13" data-line-number="13"></a>
<a class="sourceLine" id="cb184-14" data-line-number="14">    <span class="kw">if</span> !p.expectPeek(token.RPAREN) {</a>
<a class="sourceLine" id="cb184-15" data-line-number="15">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb184-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb184-17" data-line-number="17"></a>
<a class="sourceLine" id="cb184-18" data-line-number="18">    <span class="kw">return</span> exp</a>
<a class="sourceLine" id="cb184-19" data-line-number="19">}</a></code></pre></div>
<p>And that’s it! Yes, it really is. The tests pass and the parentheses work as expected by boosting the precedence of the enclosed expressions. The concept of associating token types with functions really shines here. That’s all there is to it. There is nothing happening here that we haven’t seen before.</p>
<p>I told you, didn’t I? It’s a great trick. With that said, let’s keep some of the magic and move on.</p>
<h3 id="if-expressions">If Expressions</h3>
<p>In Monkey we can use <code>if</code> and <code>else</code> just like we did hundreds of times in other programming languages:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb185-1" data-line-number="1"><span class="cf">if</span> (x <span class="op">&gt;</span> y) <span class="op">{</span></a>
<a class="sourceLine" id="cb185-2" data-line-number="2">  <span class="cf">return</span> x<span class="op">;</span></a>
<a class="sourceLine" id="cb185-3" data-line-number="3"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb185-4" data-line-number="4">  <span class="cf">return</span> y<span class="op">;</span></a>
<a class="sourceLine" id="cb185-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>The <code>else</code> is optional and can be left out:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb186-1" data-line-number="1"><span class="cf">if</span> (x <span class="op">&gt;</span> y) <span class="op">{</span></a>
<a class="sourceLine" id="cb186-2" data-line-number="2">  <span class="cf">return</span> x<span class="op">;</span></a>
<a class="sourceLine" id="cb186-3" data-line-number="3"><span class="op">}</span></a></code></pre></div>
<p>That’s all very familiar. In Monkey though, if-else-conditionals are expressions. That means that they produce a value and in the case of if expressions that’s the last evaluated line. We don’t need the return statements here:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="kw">let</span> foobar <span class="op">=</span> <span class="cf">if</span> (x <span class="op">&gt;</span> y) <span class="op">{</span> x <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> y <span class="op">};</span></a></code></pre></div>
<p>Explaining the structure of if-else-conditionals is probably not necessary, but just so we’re clear on the naming, here it is:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb188-1" data-line-number="1">if (&lt;condition&gt;) &lt;consequence&gt; else &lt;alternative&gt;</a></code></pre></div>
<p>The braces are part of <code>consequence</code> and <code>alternative</code>, because both are block statements. Block statements are a series of statements (just like programs in Monkey) enclosed by an opening <code>{</code> and a closing <code>}</code>.</p>
<p>So far our recipe for success has been to “define AST nodes, write tests, make tests pass by writing parsing code, celebrate, pat ourselves on the back, congratulate each other, tell everyone” and, well, there’s no reason to change it now.</p>
<p>Here is the definition of the <code>ast.IfExpression</code> AST node:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb189-2" data-line-number="2"></a>
<a class="sourceLine" id="cb189-3" data-line-number="3"><span class="kw">type</span> IfExpression <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb189-4" data-line-number="4">    Token       token.Token <span class="co">// The &#39;if&#39; token</span></a>
<a class="sourceLine" id="cb189-5" data-line-number="5">    Condition   Expression</a>
<a class="sourceLine" id="cb189-6" data-line-number="6">    Consequence *BlockStatement</a>
<a class="sourceLine" id="cb189-7" data-line-number="7">    Alternative *BlockStatement</a>
<a class="sourceLine" id="cb189-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb189-9" data-line-number="9"></a>
<a class="sourceLine" id="cb189-10" data-line-number="10"><span class="kw">func</span> (ie *IfExpression) expressionNode()      {}</a>
<a class="sourceLine" id="cb189-11" data-line-number="11"><span class="kw">func</span> (ie *IfExpression) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> ie.Token.Literal }</a>
<a class="sourceLine" id="cb189-12" data-line-number="12"><span class="kw">func</span> (ie *IfExpression) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb189-13" data-line-number="13">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb189-14" data-line-number="14"></a>
<a class="sourceLine" id="cb189-15" data-line-number="15">    out.WriteString(<span class="st">&quot;if&quot;</span>)</a>
<a class="sourceLine" id="cb189-16" data-line-number="16">    out.WriteString(ie.Condition.String())</a>
<a class="sourceLine" id="cb189-17" data-line-number="17">    out.WriteString(<span class="st">&quot; &quot;</span>)</a>
<a class="sourceLine" id="cb189-18" data-line-number="18">    out.WriteString(ie.Consequence.String())</a>
<a class="sourceLine" id="cb189-19" data-line-number="19"></a>
<a class="sourceLine" id="cb189-20" data-line-number="20">    <span class="kw">if</span> ie.Alternative != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb189-21" data-line-number="21">        out.WriteString(<span class="st">&quot;else &quot;</span>)</a>
<a class="sourceLine" id="cb189-22" data-line-number="22">        out.WriteString(ie.Alternative.String())</a>
<a class="sourceLine" id="cb189-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb189-24" data-line-number="24"></a>
<a class="sourceLine" id="cb189-25" data-line-number="25">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb189-26" data-line-number="26">}</a></code></pre></div>
<p>No surprises here. <code>ast.IfExpression</code> fulfills the <code>ast.Expression</code> interface and has three fields that can represent an if-else-conditional. <code>Condition</code> holds the condition, which can be any expression, and <code>Consequence</code> and <code>Alternative</code> point to the consequence and alternative of the conditional respectively. But they reference a new type, <code>ast.BlockStatement</code>. As we saw before, the consequence/alternative of an if-else-condition is just a series of statements. That’s exactly what <code>ast.BlockStatement</code> represents:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb190-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb190-2" data-line-number="2"></a>
<a class="sourceLine" id="cb190-3" data-line-number="3"><span class="kw">type</span> BlockStatement <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb190-4" data-line-number="4">    Token      token.Token <span class="co">// the { token</span></a>
<a class="sourceLine" id="cb190-5" data-line-number="5">    Statements []Statement</a>
<a class="sourceLine" id="cb190-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb190-7" data-line-number="7"></a>
<a class="sourceLine" id="cb190-8" data-line-number="8"><span class="kw">func</span> (bs *BlockStatement) statementNode()       {}</a>
<a class="sourceLine" id="cb190-9" data-line-number="9"><span class="kw">func</span> (bs *BlockStatement) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> bs.Token.Literal }</a>
<a class="sourceLine" id="cb190-10" data-line-number="10"><span class="kw">func</span> (bs *BlockStatement) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb190-11" data-line-number="11">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb190-12" data-line-number="12"></a>
<a class="sourceLine" id="cb190-13" data-line-number="13">    <span class="kw">for</span> _, s := <span class="kw">range</span> bs.Statements {</a>
<a class="sourceLine" id="cb190-14" data-line-number="14">        out.WriteString(s.String())</a>
<a class="sourceLine" id="cb190-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb190-16" data-line-number="16"></a>
<a class="sourceLine" id="cb190-17" data-line-number="17">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb190-18" data-line-number="18">}</a></code></pre></div>
<p>The next step in our recipe for success is to add a test. By now, we know the drill and the test looks familiar:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb191-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb191-2" data-line-number="2"></a>
<a class="sourceLine" id="cb191-3" data-line-number="3"><span class="kw">func</span> TestIfExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb191-4" data-line-number="4">    input := <span class="st">`if (x &lt; y) { x }`</span></a>
<a class="sourceLine" id="cb191-5" data-line-number="5"></a>
<a class="sourceLine" id="cb191-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb191-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb191-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb191-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb191-10" data-line-number="10"></a>
<a class="sourceLine" id="cb191-11" data-line-number="11">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb191-12" data-line-number="12">        t.Fatalf(<span class="st">&quot;program.Statements does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb191-13" data-line-number="13">            <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb191-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb191-15" data-line-number="15"></a>
<a class="sourceLine" id="cb191-16" data-line-number="16">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb191-17" data-line-number="17">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb191-18" data-line-number="18">        t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb191-19" data-line-number="19">            program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb191-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb191-21" data-line-number="21"></a>
<a class="sourceLine" id="cb191-22" data-line-number="22">    exp, ok := stmt.Expression.(*ast.IfExpression)</a>
<a class="sourceLine" id="cb191-23" data-line-number="23">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb191-24" data-line-number="24">        t.Fatalf(<span class="st">&quot;stmt.Expression is not ast.IfExpression. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb191-25" data-line-number="25">            stmt.Expression)</a>
<a class="sourceLine" id="cb191-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb191-27" data-line-number="27"></a>
<a class="sourceLine" id="cb191-28" data-line-number="28">    <span class="kw">if</span> !testInfixExpression(t, exp.Condition, <span class="st">&quot;x&quot;</span>, <span class="st">&quot;&lt;&quot;</span>, <span class="st">&quot;y&quot;</span>) {</a>
<a class="sourceLine" id="cb191-29" data-line-number="29">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb191-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb191-31" data-line-number="31"></a>
<a class="sourceLine" id="cb191-32" data-line-number="32">    <span class="kw">if</span> <span class="bu">len</span>(exp.Consequence.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb191-33" data-line-number="33">        t.Errorf(<span class="st">&quot;consequence is not 1 statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb191-34" data-line-number="34">            <span class="bu">len</span>(exp.Consequence.Statements))</a>
<a class="sourceLine" id="cb191-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb191-36" data-line-number="36"></a>
<a class="sourceLine" id="cb191-37" data-line-number="37">    consequence, ok := exp.Consequence.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb191-38" data-line-number="38">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb191-39" data-line-number="39">        t.Fatalf(<span class="st">&quot;Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb191-40" data-line-number="40">            exp.Consequence.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb191-41" data-line-number="41">    }</a>
<a class="sourceLine" id="cb191-42" data-line-number="42"></a>
<a class="sourceLine" id="cb191-43" data-line-number="43">    <span class="kw">if</span> !testIdentifier(t, consequence.Expression, <span class="st">&quot;x&quot;</span>) {</a>
<a class="sourceLine" id="cb191-44" data-line-number="44">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb191-45" data-line-number="45">    }</a>
<a class="sourceLine" id="cb191-46" data-line-number="46"></a>
<a class="sourceLine" id="cb191-47" data-line-number="47">    <span class="kw">if</span> exp.Alternative != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb191-48" data-line-number="48">        t.Errorf(<span class="st">&quot;exp.Alternative.Statements was not nil. got=%+v&quot;</span>, exp.Alternative)</a>
<a class="sourceLine" id="cb191-49" data-line-number="49">    }</a>
<a class="sourceLine" id="cb191-50" data-line-number="50">}</a></code></pre></div>
<p>I also added a <code>TestIfElseExpression</code> test function that uses the following test input:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb192-1" data-line-number="1"><span class="cf">if</span> (x <span class="op">&lt;</span> y) <span class="op">{</span> x <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> y <span class="op">}</span></a></code></pre></div>
<p>In <code>TestIfElseExpression</code> there are additional assertions on the <code>Alternative</code> field of <code>*ast.IfExpression</code>. Both tests make assertions about the structure of the resulting <code>*ast.IfExpression</code> node and use the helper functions <code>testInfixExpression</code> and <code>testIdentifier</code> to keep the focus on the conditional itself but also make sure that the rest of our parser is correctly integrated.</p>
<p>Both tests fail with a lot of error messages. But we are familiar with all of them by now:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb193-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">--- FAIL: TestIfExpression (0.00s)</a>
<a class="sourceLine" id="cb193-3" data-line-number="3">  parser_test.go:659: parser has 3 errors</a>
<a class="sourceLine" id="cb193-4" data-line-number="4">  parser_test.go:661: parser error: &quot;no prefix parse function for IF found&quot;</a>
<a class="sourceLine" id="cb193-5" data-line-number="5">  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb193-6" data-line-number="6">  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb193-7" data-line-number="7">--- FAIL: TestIfElseExpression (0.00s)</a>
<a class="sourceLine" id="cb193-8" data-line-number="8">  parser_test.go:659: parser has 6 errors</a>
<a class="sourceLine" id="cb193-9" data-line-number="9">  parser_test.go:661: parser error: &quot;no prefix parse function for IF found&quot;</a>
<a class="sourceLine" id="cb193-10" data-line-number="10">  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb193-11" data-line-number="11">  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb193-12" data-line-number="12">  parser_test.go:661: parser error: &quot;no prefix parse function for ELSE found&quot;</a>
<a class="sourceLine" id="cb193-13" data-line-number="13">  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb193-14" data-line-number="14">  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb193-15" data-line-number="15">FAIL</a>
<a class="sourceLine" id="cb193-16" data-line-number="16">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>We’re going to start with the first failing test: <code>TestIfExpression</code>. Clearly, we need to register a <code>prefixParseFn</code> for <code>token.IF</code> tokens.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb194-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb194-2" data-line-number="2"></a>
<a class="sourceLine" id="cb194-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb194-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb194-5" data-line-number="5">    p.registerPrefix(token.IF, p.parseIfExpression)</a>
<a class="sourceLine" id="cb194-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb194-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb194-8" data-line-number="8"></a>
<a class="sourceLine" id="cb194-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseIfExpression() ast.Expression {</a>
<a class="sourceLine" id="cb194-10" data-line-number="10">    expression := &amp;ast.IfExpression{Token: p.curToken}</a>
<a class="sourceLine" id="cb194-11" data-line-number="11"></a>
<a class="sourceLine" id="cb194-12" data-line-number="12">    <span class="kw">if</span> !p.expectPeek(token.LPAREN) {</a>
<a class="sourceLine" id="cb194-13" data-line-number="13">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb194-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb194-15" data-line-number="15"></a>
<a class="sourceLine" id="cb194-16" data-line-number="16">    p.nextToken()</a>
<a class="sourceLine" id="cb194-17" data-line-number="17">    expression.Condition = p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb194-18" data-line-number="18"></a>
<a class="sourceLine" id="cb194-19" data-line-number="19">    <span class="kw">if</span> !p.expectPeek(token.RPAREN) {</a>
<a class="sourceLine" id="cb194-20" data-line-number="20">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb194-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb194-22" data-line-number="22"></a>
<a class="sourceLine" id="cb194-23" data-line-number="23">    <span class="kw">if</span> !p.expectPeek(token.LBRACE) {</a>
<a class="sourceLine" id="cb194-24" data-line-number="24">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb194-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb194-26" data-line-number="26"></a>
<a class="sourceLine" id="cb194-27" data-line-number="27">    expression.Consequence = p.parseBlockStatement()</a>
<a class="sourceLine" id="cb194-28" data-line-number="28"></a>
<a class="sourceLine" id="cb194-29" data-line-number="29">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb194-30" data-line-number="30">}</a></code></pre></div>
<p>In no other parsing function did we use <code>expectPeek</code> so extensively. There just wasn’t a need. Here it makes sense. <code>expectPeek</code> adds an error to the parser if <code>p.peekToken</code> is not of the expected type, but if it is, then it advances the tokens by calling the <code>nextToken</code> method. That’s exactly what we need here. We need there to be a <code>(</code> right after the <code>if</code> and if it’s there we need to jump over it. The same goes for the <code>)</code> after the expression and the <code>{</code> that marks the beginning of a block statement.</p>
<p>This method also follows our parsing function protocol: the tokens get advanced just enough so that <code>parseBlockStatement</code> sits on the <code>{</code> with <code>p.curToken</code> being of type <code>token.LBRACE</code>. Here is <code>parseBlockStatement</code>:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb195-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb195-2" data-line-number="2"></a>
<a class="sourceLine" id="cb195-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseBlockStatement() *ast.BlockStatement {</a>
<a class="sourceLine" id="cb195-4" data-line-number="4">    block := &amp;ast.BlockStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb195-5" data-line-number="5">    block.Statements = []ast.Statement{}</a>
<a class="sourceLine" id="cb195-6" data-line-number="6"></a>
<a class="sourceLine" id="cb195-7" data-line-number="7">    p.nextToken()</a>
<a class="sourceLine" id="cb195-8" data-line-number="8"></a>
<a class="sourceLine" id="cb195-9" data-line-number="9">    <span class="kw">for</span> !p.curTokenIs(token.RBRACE) &amp;&amp; !p.curTokenIs(token.EOF) {</a>
<a class="sourceLine" id="cb195-10" data-line-number="10">        stmt := p.parseStatement()</a>
<a class="sourceLine" id="cb195-11" data-line-number="11">        <span class="kw">if</span> stmt != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb195-12" data-line-number="12">            block.Statements = <span class="bu">append</span>(block.Statements, stmt)</a>
<a class="sourceLine" id="cb195-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb195-14" data-line-number="14">        p.nextToken()</a>
<a class="sourceLine" id="cb195-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb195-16" data-line-number="16"></a>
<a class="sourceLine" id="cb195-17" data-line-number="17">    <span class="kw">return</span> block</a>
<a class="sourceLine" id="cb195-18" data-line-number="18">}</a></code></pre></div>
<p><code>parseBlockStatement</code> calls <code>parseStatement</code> until it encounters either a <code>}</code>, which signifies the end of the block statement, or a <code>token.EOF</code>, which tells us that there’s no more tokens left to parse. In that case, we can’t successfully parse the block statement and there’s no need to keep on calling <code>parseStatement</code> in an endless loop.</p>
<p>This looks really similar to our top-level <code>ParseProgram</code> method, where we also call <code>parseStatement</code> repeatedly until we encounter an “end token”, which in the case of <code>ParseProgram</code> is just the <code>token.EOF</code> token. The duplication of the loop doesn’t hurt though, so we leave these two methods be and instead take care of our tests:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb196-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">--- FAIL: TestIfElseExpression (0.00s)</a>
<a class="sourceLine" id="cb196-3" data-line-number="3">  parser_test.go:659: parser has 3 errors</a>
<a class="sourceLine" id="cb196-4" data-line-number="4">  parser_test.go:661: parser error: &quot;no prefix parse function for ELSE found&quot;</a>
<a class="sourceLine" id="cb196-5" data-line-number="5">  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb196-6" data-line-number="6">  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb196-7" data-line-number="7">FAIL</a>
<a class="sourceLine" id="cb196-8" data-line-number="8">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p><code>TestIfExpression</code> passes and <code>TestIfElseExpression</code> does not, exactly as expected. Now, in order to support the <code>else</code> part of an if-else-condition, we need to check if it even exists and if so we need to parse the block statement that comes directly after the <code>else</code>:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb197-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb197-2" data-line-number="2"></a>
<a class="sourceLine" id="cb197-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseIfExpression() ast.Expression {</a>
<a class="sourceLine" id="cb197-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb197-5" data-line-number="5">    expression.Consequence = p.parseBlockStatement()</a>
<a class="sourceLine" id="cb197-6" data-line-number="6"></a>
<a class="sourceLine" id="cb197-7" data-line-number="7">    <span class="kw">if</span> p.peekTokenIs(token.ELSE) {</a>
<a class="sourceLine" id="cb197-8" data-line-number="8">        p.nextToken()</a>
<a class="sourceLine" id="cb197-9" data-line-number="9"></a>
<a class="sourceLine" id="cb197-10" data-line-number="10">        <span class="kw">if</span> !p.expectPeek(token.LBRACE) {</a>
<a class="sourceLine" id="cb197-11" data-line-number="11">            <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb197-12" data-line-number="12">        }</a>
<a class="sourceLine" id="cb197-13" data-line-number="13"></a>
<a class="sourceLine" id="cb197-14" data-line-number="14">        expression.Alternative = p.parseBlockStatement()</a>
<a class="sourceLine" id="cb197-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb197-16" data-line-number="16"></a>
<a class="sourceLine" id="cb197-17" data-line-number="17">    <span class="kw">return</span> expression</a>
<a class="sourceLine" id="cb197-18" data-line-number="18">}</a></code></pre></div>
<p>That’s all there is to it. The whole part of this method is constructed in a way that allows an optional <code>else</code> but doesn’t add a parser error if there is none. After we parse the consequence-block-statement we check if the next token is a <code>token.ELSE</code> token. Remember, at the end of <code>parseBlockStatement</code> we’re sitting on the <code>}</code>. If we have a <code>token.ELSE</code>, we advance the tokens two times. The first time with a call to <code>nextToken</code>, since we already know that the <code>p.peekToken</code> is the <code>else</code>. Then with a call to <code>expectPeek</code> since now the next token has to be the opening brace of a block statement, otherwise the program is invalid.</p>
<p>Yes, parsing is prone to off-by-one errors. It’s easy to forget advancing the tokens or make a wrong call to <code>nextToken</code>. Having a strict protocol that dictates how every parsing function has to advance tokens helps a lot. Luckily we also have a great test suite that lets us know everything works:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb198-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb198-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>I don’t think I have to tell you anymore: good job all around! We did it - again.</p>
<h3 id="function-literals">Function Literals</h3>
<p>You may have noticed that the <code>parseIfExpression</code> method we just added has a lot more meat to it than any of the <code>prefixParseFn</code>s or <code>infixParseFn</code>s we wrote before. The main reason is that we had to work with many different token and expression types and even optional parts. What we’re going to do next is similar in its difficulty and variety of involved token types. We’re going to parse function literals.</p>
<p>In Monkey a function literal is how we define functions: which parameters they have and what the function does. Function literals look like this:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb199-1" data-line-number="1"><span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span></a>
<a class="sourceLine" id="cb199-2" data-line-number="2">  <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span></a>
<a class="sourceLine" id="cb199-3" data-line-number="3"><span class="op">}</span></a></code></pre></div>
<p>It starts with the keyword <code>fn</code>, followed by a list of parameters, followed by a block statement, which is the function’s body, that gets executed when the function is called. The abstract structure of a function literal is this:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb200-1" data-line-number="1">fn &lt;parameters&gt; &lt;block statement&gt;</a></code></pre></div>
<p>We already know what block statements are and how to parse them. The parameters are new though, but not much more difficult to parse. They are just a list of identifiers that are comma-separated and surrounded by parentheses:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb201-1" data-line-number="1">(&lt;parameter one&gt;, &lt;parameter two&gt;, &lt;parameter three&gt;, ...)</a></code></pre></div>
<p>This list can also be empty:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="at">fn</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb202-2" data-line-number="2">  <span class="cf">return</span> foobar <span class="op">+</span> barfoo<span class="op">;</span></a>
<a class="sourceLine" id="cb202-3" data-line-number="3"><span class="op">}</span></a></code></pre></div>
<p>That’s the structure of function literals. But what type of AST node are they? Expressions, of course! We can use function literals in every place where any other expression is valid. For example, here is a function literal as the expression in a let statement:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb203-1" data-line-number="1"><span class="kw">let</span> myFunction <span class="op">=</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span> <span class="op">}</span></a></code></pre></div>
<p>And here is a function literal as the expression in a return statement inside another function literal:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="at">fn</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb204-2" data-line-number="2">  <span class="cf">return</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> x <span class="op">&gt;</span> y<span class="op">;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb204-3" data-line-number="3"><span class="op">}</span></a></code></pre></div>
<p>Using a function literal as an argument when calling another function is also possible:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb205-1" data-line-number="1"><span class="at">myFunc</span>(x<span class="op">,</span> y<span class="op">,</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> x <span class="op">&gt;</span> y<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>That does sound complicated, but it’s not. One of the great things about our parser is that once we define function literals as expressions and provide a function to correctly parse them the rest works. Sounds amazing? I agree.</p>
<p>We just saw that the two main parts of a function literal are the list of parameters and the block statement that is the function’s body. That’s all we need to keep in mind when defining the AST node:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb206-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb206-2" data-line-number="2"></a>
<a class="sourceLine" id="cb206-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb206-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb206-5" data-line-number="5">    <span class="st">&quot;strings&quot;</span></a>
<a class="sourceLine" id="cb206-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb206-7" data-line-number="7"></a>
<a class="sourceLine" id="cb206-8" data-line-number="8"><span class="kw">type</span> FunctionLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb206-9" data-line-number="9">    Token      token.Token <span class="co">// The &#39;fn&#39; token</span></a>
<a class="sourceLine" id="cb206-10" data-line-number="10">    Parameters []*Identifier</a>
<a class="sourceLine" id="cb206-11" data-line-number="11">    Body       *BlockStatement</a>
<a class="sourceLine" id="cb206-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb206-13" data-line-number="13"></a>
<a class="sourceLine" id="cb206-14" data-line-number="14"><span class="kw">func</span> (fl *FunctionLiteral) expressionNode()      {}</a>
<a class="sourceLine" id="cb206-15" data-line-number="15"><span class="kw">func</span> (fl *FunctionLiteral) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> fl.Token.Literal }</a>
<a class="sourceLine" id="cb206-16" data-line-number="16"><span class="kw">func</span> (fl *FunctionLiteral) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb206-17" data-line-number="17">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb206-18" data-line-number="18"></a>
<a class="sourceLine" id="cb206-19" data-line-number="19">    params := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb206-20" data-line-number="20">    <span class="kw">for</span> _, p := <span class="kw">range</span> fl.Parameters {</a>
<a class="sourceLine" id="cb206-21" data-line-number="21">        params = <span class="bu">append</span>(params, p.String())</a>
<a class="sourceLine" id="cb206-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb206-23" data-line-number="23"></a>
<a class="sourceLine" id="cb206-24" data-line-number="24">    out.WriteString(fl.TokenLiteral())</a>
<a class="sourceLine" id="cb206-25" data-line-number="25">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb206-26" data-line-number="26">    out.WriteString(strings.Join(params, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb206-27" data-line-number="27">    out.WriteString(<span class="st">&quot;) &quot;</span>)</a>
<a class="sourceLine" id="cb206-28" data-line-number="28">    out.WriteString(fl.Body.String())</a>
<a class="sourceLine" id="cb206-29" data-line-number="29"></a>
<a class="sourceLine" id="cb206-30" data-line-number="30">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb206-31" data-line-number="31">}</a></code></pre></div>
<p>The <code>Parameters</code> field is a slice of <code>*ast.Identifiers</code>, because that’s all there is to it, and <code>Body</code> is an <code>*ast.BlockStatement</code>, which we saw and used before.</p>
<p>Here is the test, in which we can use our helper functions <code>testLiteralExpression</code> and <code>testInfixExpression</code> again:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb207-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb207-2" data-line-number="2"></a>
<a class="sourceLine" id="cb207-3" data-line-number="3"><span class="kw">func</span> TestFunctionLiteralParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb207-4" data-line-number="4">    input := <span class="st">`fn(x, y) { x + y; }`</span></a>
<a class="sourceLine" id="cb207-5" data-line-number="5"></a>
<a class="sourceLine" id="cb207-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb207-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb207-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb207-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb207-10" data-line-number="10"></a>
<a class="sourceLine" id="cb207-11" data-line-number="11">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb207-12" data-line-number="12">        t.Fatalf(<span class="st">&quot;program.Statements does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb207-13" data-line-number="13">            <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb207-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb207-15" data-line-number="15"></a>
<a class="sourceLine" id="cb207-16" data-line-number="16">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb207-17" data-line-number="17">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb207-18" data-line-number="18">        t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb207-19" data-line-number="19">            program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb207-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb207-21" data-line-number="21"></a>
<a class="sourceLine" id="cb207-22" data-line-number="22">    function, ok := stmt.Expression.(*ast.FunctionLiteral)</a>
<a class="sourceLine" id="cb207-23" data-line-number="23">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb207-24" data-line-number="24">        t.Fatalf(<span class="st">&quot;stmt.Expression is not ast.FunctionLiteral. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb207-25" data-line-number="25">            stmt.Expression)</a>
<a class="sourceLine" id="cb207-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb207-27" data-line-number="27"></a>
<a class="sourceLine" id="cb207-28" data-line-number="28">    <span class="kw">if</span> <span class="bu">len</span>(function.Parameters) != <span class="dv">2</span> {</a>
<a class="sourceLine" id="cb207-29" data-line-number="29">        t.Fatalf(<span class="st">&quot;function literal parameters wrong. want 2, got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb207-30" data-line-number="30">            <span class="bu">len</span>(function.Parameters))</a>
<a class="sourceLine" id="cb207-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb207-32" data-line-number="32"></a>
<a class="sourceLine" id="cb207-33" data-line-number="33">    testLiteralExpression(t, function.Parameters[<span class="dv">0</span>], <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb207-34" data-line-number="34">    testLiteralExpression(t, function.Parameters[<span class="dv">1</span>], <span class="st">&quot;y&quot;</span>)</a>
<a class="sourceLine" id="cb207-35" data-line-number="35"></a>
<a class="sourceLine" id="cb207-36" data-line-number="36">    <span class="kw">if</span> <span class="bu">len</span>(function.Body.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb207-37" data-line-number="37">        t.Fatalf(<span class="st">&quot;function.Body.Statements has not 1 statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb207-38" data-line-number="38">            <span class="bu">len</span>(function.Body.Statements))</a>
<a class="sourceLine" id="cb207-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb207-40" data-line-number="40"></a>
<a class="sourceLine" id="cb207-41" data-line-number="41">    bodyStmt, ok := function.Body.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb207-42" data-line-number="42">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb207-43" data-line-number="43">        t.Fatalf(<span class="st">&quot;function body stmt is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb207-44" data-line-number="44">            function.Body.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb207-45" data-line-number="45">    }</a>
<a class="sourceLine" id="cb207-46" data-line-number="46"></a>
<a class="sourceLine" id="cb207-47" data-line-number="47">    testInfixExpression(t, bodyStmt.Expression, <span class="st">&quot;x&quot;</span>, <span class="st">&quot;+&quot;</span>, <span class="st">&quot;y&quot;</span>)</a>
<a class="sourceLine" id="cb207-48" data-line-number="48">}</a></code></pre></div>
<p>So, the test has three main parts: check that the <code>*ast.FunctionLiteral</code> is there, check that the parameter list is correct and make sure that the function body contains the correct statements. The last part is not strictly necessary, since we already tested parsing block statements before in our tests for <code>IfExpression</code>s. But I’m okay with duplicating some test assertions here that possibly alarm us when hooking up the parsing of block statements failed.</p>
<p>With only <code>ast.FunctionLiteral</code> defined and nothing changed in the parser, the tests fail:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb208-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb208-2" data-line-number="2">--- FAIL: TestFunctionLiteralParsing (0.00s)</a>
<a class="sourceLine" id="cb208-3" data-line-number="3">  parser_test.go:755: parser has 6 errors</a>
<a class="sourceLine" id="cb208-4" data-line-number="4">  parser_test.go:757: parser error: &quot;no prefix parse function for FUNCTION found&quot;</a>
<a class="sourceLine" id="cb208-5" data-line-number="5">  parser_test.go:757: parser error: &quot;expected next token to be ), got , instead&quot;</a>
<a class="sourceLine" id="cb208-6" data-line-number="6">  parser_test.go:757: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb208-7" data-line-number="7">  parser_test.go:757: parser error: &quot;no prefix parse function for ) found&quot;</a>
<a class="sourceLine" id="cb208-8" data-line-number="8">  parser_test.go:757: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb208-9" data-line-number="9">  parser_test.go:757: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb208-10" data-line-number="10">FAIL</a>
<a class="sourceLine" id="cb208-11" data-line-number="11">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>It’s clear that we need to register a new <code>prefixParseFn</code> for <code>token.FUNCTION</code> tokens.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb209-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb209-2" data-line-number="2"></a>
<a class="sourceLine" id="cb209-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb209-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb209-5" data-line-number="5">    p.registerPrefix(token.FUNCTION, p.parseFunctionLiteral)</a>
<a class="sourceLine" id="cb209-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb209-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb209-8" data-line-number="8"></a>
<a class="sourceLine" id="cb209-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseFunctionLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb209-10" data-line-number="10">    lit := &amp;ast.FunctionLiteral{Token: p.curToken}</a>
<a class="sourceLine" id="cb209-11" data-line-number="11"></a>
<a class="sourceLine" id="cb209-12" data-line-number="12">    <span class="kw">if</span> !p.expectPeek(token.LPAREN) {</a>
<a class="sourceLine" id="cb209-13" data-line-number="13">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb209-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb209-15" data-line-number="15"></a>
<a class="sourceLine" id="cb209-16" data-line-number="16">    lit.Parameters = p.parseFunctionParameters()</a>
<a class="sourceLine" id="cb209-17" data-line-number="17"></a>
<a class="sourceLine" id="cb209-18" data-line-number="18">    <span class="kw">if</span> !p.expectPeek(token.LBRACE) {</a>
<a class="sourceLine" id="cb209-19" data-line-number="19">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb209-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb209-21" data-line-number="21"></a>
<a class="sourceLine" id="cb209-22" data-line-number="22">    lit.Body = p.parseBlockStatement()</a>
<a class="sourceLine" id="cb209-23" data-line-number="23"></a>
<a class="sourceLine" id="cb209-24" data-line-number="24">    <span class="kw">return</span> lit</a>
<a class="sourceLine" id="cb209-25" data-line-number="25">}</a></code></pre></div>
<p>The <code>parseFunctionParameters</code> method we use here to parse the literal’s parameters looks like this:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb210-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb210-2" data-line-number="2"></a>
<a class="sourceLine" id="cb210-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseFunctionParameters() []*ast.Identifier {</a>
<a class="sourceLine" id="cb210-4" data-line-number="4">    identifiers := []*ast.Identifier{}</a>
<a class="sourceLine" id="cb210-5" data-line-number="5"></a>
<a class="sourceLine" id="cb210-6" data-line-number="6">    <span class="kw">if</span> p.peekTokenIs(token.RPAREN) {</a>
<a class="sourceLine" id="cb210-7" data-line-number="7">        p.nextToken()</a>
<a class="sourceLine" id="cb210-8" data-line-number="8">        <span class="kw">return</span> identifiers</a>
<a class="sourceLine" id="cb210-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb210-10" data-line-number="10"></a>
<a class="sourceLine" id="cb210-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb210-12" data-line-number="12"></a>
<a class="sourceLine" id="cb210-13" data-line-number="13">    ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb210-14" data-line-number="14">    identifiers = <span class="bu">append</span>(identifiers, ident)</a>
<a class="sourceLine" id="cb210-15" data-line-number="15"></a>
<a class="sourceLine" id="cb210-16" data-line-number="16">    <span class="kw">for</span> p.peekTokenIs(token.COMMA) {</a>
<a class="sourceLine" id="cb210-17" data-line-number="17">        p.nextToken()</a>
<a class="sourceLine" id="cb210-18" data-line-number="18">        p.nextToken()</a>
<a class="sourceLine" id="cb210-19" data-line-number="19">        ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb210-20" data-line-number="20">        identifiers = <span class="bu">append</span>(identifiers, ident)</a>
<a class="sourceLine" id="cb210-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb210-22" data-line-number="22"></a>
<a class="sourceLine" id="cb210-23" data-line-number="23">    <span class="kw">if</span> !p.expectPeek(token.RPAREN) {</a>
<a class="sourceLine" id="cb210-24" data-line-number="24">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb210-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb210-26" data-line-number="26"></a>
<a class="sourceLine" id="cb210-27" data-line-number="27">    <span class="kw">return</span> identifiers</a>
<a class="sourceLine" id="cb210-28" data-line-number="28">}</a></code></pre></div>
<p>There’s the heart of the matter. <code>parseFunctionParameters</code> constructs the slice of parameters by repeatedly building identifiers from the comma separated list. It also makes an early exit if the list is empty and it carefully handles lists of varying sizes.</p>
<p>For a method like this it really pays off to have another set of tests that check the edge cases: an empty parameter list, a list with one parameter and a list with multiple parameters.</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb211-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb211-2" data-line-number="2"></a>
<a class="sourceLine" id="cb211-3" data-line-number="3"><span class="kw">func</span> TestFunctionParameterParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb211-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb211-5" data-line-number="5">        input          <span class="dt">string</span></a>
<a class="sourceLine" id="cb211-6" data-line-number="6">        expectedParams []<span class="dt">string</span></a>
<a class="sourceLine" id="cb211-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb211-8" data-line-number="8">        {input: <span class="st">&quot;fn() {};&quot;</span>, expectedParams: []<span class="dt">string</span>{}},</a>
<a class="sourceLine" id="cb211-9" data-line-number="9">        {input: <span class="st">&quot;fn(x) {};&quot;</span>, expectedParams: []<span class="dt">string</span>{<span class="st">&quot;x&quot;</span>}},</a>
<a class="sourceLine" id="cb211-10" data-line-number="10">        {input: <span class="st">&quot;fn(x, y, z) {};&quot;</span>, expectedParams: []<span class="dt">string</span>{<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>}},</a>
<a class="sourceLine" id="cb211-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb211-12" data-line-number="12"></a>
<a class="sourceLine" id="cb211-13" data-line-number="13">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb211-14" data-line-number="14">        l := lexer.New(tt.input)</a>
<a class="sourceLine" id="cb211-15" data-line-number="15">        p := New(l)</a>
<a class="sourceLine" id="cb211-16" data-line-number="16">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb211-17" data-line-number="17">        checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb211-18" data-line-number="18"></a>
<a class="sourceLine" id="cb211-19" data-line-number="19">        stmt := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb211-20" data-line-number="20">        function := stmt.Expression.(*ast.FunctionLiteral)</a>
<a class="sourceLine" id="cb211-21" data-line-number="21"></a>
<a class="sourceLine" id="cb211-22" data-line-number="22">        <span class="kw">if</span> <span class="bu">len</span>(function.Parameters) != <span class="bu">len</span>(tt.expectedParams) {</a>
<a class="sourceLine" id="cb211-23" data-line-number="23">            t.Errorf(<span class="st">&quot;length parameters wrong. want %d, got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb211-24" data-line-number="24">                <span class="bu">len</span>(tt.expectedParams), <span class="bu">len</span>(function.Parameters))</a>
<a class="sourceLine" id="cb211-25" data-line-number="25">        }</a>
<a class="sourceLine" id="cb211-26" data-line-number="26"></a>
<a class="sourceLine" id="cb211-27" data-line-number="27">        <span class="kw">for</span> i, ident := <span class="kw">range</span> tt.expectedParams {</a>
<a class="sourceLine" id="cb211-28" data-line-number="28">            testLiteralExpression(t, function.Parameters[i], ident)</a>
<a class="sourceLine" id="cb211-29" data-line-number="29">        }</a>
<a class="sourceLine" id="cb211-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb211-31" data-line-number="31">}</a></code></pre></div>
<p>Both of these test functions now pass:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb212-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb212-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>Function literals are in the bag! Sweet! There is only one last thing to do now before we can leave the parser and start talking about the evaluation of our AST.</p>
<h3 id="call-expressions">Call Expressions</h3>
<p>Now that we know how to parse function literals the next step is to parse the calling of a function: call expressions. Here is their structure:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb213-1" data-line-number="1">&lt;expression&gt;(&lt;comma separated expressions&gt;)</a></code></pre></div>
<p>What? Yup, that’s it, but granted, a few examples are needed. Here is the normal call expression we all know:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb214-1" data-line-number="1"><span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)</a></code></pre></div>
<p>Now think about this: the <code>add</code> is an identifier. And identifiers are expressions. The arguments <code>2</code> and <code>3</code> are expressions too - integer literals. But they don’t have to be, the arguments are just a list of expressions:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb215-1" data-line-number="1"><span class="at">add</span>(<span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span>)</a></code></pre></div>
<p>That’s valid, too. The first argument is the infix expression <code>2 + 2</code> and the second one is <code>3 * 3 * 3</code>. So far, so good. Now, let’s look at the function that’s being called here. In this case the function is bound to the identifier <code>add</code>. The identifier <code>add</code> returns this function when it’s evaluated. That means, we could go straight to the source, skip the identifier and replace <code>add</code> with a function literal:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb216-1" data-line-number="1"><span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> x <span class="op">+</span> y<span class="op">;</span> <span class="op">}</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)</a></code></pre></div>
<p>Yes, that’s valid. We can also use function literals as arguments:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb217-1" data-line-number="1"><span class="at">callsFunction</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> x <span class="op">+</span> y<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Let’s look at the structure again:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb218-1" data-line-number="1">&lt;expression&gt;(&lt;comma separated expressions&gt;)</a></code></pre></div>
<p>Call expressions consist of an expression that results in a function when evaluated and a list of expressions that are the arguments to this function call. As an AST node they look like this:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb219-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb219-2" data-line-number="2"></a>
<a class="sourceLine" id="cb219-3" data-line-number="3"><span class="kw">type</span> CallExpression <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb219-4" data-line-number="4">    Token     token.Token <span class="co">// The &#39;(&#39; token</span></a>
<a class="sourceLine" id="cb219-5" data-line-number="5">    Function  Expression  <span class="co">// Identifier or FunctionLiteral</span></a>
<a class="sourceLine" id="cb219-6" data-line-number="6">    Arguments []Expression</a>
<a class="sourceLine" id="cb219-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb219-8" data-line-number="8"></a>
<a class="sourceLine" id="cb219-9" data-line-number="9"><span class="kw">func</span> (ce *CallExpression) expressionNode()      {}</a>
<a class="sourceLine" id="cb219-10" data-line-number="10"><span class="kw">func</span> (ce *CallExpression) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> ce.Token.Literal }</a>
<a class="sourceLine" id="cb219-11" data-line-number="11"><span class="kw">func</span> (ce *CallExpression) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb219-12" data-line-number="12">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb219-13" data-line-number="13"></a>
<a class="sourceLine" id="cb219-14" data-line-number="14">    args := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb219-15" data-line-number="15">    <span class="kw">for</span> _, a := <span class="kw">range</span> ce.Arguments {</a>
<a class="sourceLine" id="cb219-16" data-line-number="16">        args = <span class="bu">append</span>(args, a.String())</a>
<a class="sourceLine" id="cb219-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb219-18" data-line-number="18"></a>
<a class="sourceLine" id="cb219-19" data-line-number="19">    out.WriteString(ce.Function.String())</a>
<a class="sourceLine" id="cb219-20" data-line-number="20">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb219-21" data-line-number="21">    out.WriteString(strings.Join(args, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb219-22" data-line-number="22">    out.WriteString(<span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb219-23" data-line-number="23"></a>
<a class="sourceLine" id="cb219-24" data-line-number="24">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb219-25" data-line-number="25">}</a></code></pre></div>
<p>The test case for call expressions is just like the rest of our test suite and makes assertions about the <code>*ast.CallExpression</code> structure:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb220-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb220-2" data-line-number="2"></a>
<a class="sourceLine" id="cb220-3" data-line-number="3"><span class="kw">func</span> TestCallExpressionParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb220-4" data-line-number="4">    input := <span class="st">&quot;add(1, 2 * 3, 4 + 5);&quot;</span></a>
<a class="sourceLine" id="cb220-5" data-line-number="5"></a>
<a class="sourceLine" id="cb220-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb220-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb220-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb220-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb220-10" data-line-number="10"></a>
<a class="sourceLine" id="cb220-11" data-line-number="11">    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb220-12" data-line-number="12">        t.Fatalf(<span class="st">&quot;program.Statements does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb220-13" data-line-number="13">            <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb220-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb220-15" data-line-number="15"></a>
<a class="sourceLine" id="cb220-16" data-line-number="16">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb220-17" data-line-number="17">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb220-18" data-line-number="18">        t.Fatalf(<span class="st">&quot;stmt is not ast.ExpressionStatement. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb220-19" data-line-number="19">            program.Statements[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb220-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb220-21" data-line-number="21"></a>
<a class="sourceLine" id="cb220-22" data-line-number="22">    exp, ok := stmt.Expression.(*ast.CallExpression)</a>
<a class="sourceLine" id="cb220-23" data-line-number="23">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb220-24" data-line-number="24">        t.Fatalf(<span class="st">&quot;stmt.Expression is not ast.CallExpression. got=%T&quot;</span>,</a>
<a class="sourceLine" id="cb220-25" data-line-number="25">            stmt.Expression)</a>
<a class="sourceLine" id="cb220-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb220-27" data-line-number="27"></a>
<a class="sourceLine" id="cb220-28" data-line-number="28">    <span class="kw">if</span> !testIdentifier(t, exp.Function, <span class="st">&quot;add&quot;</span>) {</a>
<a class="sourceLine" id="cb220-29" data-line-number="29">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb220-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb220-31" data-line-number="31"></a>
<a class="sourceLine" id="cb220-32" data-line-number="32">    <span class="kw">if</span> <span class="bu">len</span>(exp.Arguments) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb220-33" data-line-number="33">        t.Fatalf(<span class="st">&quot;wrong length of arguments. got=%d&quot;</span>, <span class="bu">len</span>(exp.Arguments))</a>
<a class="sourceLine" id="cb220-34" data-line-number="34">    }</a>
<a class="sourceLine" id="cb220-35" data-line-number="35"></a>
<a class="sourceLine" id="cb220-36" data-line-number="36">    testLiteralExpression(t, exp.Arguments[<span class="dv">0</span>], <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb220-37" data-line-number="37">    testInfixExpression(t, exp.Arguments[<span class="dv">1</span>], <span class="dv">2</span>, <span class="st">&quot;*&quot;</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb220-38" data-line-number="38">    testInfixExpression(t, exp.Arguments[<span class="dv">2</span>], <span class="dv">4</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb220-39" data-line-number="39">}</a></code></pre></div>
<p>As with function literals and parameter parsing it’s also a good idea to add a separate test for the argument parsing. Just to make sure that every corner case works and is covered by a test. I added a <code>TestCallExpressionParameterParsing</code> test function that does exactly this. You can see it in the code for this chapter.</p>
<p>So far, so familiar. But now comes the twist. If we run the tests we get this error message:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb221-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb221-2" data-line-number="2">--- FAIL: TestCallExpressionParsing (0.00s)</a>
<a class="sourceLine" id="cb221-3" data-line-number="3">  parser_test.go:853: parser has 4 errors</a>
<a class="sourceLine" id="cb221-4" data-line-number="4">  parser_test.go:855: parser error: &quot;expected next token to be ), got , instead&quot;</a>
<a class="sourceLine" id="cb221-5" data-line-number="5">  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb221-6" data-line-number="6">  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb221-7" data-line-number="7">  parser_test.go:855: parser error: &quot;no prefix parse function for ) found&quot;</a>
<a class="sourceLine" id="cb221-8" data-line-number="8">FAIL</a>
<a class="sourceLine" id="cb221-9" data-line-number="9">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>Huh, that doesn’t make a lot of sense. Why is there no error message telling us to register a <code>prefixParseFn</code> for call expressions? Because there <em>are no new token types</em> in call expressions. So what do we do instead of registering a <code>prefixParseFn</code>? Take at look at this:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb222-1" data-line-number="1"><span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></a></code></pre></div>
<p>The <code>add</code> is an identifier that’s parsed by a <code>prefixParseFn</code>. And after the identifier comes a <code>token.LPAREN</code>, right between the identifier and the list of arguments, just in the middle, in infix position… Yes, we need to register an <code>infixParseFn</code> for <code>token.LPAREN</code>. This way we parse the expression that is the function (either an identifier, or a function literal), then check for an <code>infixParseFn</code> associated with <code>token.LPAREN</code> and call it with the already parsed expression as argument. And in this <code>infixParseFn</code> we can then parse the argument list. Perfect!</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb223-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb223-2" data-line-number="2"></a>
<a class="sourceLine" id="cb223-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb223-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb223-5" data-line-number="5">    p.registerInfix(token.LPAREN, p.parseCallExpression)</a>
<a class="sourceLine" id="cb223-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb223-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb223-8" data-line-number="8"></a>
<a class="sourceLine" id="cb223-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb223-10" data-line-number="10">    exp := &amp;ast.CallExpression{Token: p.curToken, Function: function}</a>
<a class="sourceLine" id="cb223-11" data-line-number="11">    exp.Arguments = p.parseCallArguments()</a>
<a class="sourceLine" id="cb223-12" data-line-number="12">    <span class="kw">return</span> exp</a>
<a class="sourceLine" id="cb223-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb223-14" data-line-number="14"></a>
<a class="sourceLine" id="cb223-15" data-line-number="15"><span class="kw">func</span> (p *Parser) parseCallArguments() []ast.Expression {</a>
<a class="sourceLine" id="cb223-16" data-line-number="16">    args := []ast.Expression{}</a>
<a class="sourceLine" id="cb223-17" data-line-number="17"></a>
<a class="sourceLine" id="cb223-18" data-line-number="18">    <span class="kw">if</span> p.peekTokenIs(token.RPAREN) {</a>
<a class="sourceLine" id="cb223-19" data-line-number="19">        p.nextToken()</a>
<a class="sourceLine" id="cb223-20" data-line-number="20">        <span class="kw">return</span> args</a>
<a class="sourceLine" id="cb223-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb223-22" data-line-number="22"></a>
<a class="sourceLine" id="cb223-23" data-line-number="23">    p.nextToken()</a>
<a class="sourceLine" id="cb223-24" data-line-number="24">    args = <span class="bu">append</span>(args, p.parseExpression(LOWEST))</a>
<a class="sourceLine" id="cb223-25" data-line-number="25"></a>
<a class="sourceLine" id="cb223-26" data-line-number="26">    <span class="kw">for</span> p.peekTokenIs(token.COMMA) {</a>
<a class="sourceLine" id="cb223-27" data-line-number="27">        p.nextToken()</a>
<a class="sourceLine" id="cb223-28" data-line-number="28">        p.nextToken()</a>
<a class="sourceLine" id="cb223-29" data-line-number="29">        args = <span class="bu">append</span>(args, p.parseExpression(LOWEST))</a>
<a class="sourceLine" id="cb223-30" data-line-number="30">    }</a>
<a class="sourceLine" id="cb223-31" data-line-number="31"></a>
<a class="sourceLine" id="cb223-32" data-line-number="32">    <span class="kw">if</span> !p.expectPeek(token.RPAREN) {</a>
<a class="sourceLine" id="cb223-33" data-line-number="33">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb223-34" data-line-number="34">    }</a>
<a class="sourceLine" id="cb223-35" data-line-number="35"></a>
<a class="sourceLine" id="cb223-36" data-line-number="36">    <span class="kw">return</span> args</a>
<a class="sourceLine" id="cb223-37" data-line-number="37">}</a></code></pre></div>
<p><code>parseCallExpression</code> receives the already parsed <code>function</code> as argument and uses it to construct an <code>*ast.CallExpression</code> node. To parse the argument list we call <code>parseCallArguments</code>, which looks strikingly similar to <code>parseFunctionParameters</code>, except that it’s more generic and returns a slice of <code>ast.Expression</code> and not <code>*ast.Identifier</code>.</p>
<p>There is nothing here we haven’t seen before. All we did was register a new <code>infixParseFn</code>. The tests still fail though:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb224-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb224-2" data-line-number="2">--- FAIL: TestCallExpressionParsing (0.00s)</a>
<a class="sourceLine" id="cb224-3" data-line-number="3">  parser_test.go:853: parser has 4 errors</a>
<a class="sourceLine" id="cb224-4" data-line-number="4">  parser_test.go:855: parser error: &quot;expected next token to be ), got , instead&quot;</a>
<a class="sourceLine" id="cb224-5" data-line-number="5">  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb224-6" data-line-number="6">  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb224-7" data-line-number="7">  parser_test.go:855: parser error: &quot;no prefix parse function for ) found&quot;</a>
<a class="sourceLine" id="cb224-8" data-line-number="8">FAIL</a>
<a class="sourceLine" id="cb224-9" data-line-number="9">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>The reason that it still doesn’t work is that the <code>(</code> in <code>add(1, 2)</code> acts like an infix operator now, but we haven’t assigned a precedence to it. It doesn’t have the right “stickiness” yet, so <code>parseExpression</code> doesn’t return what we want. But call expressions have the highest precedence of all, so it’s important that we fix our precedences table:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb225-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb225-2" data-line-number="2"></a>
<a class="sourceLine" id="cb225-3" data-line-number="3"><span class="kw">var</span> precedences = <span class="kw">map</span>[token.TokenType]<span class="dt">int</span>{</a>
<a class="sourceLine" id="cb225-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb225-5" data-line-number="5">    token.LPAREN:   CALL,</a>
<a class="sourceLine" id="cb225-6" data-line-number="6">}</a></code></pre></div>
<p>To make sure that call expressions really have the highest precedence we can just extend our <code>TestOperatorPrecedenceParsing</code> test function:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb226-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb226-2" data-line-number="2"></a>
<a class="sourceLine" id="cb226-3" data-line-number="3"><span class="kw">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb226-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb226-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb226-6" data-line-number="6">        expected <span class="dt">string</span></a>
<a class="sourceLine" id="cb226-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb226-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb226-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb226-10" data-line-number="10">            <span class="st">&quot;a + add(b * c) + d&quot;</span>,</a>
<a class="sourceLine" id="cb226-11" data-line-number="11">            <span class="st">&quot;((a + add((b * c))) + d)&quot;</span>,</a>
<a class="sourceLine" id="cb226-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb226-13" data-line-number="13">        {</a>
<a class="sourceLine" id="cb226-14" data-line-number="14">            <span class="st">&quot;add(a, b, 1, 2 * 3, 4 + 5, add(6, 7 * 8))&quot;</span>,</a>
<a class="sourceLine" id="cb226-15" data-line-number="15">            <span class="st">&quot;add(a, b, 1, (2 * 3), (4 + 5), add(6, (7 * 8)))&quot;</span>,</a>
<a class="sourceLine" id="cb226-16" data-line-number="16">        },</a>
<a class="sourceLine" id="cb226-17" data-line-number="17">        {</a>
<a class="sourceLine" id="cb226-18" data-line-number="18">            <span class="st">&quot;add(a + b + c * d / f + g)&quot;</span>,</a>
<a class="sourceLine" id="cb226-19" data-line-number="19">            <span class="st">&quot;add((((a + b) + ((c * d) / f)) + g))&quot;</span>,</a>
<a class="sourceLine" id="cb226-20" data-line-number="20">        },</a>
<a class="sourceLine" id="cb226-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb226-22" data-line-number="22"></a>
<a class="sourceLine" id="cb226-23" data-line-number="23"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb226-24" data-line-number="24">}</a></code></pre></div>
<p>If we now run the tests again, we can see that all of them pass:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb227-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb227-2" data-line-number="2">ok      monkey/parser   0.008s</a></code></pre></div>
<p>Yes, all of them: the unit test, the test for argument parsing and the precedence tests - wow! They all pass! And if that wasn’t enough, here’s some more good news: we are done. Yes, the parser is finished. Granted, we’ll come back to it later, at the end of the book, to extend it once more. But for now: that’s it! The AST is fully defined and the parser works - it’s time to move on to the topic of evaluation.</p>
<p>Before we do that though, let’s remove the TODOs we left in the code and extend our REPL to integrate the parser.</p>
<h3 id="removing-todos">Removing TODOs</h3>
<p>When we wrote the code that parses let and return statements we took a shortcut by skipping over the expressions:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb228-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb228-2" data-line-number="2"></a>
<a class="sourceLine" id="cb228-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</a>
<a class="sourceLine" id="cb228-4" data-line-number="4">    stmt := &amp;ast.LetStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb228-5" data-line-number="5"></a>
<a class="sourceLine" id="cb228-6" data-line-number="6">    <span class="kw">if</span> !p.expectPeek(token.IDENT) {</a>
<a class="sourceLine" id="cb228-7" data-line-number="7">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb228-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb228-9" data-line-number="9"></a>
<a class="sourceLine" id="cb228-10" data-line-number="10">    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb228-11" data-line-number="11"></a>
<a class="sourceLine" id="cb228-12" data-line-number="12">    <span class="kw">if</span> !p.expectPeek(token.ASSIGN) {</a>
<a class="sourceLine" id="cb228-13" data-line-number="13">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb228-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb228-15" data-line-number="15"></a>
<a class="sourceLine" id="cb228-16" data-line-number="16">    <span class="co">// </span><span class="al">TODO</span><span class="co">: We&#39;re skipping the expressions until we</span></a>
<a class="sourceLine" id="cb228-17" data-line-number="17">    <span class="co">// encounter a semicolon</span></a>
<a class="sourceLine" id="cb228-18" data-line-number="18">    <span class="kw">for</span> !p.curTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb228-19" data-line-number="19">        p.nextToken()</a>
<a class="sourceLine" id="cb228-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb228-21" data-line-number="21"></a>
<a class="sourceLine" id="cb228-22" data-line-number="22">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb228-23" data-line-number="23">}</a></code></pre></div>
<p>The same <code>TODO</code> sits in <code>parseReturnStatement</code>. It’s time to get rid of them. No shortcuts. First of all, we need to extend our existing tests to make sure that the expressions, that are parsed as part of a let or return statement, are actually there. We do this by using our helper functions (that don’t distract from the focus of the test) and different expression types, so we know that <code>parseExpression</code> is correctly integrated.</p>
<p>Here is what the <code>TestLetStatement</code> function looks like:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb229-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb229-2" data-line-number="2"></a>
<a class="sourceLine" id="cb229-3" data-line-number="3"><span class="kw">func</span> TestLetStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb229-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb229-5" data-line-number="5">        input              <span class="dt">string</span></a>
<a class="sourceLine" id="cb229-6" data-line-number="6">        expectedIdentifier <span class="dt">string</span></a>
<a class="sourceLine" id="cb229-7" data-line-number="7">        expectedValue      <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb229-8" data-line-number="8">    }{</a>
<a class="sourceLine" id="cb229-9" data-line-number="9">        {<span class="st">&quot;let x = 5;&quot;</span>, <span class="st">&quot;x&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb229-10" data-line-number="10">        {<span class="st">&quot;let y = true;&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb229-11" data-line-number="11">        {<span class="st">&quot;let foobar = y;&quot;</span>, <span class="st">&quot;foobar&quot;</span>, <span class="st">&quot;y&quot;</span>},</a>
<a class="sourceLine" id="cb229-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb229-13" data-line-number="13"></a>
<a class="sourceLine" id="cb229-14" data-line-number="14">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb229-15" data-line-number="15">        l := lexer.New(tt.input)</a>
<a class="sourceLine" id="cb229-16" data-line-number="16">        p := New(l)</a>
<a class="sourceLine" id="cb229-17" data-line-number="17">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb229-18" data-line-number="18">        checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb229-19" data-line-number="19"></a>
<a class="sourceLine" id="cb229-20" data-line-number="20">        <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb229-21" data-line-number="21">            t.Fatalf(<span class="st">&quot;program.Statements does not contain 1 statements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb229-22" data-line-number="22">                <span class="bu">len</span>(program.Statements))</a>
<a class="sourceLine" id="cb229-23" data-line-number="23">        }</a>
<a class="sourceLine" id="cb229-24" data-line-number="24"></a>
<a class="sourceLine" id="cb229-25" data-line-number="25">        stmt := program.Statements[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb229-26" data-line-number="26">        <span class="kw">if</span> !testLetStatement(t, stmt, tt.expectedIdentifier) {</a>
<a class="sourceLine" id="cb229-27" data-line-number="27">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb229-28" data-line-number="28">        }</a>
<a class="sourceLine" id="cb229-29" data-line-number="29"></a>
<a class="sourceLine" id="cb229-30" data-line-number="30">        val := stmt.(*ast.LetStatement).Value</a>
<a class="sourceLine" id="cb229-31" data-line-number="31">        <span class="kw">if</span> !testLiteralExpression(t, val, tt.expectedValue) {</a>
<a class="sourceLine" id="cb229-32" data-line-number="32">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb229-33" data-line-number="33">        }</a>
<a class="sourceLine" id="cb229-34" data-line-number="34">    }</a>
<a class="sourceLine" id="cb229-35" data-line-number="35">}</a></code></pre></div>
<p>The same needs to be done for <code>TestReturnStatements</code>. And the fix is trivial, since we did such great work before. We merely need to hook up <code>parseExpression</code> in <code>parseReturnStatement</code> and <code>parseLetStatement</code>. And we also need to take care of optional semicolons, which we already know how to do from <code>parseExpressionStatement</code>. The updated, fully-working versions of <code>parseReturnStatement</code> and <code>parseLetStatement</code> look like this:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb230-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb230-2" data-line-number="2"></a>
<a class="sourceLine" id="cb230-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseReturnStatement() *ast.ReturnStatement {</a>
<a class="sourceLine" id="cb230-4" data-line-number="4">    stmt := &amp;ast.ReturnStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb230-5" data-line-number="5"></a>
<a class="sourceLine" id="cb230-6" data-line-number="6">    p.nextToken()</a>
<a class="sourceLine" id="cb230-7" data-line-number="7"></a>
<a class="sourceLine" id="cb230-8" data-line-number="8">    stmt.ReturnValue = p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb230-9" data-line-number="9"></a>
<a class="sourceLine" id="cb230-10" data-line-number="10">    <span class="kw">if</span> p.peekTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb230-11" data-line-number="11">        p.nextToken()</a>
<a class="sourceLine" id="cb230-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb230-13" data-line-number="13"></a>
<a class="sourceLine" id="cb230-14" data-line-number="14">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb230-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb230-16" data-line-number="16"></a>
<a class="sourceLine" id="cb230-17" data-line-number="17"><span class="kw">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</a>
<a class="sourceLine" id="cb230-18" data-line-number="18">    stmt := &amp;ast.LetStatement{Token: p.curToken}</a>
<a class="sourceLine" id="cb230-19" data-line-number="19"></a>
<a class="sourceLine" id="cb230-20" data-line-number="20">    <span class="kw">if</span> !p.expectPeek(token.IDENT) {</a>
<a class="sourceLine" id="cb230-21" data-line-number="21">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb230-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb230-23" data-line-number="23"></a>
<a class="sourceLine" id="cb230-24" data-line-number="24">    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb230-25" data-line-number="25"></a>
<a class="sourceLine" id="cb230-26" data-line-number="26">    <span class="kw">if</span> !p.expectPeek(token.ASSIGN) {</a>
<a class="sourceLine" id="cb230-27" data-line-number="27">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb230-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb230-29" data-line-number="29"></a>
<a class="sourceLine" id="cb230-30" data-line-number="30">    p.nextToken()</a>
<a class="sourceLine" id="cb230-31" data-line-number="31"></a>
<a class="sourceLine" id="cb230-32" data-line-number="32">    stmt.Value = p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb230-33" data-line-number="33"></a>
<a class="sourceLine" id="cb230-34" data-line-number="34">    <span class="kw">if</span> p.peekTokenIs(token.SEMICOLON) {</a>
<a class="sourceLine" id="cb230-35" data-line-number="35">        p.nextToken()</a>
<a class="sourceLine" id="cb230-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb230-37" data-line-number="37"></a>
<a class="sourceLine" id="cb230-38" data-line-number="38">    <span class="kw">return</span> stmt</a>
<a class="sourceLine" id="cb230-39" data-line-number="39">}</a></code></pre></div>
<p>Ah! All TODOs removed from the code. Let’s take this parser for a test drive.</p>
<h2 id="read-parse-print-loop">2.9 - Read-Parse-Print-Loop</h2>
<p>Up until now our REPL was more of a RLPL, a read-lex-print-loop. We don’t know how to evaluate code yet, so replacing the “lex” with “evaluate” is still out of the question. But what we most certainly know by now is parsing. It’s time to replace the “lex” with “parse” and build a RPPL.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb231-1" data-line-number="1"><span class="co">// repl/repl.go</span></a>
<a class="sourceLine" id="cb231-2" data-line-number="2"></a>
<a class="sourceLine" id="cb231-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb231-4" data-line-number="4">    <span class="st">&quot;bufio&quot;</span></a>
<a class="sourceLine" id="cb231-5" data-line-number="5">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb231-6" data-line-number="6">    <span class="st">&quot;io&quot;</span></a>
<a class="sourceLine" id="cb231-7" data-line-number="7">    <span class="st">&quot;monkey/lexer&quot;</span></a>
<a class="sourceLine" id="cb231-8" data-line-number="8">    <span class="st">&quot;monkey/parser&quot;</span></a>
<a class="sourceLine" id="cb231-9" data-line-number="9">)</a>
<a class="sourceLine" id="cb231-10" data-line-number="10"></a>
<a class="sourceLine" id="cb231-11" data-line-number="11"><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</a>
<a class="sourceLine" id="cb231-12" data-line-number="12">    scanner := bufio.NewScanner(in)</a>
<a class="sourceLine" id="cb231-13" data-line-number="13"></a>
<a class="sourceLine" id="cb231-14" data-line-number="14">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb231-15" data-line-number="15">        fmt.Printf(PROMPT)</a>
<a class="sourceLine" id="cb231-16" data-line-number="16">        scanned := scanner.Scan()</a>
<a class="sourceLine" id="cb231-17" data-line-number="17">        <span class="kw">if</span> !scanned {</a>
<a class="sourceLine" id="cb231-18" data-line-number="18">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb231-19" data-line-number="19">        }</a>
<a class="sourceLine" id="cb231-20" data-line-number="20"></a>
<a class="sourceLine" id="cb231-21" data-line-number="21">        line := scanner.Text()</a>
<a class="sourceLine" id="cb231-22" data-line-number="22">        l := lexer.New(line)</a>
<a class="sourceLine" id="cb231-23" data-line-number="23">        p := parser.New(l)</a>
<a class="sourceLine" id="cb231-24" data-line-number="24"></a>
<a class="sourceLine" id="cb231-25" data-line-number="25">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb231-26" data-line-number="26">        <span class="kw">if</span> <span class="bu">len</span>(p.Errors()) != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb231-27" data-line-number="27">            printParserErrors(out, p.Errors())</a>
<a class="sourceLine" id="cb231-28" data-line-number="28">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb231-29" data-line-number="29">        }</a>
<a class="sourceLine" id="cb231-30" data-line-number="30"></a>
<a class="sourceLine" id="cb231-31" data-line-number="31">        io.WriteString(out, program.String())</a>
<a class="sourceLine" id="cb231-32" data-line-number="32">        io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb231-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb231-34" data-line-number="34">}</a>
<a class="sourceLine" id="cb231-35" data-line-number="35"></a>
<a class="sourceLine" id="cb231-36" data-line-number="36"><span class="kw">func</span> printParserErrors(out io.Writer, errors []<span class="dt">string</span>) {</a>
<a class="sourceLine" id="cb231-37" data-line-number="37">    <span class="kw">for</span> _, msg := <span class="kw">range</span> errors {</a>
<a class="sourceLine" id="cb231-38" data-line-number="38">        io.WriteString(out, <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>+msg+<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb231-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb231-40" data-line-number="40">}</a></code></pre></div>
<p>Here we extend our loop to parse the line we just entered in the REPL. The output of the parser, an <code>*ast.Program</code>, is then printed by calling its <code>String</code> method, which recursively calls the <code>String</code> method of all statements belonging to that program. Now we can take the parser for a spin - interactively on the command line:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb232-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb232-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb232-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb232-4" data-line-number="4">&gt;&gt; let x = 1 * 2 * 3 * 4 * 5</a>
<a class="sourceLine" id="cb232-5" data-line-number="5">let x = ((((1 * 2) * 3) * 4) * 5);</a>
<a class="sourceLine" id="cb232-6" data-line-number="6">&gt;&gt; x * y / 2 + 3 * 8 - 123</a>
<a class="sourceLine" id="cb232-7" data-line-number="7">((((x * y) / 2) + (3 * 8)) - 123)</a>
<a class="sourceLine" id="cb232-8" data-line-number="8">&gt;&gt; true == false</a>
<a class="sourceLine" id="cb232-9" data-line-number="9">(true == false)</a>
<a class="sourceLine" id="cb232-10" data-line-number="10">&gt;&gt;</a></code></pre></div>
<p>Sweet! Now instead of calling <code>String</code> we could use any string-based representation of the AST to output here. We could add a <code>PrettyPrint</code> method that prints the type of the AST node and intends its child nodes correctly, or we could use ASCII color codes, or we could print an ASCII graph, or… The point is: the sky is the limit.</p>
<p>But our RPPL still has a huge drawback. Here is what happens when the parser runs into an error:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb233-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb233-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb233-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb233-4" data-line-number="4">&gt;&gt; let x 12 * 3;</a>
<a class="sourceLine" id="cb233-5" data-line-number="5">        expected next token to be =, got INT instead</a>
<a class="sourceLine" id="cb233-6" data-line-number="6">&gt;&gt;</a></code></pre></div>
<p>That’s not a very nice error message. I mean, it does the job, yes, but it’s not very nice, is it? The Monkey programming language deserves better. Here is a more user-friendly <code>printParseError</code> function that enhances the user-experience:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb234-1" data-line-number="1"><span class="co">// repl/repl.go</span></a>
<a class="sourceLine" id="cb234-2" data-line-number="2"></a>
<a class="sourceLine" id="cb234-3" data-line-number="3"><span class="kw">const</span> MONKEY_FACE = <span class="st">`            __,__</span></a>
<a class="sourceLine" id="cb234-4" data-line-number="4"><span class="st">   .--.  .-&quot;     &quot;-.  .--.</span></a>
<a class="sourceLine" id="cb234-5" data-line-number="5"><span class="st">  / .. \/  .-. .-.  \/ .. \</span></a>
<a class="sourceLine" id="cb234-6" data-line-number="6"><span class="st"> | |  &#39;|  /   Y   \  |&#39;  | |</span></a>
<a class="sourceLine" id="cb234-7" data-line-number="7"><span class="st"> | \   \  \ 0 | 0 /  /   / |</span></a>
<a class="sourceLine" id="cb234-8" data-line-number="8"><span class="st">  \ &#39;- ,\.-&quot;&quot;&quot;&quot;&quot;&quot;&quot;-./, -&#39; /</span></a>
<a class="sourceLine" id="cb234-9" data-line-number="9"><span class="st">   &#39;&#39;-&#39; /_   ^ ^   _\ &#39;-&#39;&#39;</span></a>
<a class="sourceLine" id="cb234-10" data-line-number="10"><span class="st">       |  \._   _./  |</span></a>
<a class="sourceLine" id="cb234-11" data-line-number="11"><span class="st">       \   \ &#39;~&#39; /   /</span></a>
<a class="sourceLine" id="cb234-12" data-line-number="12"><span class="st">        &#39;._ &#39;-=-&#39; _.&#39;</span></a>
<a class="sourceLine" id="cb234-13" data-line-number="13"><span class="st">           &#39;-----&#39;</span></a>
<a class="sourceLine" id="cb234-14" data-line-number="14"><span class="st">`</span></a>
<a class="sourceLine" id="cb234-15" data-line-number="15"></a>
<a class="sourceLine" id="cb234-16" data-line-number="16"><span class="kw">func</span> printParserErrors(out io.Writer, errors []<span class="dt">string</span>) {</a>
<a class="sourceLine" id="cb234-17" data-line-number="17">    io.WriteString(out, MONKEY_FACE)</a>
<a class="sourceLine" id="cb234-18" data-line-number="18">    io.WriteString(out, <span class="st">&quot;Woops! We ran into some monkey business here!</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb234-19" data-line-number="19">    io.WriteString(out, <span class="st">&quot; parser errors:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb234-20" data-line-number="20">    <span class="kw">for</span> _, msg := <span class="kw">range</span> errors {</a>
<a class="sourceLine" id="cb234-21" data-line-number="21">        io.WriteString(out, <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>+msg+<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb234-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb234-23" data-line-number="23">}</a></code></pre></div>
<p>That’s better! If we now run into any parser errors, we get to see a monkey, which, really, is more than anyone could ask for:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb235-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb235-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb235-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb235-4" data-line-number="4">&gt;&gt; let x 12 * 3</a>
<a class="sourceLine" id="cb235-5" data-line-number="5">            __,__</a>
<a class="sourceLine" id="cb235-6" data-line-number="6">   .--.  .-&quot;     &quot;-.  .--.</a>
<a class="sourceLine" id="cb235-7" data-line-number="7">  / .. \/  .-. .-.  \/ .. \</a>
<a class="sourceLine" id="cb235-8" data-line-number="8"> | |  &#39;|  /   Y   \  |&#39;  | |</a>
<a class="sourceLine" id="cb235-9" data-line-number="9"> | \   \  \ 0 | 0 /  /   / |</a>
<a class="sourceLine" id="cb235-10" data-line-number="10">  \ &#39;- ,\.-&quot;&quot;&quot;&quot;&quot;&quot;&quot;-./, -&#39; /</a>
<a class="sourceLine" id="cb235-11" data-line-number="11">   &#39;&#39;-&#39; /_   ^ ^   _\ &#39;-&#39;&#39;</a>
<a class="sourceLine" id="cb235-12" data-line-number="12">       |  \._   _./  |</a>
<a class="sourceLine" id="cb235-13" data-line-number="13">       \   \ &#39;~&#39; /   /</a>
<a class="sourceLine" id="cb235-14" data-line-number="14">        &#39;._ &#39;-=-&#39; _.&#39;</a>
<a class="sourceLine" id="cb235-15" data-line-number="15">           &#39;-----&#39;</a>
<a class="sourceLine" id="cb235-16" data-line-number="16">Woops! We ran into some monkey business here!</a>
<a class="sourceLine" id="cb235-17" data-line-number="17"> parser errors:</a>
<a class="sourceLine" id="cb235-18" data-line-number="18">        expected next token to be =, got INT instead</a>
<a class="sourceLine" id="cb235-19" data-line-number="19">&gt;&gt;</a></code></pre></div>
<p>On second thought… Anyway, it’s time to start evaluating our AST.</p>
<h1 id="evaluation">Evaluation</h1>
<h2 id="giving-meaning-to-symbols">3.1 - Giving Meaning to Symbols</h2>
<p>We are finally here. Evaluation. The E in REPL and the last thing an interpreter has to do when processing source code. This is where code becomes meaningful. Without evaluation an expression like <code>1 + 2</code> is just a series of characters, tokens, or a tree structure that represents this expression. It doesn’t mean anything. Evaluated, of course, <code>1 + 2</code> becomes <code>3</code>. <code>5 &gt; 1</code> becomes <code>true</code>, <code>5 &lt; 1</code> becomes <code>false</code> and <code>puts(&quot;Hello World!&quot;)</code> becomes the friendly message we all know.</p>
<p>The evaluation process of an interpreter defines how the programming language being interpreted works.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb236-1" data-line-number="1"><span class="kw">let</span> num <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb236-2" data-line-number="2"><span class="cf">if</span> (num) <span class="op">{</span></a>
<a class="sourceLine" id="cb236-3" data-line-number="3">  <span class="cf">return</span> a<span class="op">;</span></a>
<a class="sourceLine" id="cb236-4" data-line-number="4"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb236-5" data-line-number="5">  <span class="cf">return</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb236-6" data-line-number="6"><span class="op">}</span></a></code></pre></div>
<p>Whether this returns <code>a</code> or <code>b</code> depends on the decision of the interpreter’s evaluation process whether the integer <code>5</code> is truthy or not. In some languages it’s truthy, in others we’d need to use an expression that produces a boolean like <code>5 != 0</code>.</p>
<p>Consider this:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb237-1" data-line-number="1"><span class="kw">let</span> one <span class="op">=</span> <span class="at">fn</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb237-2" data-line-number="2">  <span class="at">printLine</span>(<span class="st">&quot;one&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb237-3" data-line-number="3">  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb237-4" data-line-number="4"><span class="op">};</span></a>
<a class="sourceLine" id="cb237-5" data-line-number="5"></a>
<a class="sourceLine" id="cb237-6" data-line-number="6"><span class="kw">let</span> two <span class="op">=</span> <span class="at">fn</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb237-7" data-line-number="7">  <span class="at">printLine</span>(<span class="st">&quot;two&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb237-8" data-line-number="8">  <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb237-9" data-line-number="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb237-10" data-line-number="10"></a>
<a class="sourceLine" id="cb237-11" data-line-number="11"><span class="at">add</span>(<span class="at">one</span>()<span class="op">,</span> <span class="at">two</span>())<span class="op">;</span></a></code></pre></div>
<p>Does this first output <code>one</code> and then <code>two</code> or the other way around? It depends on the specification of the language and ultimately on the implementation of its interpreter and in which order it evaluates the arguments in a call expression.</p>
<p>In this chapter there will be many more small choices like these, where we get to decide how Monkey is going to work and how our interpreter evaluates Monkey source code.</p>
<p>Maybe you’re skeptical, after I told you that writing a parser was fun, but trust me: this is the best part. This is where the Monkey programming language comes to life, where source code quickens and starts to breathe.</p>
<h2 id="strategies-of-evaluation">3.2 - Strategies of Evaluation</h2>
<p>Evaluation is also where interpreter implementations (regardless of which language they’re interpreting) diverge the most. There are a lot of different strategies to choose from when evaluating source code. I’ve already hinted at this in the introduction of this book, where we took a brief look at different interpreter architectures. Now that we’re here, AST in hand, the question of what to do with it and how to evaluate this shiny tree of ours is more relevant than ever, so looking at different options again is worthwhile.</p>
<p>Before we start, though, it’s also worth noting again that the line between interpreters and compilers is a blurry one. The notion of an interpreter as something that doesn’t leave executable artifacts behind (in contrast to a compiler, which does just that) gets fuzzy real fast when looking at the implementations of real-world and highly-optimized programming languages.</p>
<p>With that said, the most obvious and classical choice of what to do with the AST is to just interpret it. Traverse the AST, visit each node and do what the node signifies: print a string, add two numbers, execute a function’s body - all on the fly. Interpreters working this way are called “tree-walking interpreters” and are the archetype of interpreters. Sometimes their evaluation step is preceded by small optimizations that rewrite the AST (e.g. remove unused variable bindings) or convert it into another intermediate representation (IR) that’s more suitable for recursive and repeated evaluation.</p>
<p>Other interpreters also traverse the AST, but instead of interpreting the AST itself they first convert it to bytecode. Bytecode is another IR of the AST and a really dense one at that. The exact format and of which opcodes (the instructions that make up the bytecode) it’s composed of varies and depends on the guest and host programming languages. In general though, the opcodes are pretty similar to the mnemonics of most assembly languages; it’s a safe bet to say that most bytecode definitions contain opcodes for <code>push</code> and <code>pop</code> to do stack operations. But bytecode is not native machine code, nor is it assembly language. It can’t and won’t be executed by the operating system and the CPU of the machine the interpreter is running on. Instead it’s interpreted by a virtual machine, that’s part of the interpreter. Just like VMWare and VirtualBox emulate real machines and CPUs, these virtual machines emulate a machine that understands this particular bytecode format. This approach can yield great performance benefits.</p>
<p>A variation of this strategy doesn’t involve an AST at all. Instead of building an AST the parser emits bytecode directly. Now, are we still talking about interpreters or compilers? Isn’t emitting bytecode that gets then interpreted (or should we say “executed”?) a form of compilation? I told you: the line becomes blurry. And to make it even more fuzzy, consider this: some implementations of programming languages parse the source code, build an AST and convert this AST to bytecode. But instead of executing the operations specified by the bytecode directly in a virtual machine, the virtual machine then compiles the bytecode to native machine code, right before its executed - just in time. That’s called a JIT (for “just in time”) interpreter/compiler.</p>
<p>Others skip the compilation to bytecode. They recursively traverse the AST but before executing a particular branch of it the node is compiled to native machine code. And then executed. Again, “just in time”.</p>
<p>A slight variation of this is a mixed mode of interpretation where the interpreter recursively evaluates the AST and only after evaluating a particular branch of the AST multiple times does it compile the branch to machine code.</p>
<p>Amazing, isn’t it? So many different ways to go about this task of evaluation, so many twists and variations.</p>
<p>The choice of which strategy to choose largely depends on performance and portability needs, the programming language that’s being interpreted and how far you’re willing to go. A tree-walking interpreter that recursively evaluates an AST is probably the slowest of all approaches, but easy to build, extend, reason about and as portable as the language it’s implemented in.</p>
<p>An interpreter that compiles to bytecode and uses a virtual machine to evaluate said bytecode is going to be a lot faster. But more complicated and harder to build, too. Throw JIT compilation to machine code into the mix and now you also need to support multiple machine architectures if you want the interpreter to work on both ARM and x86 CPUs.</p>
<p>All of these approaches can be found in real-world programming languages. And most of the time the chosen approach changed with the lifetime of the language. Ruby is a great example here. Up to and including version 1.8 the interpreter was a tree-walking interpreter, executing the AST while traversing it. But with version 1.9 came the switch to a virtual machine architecture. Now the Ruby interpreter parses source code, builds an AST and then compiles this AST into bytecode, which gets then executed in a virtual machine. The increase in performance was huge.</p>
<p>The WebKit JavaScript engine JavaScriptCore and its interpreter named “Squirrelfish” also used AST walking and direct execution as its approach. Then in 2008 came the switch to a virtual machine and bytecode interpretation. Nowadays the engine has four (!) different stages of JIT compilation, which kick in at different times in the lifetime of the interpreted program – depending on which part of the program needs the best performance.</p>
<p>Another example is Lua. The main implementation of the Lua programming language started out as an interpreter that compiles to bytecode and executes the bytecode in a register-based virtual machine. 12 years after its first release another implementation of the language was born: LuaJIT. The clear goal of Mike Pall, the creator of LuaJIT, was to create the fastest Lua implementation possible. And he did. By JIT compiling a dense bytecode format to highly-optimized machine code for different architectures the LuaJIT implementation beats the original Lua in every benchmark. And not just by a tiny bit, no; it’s sometimes 50 times faster.</p>
<p>So, a lot of interpreters started out small with room for improvement. That’s exactly what we’re going to do. There are a lot of ways to build a faster interpreter, but not necessarily one that’s easier to understand. We are here to learn, to understand and to be able to build upon our work.</p>
<h2 id="a-tree-walking-interpreter">3.3 - A Tree-Walking Interpreter</h2>
<p>What we’re going to build is a tree-walking interpreter. We’re going to take the AST our parser builds for us and interpret it “on the fly”, without any preprocessing or compilation step.</p>
<p>Our interpreter will be a lot like a classic Lisp interpreter. The design we’re going to use is heavily inspired by the interpreter presented in “The Structure and Interpretation of Computer Programs” (SICP), especially its usage of environments. That doesn’t mean that we’re copying one particular interpreter, no, we’re rather using a blueprint that you can see in lot of other interpreters too, if you squint hard enough. There are really good reasons for the prevalence of this particular design: it’s the easiest way to get started, it’s easy to understand and to extend later on.</p>
<p>We only need two things really: a tree-walking evaluator and a way to represent Monkey values in our host language Go. Evaluator sounds mighty and grand, but it will be just one function called “eval”. Its job is to evaluate the AST. Here is a pseudocode version that illustrates what “evaluating on the fly” and “tree-walking” mean in the context of interpretation:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="kw">function</span> <span class="at">eval</span>(astNode) <span class="op">{</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2">  <span class="cf">if</span> (astNode is integerliteral) <span class="op">{</span></a>
<a class="sourceLine" id="cb238-3" data-line-number="3">    <span class="cf">return</span> <span class="va">astNode</span>.<span class="at">integerValue</span></a>
<a class="sourceLine" id="cb238-4" data-line-number="4"></a>
<a class="sourceLine" id="cb238-5" data-line-number="5">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (astNode is booleanLiteral) <span class="op">{</span></a>
<a class="sourceLine" id="cb238-6" data-line-number="6">    <span class="cf">return</span> <span class="va">astNode</span>.<span class="at">booleanValue</span></a>
<a class="sourceLine" id="cb238-7" data-line-number="7"></a>
<a class="sourceLine" id="cb238-8" data-line-number="8">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (astNode is infixExpression) <span class="op">{</span></a>
<a class="sourceLine" id="cb238-9" data-line-number="9"></a>
<a class="sourceLine" id="cb238-10" data-line-number="10">    leftEvaluated <span class="op">=</span> <span class="at">eval</span>(<span class="va">astNode</span>.<span class="at">Left</span>)</a>
<a class="sourceLine" id="cb238-11" data-line-number="11">    rightEvaluated <span class="op">=</span> <span class="at">eval</span>(<span class="va">astNode</span>.<span class="at">Right</span>)</a>
<a class="sourceLine" id="cb238-12" data-line-number="12"></a>
<a class="sourceLine" id="cb238-13" data-line-number="13">    <span class="cf">if</span> <span class="va">astNode</span>.<span class="at">Operator</span> <span class="op">==</span> <span class="st">&quot;+&quot;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb238-14" data-line-number="14">      <span class="cf">return</span> leftEvaluated <span class="op">+</span> rightEvaluated</a>
<a class="sourceLine" id="cb238-15" data-line-number="15">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="va">ast</span>.<span class="at">Operator</span> <span class="op">==</span> <span class="st">&quot;-&quot;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb238-16" data-line-number="16">      <span class="cf">return</span> leftEvaluated <span class="op">-</span> rightEvaluated</a>
<a class="sourceLine" id="cb238-17" data-line-number="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb238-18" data-line-number="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb238-19" data-line-number="19"><span class="op">}</span></a></code></pre></div>
<p>As you can see, <code>eval</code> is recursive. When <code>astNode is infixExpression</code> is true, <code>eval</code> calls itself again two times to evaluate the left and the right operands of the infix expression. This in turn may lead to the evaluation of another infix expression or an integer literal or a boolean literal or an identifier… We’ve already seen recursion at work when building and testing the AST. The same concepts apply here, except that we’re evaluating the tree and not building it.</p>
<p>Looking at this snippet of pseudocode you can probably imagine how easy it is to extend this function. That comes to our advantage. We’re going to build up our own <code>Eval</code> function piece by piece and add new branches and capabilities as we go along and extend our interpreter.</p>
<p>But the most interesting lines of this snippet are the return statements. What do they return? Here are two lines that bind the return value of a call to <code>eval</code> to names:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb239-1" data-line-number="1">leftEvaluated = eval(astNode.Left)</a>
<a class="sourceLine" id="cb239-2" data-line-number="2">rightEvaluated = eval(astNode.Right)</a></code></pre></div>
<p>What does <code>eval</code> return here? Of which type are the return values? The answer to these questions is the same as the one for “what kind of internal object system will our interpreter have?”</p>
<h2 id="representing-objects">3.4 - Representing Objects</h2>
<p><em>Wait, what? You never said Monkey was object oriented!</em> Yes, I never did and it’s not. <em>Why do we need “a object system” then?</em> Call it a “value system” or “object representation” then. The point is, we need to define what our “eval” function returns. We need a system that can represent the values our AST represents or values that we generate when evaluating the AST in memory.</p>
<p>Let’s say we’re evaluating the following Monkey code:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="kw">let</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb240-2" data-line-number="2"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb240-3" data-line-number="3">a <span class="op">+</span> a<span class="op">;</span></a></code></pre></div>
<p>As you can see, we’re binding the integer literal <code>5</code> to the name <code>a</code>. Then things happen. It doesn’t matter what. What matters is that when we come across the <code>a + a</code> expression later we need to access the value <code>a</code> is bound to. In order to evaluate <code>a + a</code> we need to get to the <code>5</code>. In the AST it’s represented as an <code>*ast.IntegerLiteral</code>, but how are we going to keep track of and represent the <code>5</code> while we’re evaluating the rest of the AST?</p>
<p>There are a lot of different choices when building an internal representation of values in an interpreted language. And there is a lot of wisdom about this topic spread throughout the codebases of the world’s interpreters and compilers. Each interpreter has its own way to represent values, always slightly differing from the solution that came before, adjusted for the requirements of the interpreted language.</p>
<p>Some use native types (integers, booleans, etc.) of the host language to represent values in the interpreted language, not wrapped in anything. In other languages values/objects are represented only as pointers, whereas in some programming languages native types and pointers are mixed.</p>
<p>Why the variety? For one, the host languages differ. How you represent a string of your interpreted language depends on how a string can be represented in the language the interpreter is implemented in. An interpreter written in Ruby can’t represent values the same way an interpreter written in C can.</p>
<p>And not only do the host languages differ, but the languages being interpreted do too. Some interpreted languages may only need representations of primitive data types, like integers, characters or bytes. But in others you’ll have lists, dictionaries, functions or compound data types. These differences lead to highly different requirements in regards to value representation.</p>
<p>Besides the host language and the interpreted language, the biggest influence on the design and implementation of value representations is the resulting execution speed and the memory consumption while evaluating programs. If you want to build a fast interpreter you can’t get away with a slow and bloated object system. And if you’re going to write your own garbage collector, you need to think about how it’ll keep track of the values in the system. But, on the other hand, if you don’t care about performance, then it does make sense to keep things simple and easy to understand until further requirements arise.</p>
<p>The point is this: there are a lot of different ways to represent values of the interpreted languages in the host language. The best (and maybe the only) way to learn about these different representations is to actually read through the source code of some popular interpreters. I heartily recommended the <a href="https://github.com/munificent/wren">Wren source code</a>, which includes two types of value representation, enabled/disabled by using a compiler flag.</p>
<p>Besides the representation of values inside the host language there is also the matter of how to expose these values and their representation to the user of the interpreted language. What does the “public API” of these values look like?</p>
<p>Java, for example, offers both “primitive data types” (int, byte, short, long, float, double, boolean, char) and reference types to the user. The primitive data types do not have a huge representation inside the Java implementation, they closely map to their native counterparts. Reference types on the other hand are references to compound data structures defined in the host language.</p>
<p>In Ruby the user doesn’t have access to “primitive data types”, nothing like a native value type exists because everything is an object and thus wrapped inside an internal representation. Internally Ruby doesn’t distinguish between a byte and an instance of the class <code>Pizza</code>: both are the same value type, wrapping different values.</p>
<p>There are a myriad ways to expose data to users of programming languages. Which one to choose depends on the language design and also, again, on performance requirements. If you don’t care about performance everything goes. But if you do, you need to make some smart decisions to achieve your goals.</p>
<h3 id="foundation-of-our-object-system">Foundation of our Object System</h3>
<p>Carefree as we still are about the performance of our Monkey interpreter, we choose the easy way: we’re going to represent every value we encounter when evaluating Monkey source code as an <code>Object</code>, an interface of our design. Every value will be wrapped inside a struct, which fulfills this <code>Object</code> interface.</p>
<p>In a new <code>object</code> package we define the <code>Object</code> interface and the <code>ObjectType</code> type:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb241-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb241-2" data-line-number="2"></a>
<a class="sourceLine" id="cb241-3" data-line-number="3"><span class="kw">package</span> object</a>
<a class="sourceLine" id="cb241-4" data-line-number="4"></a>
<a class="sourceLine" id="cb241-5" data-line-number="5"><span class="kw">type</span> ObjectType <span class="dt">string</span></a>
<a class="sourceLine" id="cb241-6" data-line-number="6"></a>
<a class="sourceLine" id="cb241-7" data-line-number="7"><span class="kw">type</span> Object <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb241-8" data-line-number="8">    Type() ObjectType</a>
<a class="sourceLine" id="cb241-9" data-line-number="9">    Inspect() <span class="dt">string</span></a>
<a class="sourceLine" id="cb241-10" data-line-number="10">}</a></code></pre></div>
<p>That’s pretty simple and looks a lot like what we did in the <code>token</code> package with the <code>Token</code> and <code>TokenType</code> types. Except that instead of being a struct like <code>Token</code> the <code>Object</code> type is an interface. The reason is that every value needs a different internal representation and it’s easier to define two different struct types than trying to fit booleans and integers into the same struct field.</p>
<p>At the moment we only have three data types in our Monkey interpreter: null, booleans and integers. Let’s start with implementing the integer representation and build up our object system.</p>
<h3 id="integers">Integers</h3>
<p>The <code>object.Integer</code> type is as small as you’d expect it to be:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb242-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb242-2" data-line-number="2"></a>
<a class="sourceLine" id="cb242-3" data-line-number="3"><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb242-4" data-line-number="4"></a>
<a class="sourceLine" id="cb242-5" data-line-number="5"><span class="kw">type</span> Integer <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb242-6" data-line-number="6">    Value <span class="dt">int64</span></a>
<a class="sourceLine" id="cb242-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb242-8" data-line-number="8"></a>
<a class="sourceLine" id="cb242-9" data-line-number="9"><span class="kw">func</span> (i *Integer) Inspect() <span class="dt">string</span> { <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%d&quot;</span>, i.Value) }</a></code></pre></div>
<p>Whenever we encounter an integer literal in the source code we first turn it into an <code>ast.IntegerLiteral</code> and then, when evaluating that AST node, we turn it into an <code>object.Integer</code>, saving the value inside our struct and passing around a reference to this struct.</p>
<p>In order for <code>object.Integer</code> to fulfill the <code>object.Object</code> interface, it still needs a <code>Type()</code> method that returns its <code>ObjectType</code>. Just like we did with <code>token.TokenType</code> we define constants for each <code>ObjectType</code>:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb243-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb243-2" data-line-number="2"></a>
<a class="sourceLine" id="cb243-3" data-line-number="3"><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb243-4" data-line-number="4"></a>
<a class="sourceLine" id="cb243-5" data-line-number="5"><span class="kw">type</span> ObjectType <span class="dt">string</span></a>
<a class="sourceLine" id="cb243-6" data-line-number="6"></a>
<a class="sourceLine" id="cb243-7" data-line-number="7"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb243-8" data-line-number="8">    INTEGER_OBJ = <span class="st">&quot;INTEGER&quot;</span></a>
<a class="sourceLine" id="cb243-9" data-line-number="9">)</a></code></pre></div>
<p>As I said, this is pretty much what we did in the <code>token</code> package. And with that in place we can add the <code>Type()</code> method to <code>*object.Integer</code>:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb244-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb244-2" data-line-number="2"></a>
<a class="sourceLine" id="cb244-3" data-line-number="3"><span class="kw">func</span> (i *Integer) Type() ObjectType { <span class="kw">return</span> INTEGER_OBJ }</a></code></pre></div>
<p>And we’re done with <code>Integer</code>! Onto another data type: booleans.</p>
<h3 id="booleans">Booleans</h3>
<p>If you were expecting big things of this section, I’m sorry to disappoint. <code>object.Boolean</code> is as tiny as it gets:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb245-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb245-2" data-line-number="2"></a>
<a class="sourceLine" id="cb245-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb245-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb245-5" data-line-number="5">    BOOLEAN_OBJ = <span class="st">&quot;BOOLEAN&quot;</span></a>
<a class="sourceLine" id="cb245-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb245-7" data-line-number="7"></a>
<a class="sourceLine" id="cb245-8" data-line-number="8"><span class="kw">type</span> Boolean <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb245-9" data-line-number="9">    Value <span class="dt">bool</span></a>
<a class="sourceLine" id="cb245-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb245-11" data-line-number="11"></a>
<a class="sourceLine" id="cb245-12" data-line-number="12"><span class="kw">func</span> (b *Boolean) Type() ObjectType { <span class="kw">return</span> BOOLEAN_OBJ }</a>
<a class="sourceLine" id="cb245-13" data-line-number="13"><span class="kw">func</span> (b *Boolean) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%t&quot;</span>, b.Value) }</a></code></pre></div>
<p>Just a struct that wraps a single value, a <code>bool</code>.</p>
<p>We’re close to finishing the foundation of our object system. The last thing we need to do now, before we can start with our <code>Eval</code> function, is to represent a value that isn’t there.</p>
<h3 id="null">Null</h3>
<p>Tony Hoare introduced null references to the ALGOL W language in 1965 and called this his <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">“billion-dollar mistake”</a>. Since their introduction countless systems have crashed because of references to “null”, a value that represents the absence of a value. Null (or “nil” as in some languages) doesn’t have the best reputation, to say the least.</p>
<p>I debated with myself whether Monkey should have null. On one hand, yes, the language would be safer to use if it doesn’t allow null or null references. But on the other, we’re not trying to reinvent the wheel, but to learn something. And I found that having null at my disposal lead me to think twice whenever there was a chance to use it. Kinda like having something explosive in your car leads you to driving slower and more carefully. It really made me appreciate the choices that go into the design of a programming language. That’s something I consider worthwhile. So let’s implement the <code>Null</code> type and keep a close look and steady hand when using it later on.</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb246-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb246-2" data-line-number="2"></a>
<a class="sourceLine" id="cb246-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb246-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb246-5" data-line-number="5">    NULL_OBJ  = <span class="st">&quot;NULL&quot;</span></a>
<a class="sourceLine" id="cb246-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb246-7" data-line-number="7"></a>
<a class="sourceLine" id="cb246-8" data-line-number="8"><span class="kw">type</span> Null <span class="kw">struct</span>{}</a>
<a class="sourceLine" id="cb246-9" data-line-number="9"></a>
<a class="sourceLine" id="cb246-10" data-line-number="10"><span class="kw">func</span> (n *Null) Type() ObjectType { <span class="kw">return</span> NULL_OBJ }</a>
<a class="sourceLine" id="cb246-11" data-line-number="11"><span class="kw">func</span> (n *Null) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> <span class="st">&quot;null&quot;</span> }</a></code></pre></div>
<p><code>object.Null</code> is a struct just like <code>object.Boolean</code> and <code>object.Integer</code>, except that it doesn’t wrap any value. It represents the absence of any value.</p>
<p>With <code>object.Null</code> added, our object system is now capable of representing boolean, integer and null values. That’s more than enough to get started with <code>Eval</code>.</p>
<h2 id="evaluating-expressions">3.5 - Evaluating Expressions</h2>
<p>Alright, here we go. Let’s start writing <code>Eval</code>! We have our AST and we have a new object system, that allows us to keep track of values we encounter when executing Monkey source code. It’s time to finally evaluate the AST.</p>
<p>Here is what the signature of <code>Eval</code> will look like in its first version:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb247-1" data-line-number="1"><span class="kw">func</span> Eval(node ast.Node) object.Object</a></code></pre></div>
<p><code>Eval</code> will take an <code>ast.Node</code> as input and return an <code>object.Object</code>. Remember that every node we defined in the <code>ast</code> package fulfills the <code>ast.Node</code> interface and can thus be passed to <code>Eval</code>. This allows us to use <code>Eval</code> recursively and call itself while evaluating a part of the AST. Each AST node needs a different form of evaluation and <code>Eval</code> is the place where we decide what these forms look like. As an example, let’s say that we pass an <code>*ast.Program</code> node to <code>Eval</code>. What <code>Eval</code> should do then is to evaluate each of <code>*ast.Program.Statements</code> by calling itself with a single statement. The return value of the outer call to <code>Eval</code> is the return value of the last call.</p>
<p>We’re going to start by implementing self-evaluating expressions. That’s what we call literals in the land of <code>Eval</code>. Specifically, boolean and integer literals. They are the constructs in Monkey that are easiest to evaluate, because they evaluate to themselves. If I type <code>5</code> into my REPL then <code>5</code> is also what should come out. And if I type in <code>true</code> then <code>true</code> is what I want.</p>
<p>Sounds easy enough? It is! So, let’s turn “type in 5, get back 5” into reality.</p>
<h3 id="integer-literals-1">Integer Literals</h3>
<p>Before writing any code though, what does this mean exactly? We’re given a single expression statement as input, which only contains an integer literal, and want to evaluate it so that the integer itself is returned.</p>
<p>Translated into the language of our system, it means that, given an <code>*ast.IntegerLiteral</code>, our <code>Eval</code> function should return an <code>*object.Integer</code> whose <code>Value</code> field contains the same integer as <code>*ast.IntegerLiteral.Value</code>.</p>
<p>We can easily write a test for this in our new <code>evaluator</code> package:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb248-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb248-2" data-line-number="2"></a>
<a class="sourceLine" id="cb248-3" data-line-number="3"><span class="kw">package</span> evaluator</a>
<a class="sourceLine" id="cb248-4" data-line-number="4"></a>
<a class="sourceLine" id="cb248-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb248-6" data-line-number="6">    <span class="st">&quot;monkey/lexer&quot;</span></a>
<a class="sourceLine" id="cb248-7" data-line-number="7">    <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb248-8" data-line-number="8">    <span class="st">&quot;monkey/parser&quot;</span></a>
<a class="sourceLine" id="cb248-9" data-line-number="9">    <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb248-10" data-line-number="10">)</a>
<a class="sourceLine" id="cb248-11" data-line-number="11"></a>
<a class="sourceLine" id="cb248-12" data-line-number="12"><span class="kw">func</span> TestEvalIntegerExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb248-13" data-line-number="13">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb248-14" data-line-number="14">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb248-15" data-line-number="15">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb248-16" data-line-number="16">    }{</a>
<a class="sourceLine" id="cb248-17" data-line-number="17">        {<span class="st">&quot;5&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb248-18" data-line-number="18">        {<span class="st">&quot;10&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb248-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb248-20" data-line-number="20"></a>
<a class="sourceLine" id="cb248-21" data-line-number="21">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb248-22" data-line-number="22">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb248-23" data-line-number="23">        testIntegerObject(t, evaluated, tt.expected)</a>
<a class="sourceLine" id="cb248-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb248-25" data-line-number="25">}</a>
<a class="sourceLine" id="cb248-26" data-line-number="26"></a>
<a class="sourceLine" id="cb248-27" data-line-number="27"><span class="kw">func</span> testEval(input <span class="dt">string</span>) object.Object {</a>
<a class="sourceLine" id="cb248-28" data-line-number="28">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb248-29" data-line-number="29">    p := parser.New(l)</a>
<a class="sourceLine" id="cb248-30" data-line-number="30">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb248-31" data-line-number="31"></a>
<a class="sourceLine" id="cb248-32" data-line-number="32">    <span class="kw">return</span> Eval(program)</a>
<a class="sourceLine" id="cb248-33" data-line-number="33">}</a>
<a class="sourceLine" id="cb248-34" data-line-number="34"></a>
<a class="sourceLine" id="cb248-35" data-line-number="35"><span class="kw">func</span> testIntegerObject(t *testing.T, obj object.Object, expected <span class="dt">int64</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb248-36" data-line-number="36">    result, ok := obj.(*object.Integer)</a>
<a class="sourceLine" id="cb248-37" data-line-number="37">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb248-38" data-line-number="38">        t.Errorf(<span class="st">&quot;object is not Integer. got=%T (%+v)&quot;</span>, obj, obj)</a>
<a class="sourceLine" id="cb248-39" data-line-number="39">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb248-40" data-line-number="40">    }</a>
<a class="sourceLine" id="cb248-41" data-line-number="41">    <span class="kw">if</span> result.Value != expected {</a>
<a class="sourceLine" id="cb248-42" data-line-number="42">        t.Errorf(<span class="st">&quot;object has wrong value. got=%d, want=%d&quot;</span>,</a>
<a class="sourceLine" id="cb248-43" data-line-number="43">            result.Value, expected)</a>
<a class="sourceLine" id="cb248-44" data-line-number="44">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb248-45" data-line-number="45">    }</a>
<a class="sourceLine" id="cb248-46" data-line-number="46"></a>
<a class="sourceLine" id="cb248-47" data-line-number="47">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb248-48" data-line-number="48">}</a></code></pre></div>
<p>That’s a lot of code for such a small test, isn’t it? As with our parser tests, we’re building up our testing infrastructure here. The <code>TestEvalIntegerExpression</code> test will need to grow and its current structure makes this really easy. The <code>testEval</code> and <code>testIntegerObject</code> will also find a lot of use.</p>
<p>The heart of the test is the call to <code>Eval</code> inside <code>testEval</code>. We take our input, pass it to the lexer, pass the lexer to the parser and get back an AST. And then, this is new, we pass the AST to <code>Eval</code>. The return value of <code>Eval</code> is what we make assertions about. In this case, we want the return value to be an <code>*object.Integer</code> with the correct <code>.Value</code>. In other words: we want <code>5</code> to evaluate to <code>5</code>.</p>
<p>Of course, the test fails because we haven’t defined <code>Eval</code> yet. But we already know that <code>Eval</code> should take an <code>ast.Node</code> as argument and return an <code>object.Object</code>. And whenever it encounters an <code>*ast.IntegerLiteral</code> it should return an <code>*object.Integer</code> with the correct <code>.Value</code>. Turning this into code and defining our new <code>Eval</code> with this behaviour in the <code>evaluator</code> package, we get this:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb249-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb249-2" data-line-number="2"></a>
<a class="sourceLine" id="cb249-3" data-line-number="3"><span class="kw">package</span> evaluator</a>
<a class="sourceLine" id="cb249-4" data-line-number="4"></a>
<a class="sourceLine" id="cb249-5" data-line-number="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb249-6" data-line-number="6">    <span class="st">&quot;monkey/ast&quot;</span></a>
<a class="sourceLine" id="cb249-7" data-line-number="7">    <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb249-8" data-line-number="8">)</a>
<a class="sourceLine" id="cb249-9" data-line-number="9"></a>
<a class="sourceLine" id="cb249-10" data-line-number="10"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb249-11" data-line-number="11">    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb249-12" data-line-number="12">    <span class="kw">case</span> *ast.IntegerLiteral:</a>
<a class="sourceLine" id="cb249-13" data-line-number="13">        <span class="kw">return</span> &amp;object.Integer{Value: node.Value}</a>
<a class="sourceLine" id="cb249-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb249-15" data-line-number="15"></a>
<a class="sourceLine" id="cb249-16" data-line-number="16">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb249-17" data-line-number="17">}</a></code></pre></div>
<p>Nothing surprising here, it does just what we said it should. Except that it doesn’t work. The test still fails because <code>Eval</code> returns <code>nil</code> instead of an <code>*object.Integer</code>.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb250-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb250-2" data-line-number="2">--- FAIL: TestEvalIntegerExpression (0.00s)</a>
<a class="sourceLine" id="cb250-3" data-line-number="3">  evaluator_test.go:36: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb250-4" data-line-number="4">  evaluator_test.go:36: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb250-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb250-6" data-line-number="6">FAIL    monkey/evaluator        0.006s</a></code></pre></div>
<p>The reason for this failure is that we never encounter an <code>*ast.IntegerLiteral</code> in <code>Eval</code>. We don’t traverse the AST. We should always start at the top of the tree, receiving an <code>*ast.Program</code>, and then traverse every node in it. And that’s exactly what we’re not doing here. We’re just waiting for an <code>*ast.IntegerLiteral</code>. The fix is to actually traverse the tree and evaluate every statement of the <code>*ast.Program</code>:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb251-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb251-2" data-line-number="2"></a>
<a class="sourceLine" id="cb251-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb251-4" data-line-number="4">    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb251-5" data-line-number="5"></a>
<a class="sourceLine" id="cb251-6" data-line-number="6">    <span class="co">// Statements</span></a>
<a class="sourceLine" id="cb251-7" data-line-number="7">    <span class="kw">case</span> *ast.Program:</a>
<a class="sourceLine" id="cb251-8" data-line-number="8">        <span class="kw">return</span> evalStatements(node.Statements)</a>
<a class="sourceLine" id="cb251-9" data-line-number="9"></a>
<a class="sourceLine" id="cb251-10" data-line-number="10">    <span class="kw">case</span> *ast.ExpressionStatement:</a>
<a class="sourceLine" id="cb251-11" data-line-number="11">        <span class="kw">return</span> Eval(node.Expression)</a>
<a class="sourceLine" id="cb251-12" data-line-number="12"></a>
<a class="sourceLine" id="cb251-13" data-line-number="13">    <span class="co">// Expressions</span></a>
<a class="sourceLine" id="cb251-14" data-line-number="14">    <span class="kw">case</span> *ast.IntegerLiteral:</a>
<a class="sourceLine" id="cb251-15" data-line-number="15">        <span class="kw">return</span> &amp;object.Integer{Value: node.Value}</a>
<a class="sourceLine" id="cb251-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb251-17" data-line-number="17"></a>
<a class="sourceLine" id="cb251-18" data-line-number="18">    <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb251-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb251-20" data-line-number="20"></a>
<a class="sourceLine" id="cb251-21" data-line-number="21"><span class="kw">func</span> evalStatements(stmts []ast.Statement) object.Object {</a>
<a class="sourceLine" id="cb251-22" data-line-number="22">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb251-23" data-line-number="23"></a>
<a class="sourceLine" id="cb251-24" data-line-number="24">    <span class="kw">for</span> _, statement := <span class="kw">range</span> stmts {</a>
<a class="sourceLine" id="cb251-25" data-line-number="25">        result = Eval(statement)</a>
<a class="sourceLine" id="cb251-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb251-27" data-line-number="27"></a>
<a class="sourceLine" id="cb251-28" data-line-number="28">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb251-29" data-line-number="29">}</a></code></pre></div>
<p>With these changes we evaluate every statement in a Monkey program. And if the statement is an <code>*ast.ExpressionStatement</code> we evaluate its expression. That mirrors the AST structure we get from a one line input like <code>5</code>: a program that consists of one statement, an expression statement (not a return statement and not a let statement) with an integer literal as its expression.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb252-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb252-2" data-line-number="2">ok      monkey/evaluator        0.006s</a></code></pre></div>
<p>Alright, the tests pass! We can evaluate integer literals! <em>Hey everyone, if we type in a number, a number comes out and it only took us a couple thousand lines of code and tests to do so!</em> Okay, granted, it doesn’t look like much. But it’s a start. We’re beginning to see how evaluation works and how we can extend our evaluator. The structure of <code>Eval</code> won’t change, we’ll only add to and extend it.</p>
<p>Next up on our list of self-evaluating expressions are boolean literals. But before we do that, we should celebrate our first evaluation success and treat ourselves. Let’s put the E in REPL!</p>
<h3 id="completing-the-repl">Completing the REPL</h3>
<p>Up until now the E in in our REPL was missing and we had nothing but a RPPL - a Read-Parse-Print-Loop. Now that we have <code>Eval</code> we can build a real Read-Evaluate-Print-Loop!</p>
<p>Using the evaluator in the <code>repl</code> package is as easy as you’d think it is:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb253-1" data-line-number="1"><span class="co">// repl/repl.go</span></a>
<a class="sourceLine" id="cb253-2" data-line-number="2"></a>
<a class="sourceLine" id="cb253-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb253-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb253-5" data-line-number="5">    <span class="st">&quot;monkey/evaluator&quot;</span></a>
<a class="sourceLine" id="cb253-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb253-7" data-line-number="7"></a>
<a class="sourceLine" id="cb253-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb253-9" data-line-number="9"></a>
<a class="sourceLine" id="cb253-10" data-line-number="10"><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</a>
<a class="sourceLine" id="cb253-11" data-line-number="11">    scanner := bufio.NewScanner(in)</a>
<a class="sourceLine" id="cb253-12" data-line-number="12"></a>
<a class="sourceLine" id="cb253-13" data-line-number="13">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb253-14" data-line-number="14">        fmt.Printf(PROMPT)</a>
<a class="sourceLine" id="cb253-15" data-line-number="15">        scanned := scanner.Scan()</a>
<a class="sourceLine" id="cb253-16" data-line-number="16">        <span class="kw">if</span> !scanned {</a>
<a class="sourceLine" id="cb253-17" data-line-number="17">            <span class="kw">return</span></a>
<a class="sourceLine" id="cb253-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb253-19" data-line-number="19"></a>
<a class="sourceLine" id="cb253-20" data-line-number="20">        line := scanner.Text()</a>
<a class="sourceLine" id="cb253-21" data-line-number="21">        l := lexer.New(line)</a>
<a class="sourceLine" id="cb253-22" data-line-number="22">        p := parser.New(l)</a>
<a class="sourceLine" id="cb253-23" data-line-number="23"></a>
<a class="sourceLine" id="cb253-24" data-line-number="24">        program := p.ParseProgram()</a>
<a class="sourceLine" id="cb253-25" data-line-number="25">        <span class="kw">if</span> <span class="bu">len</span>(p.Errors()) != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb253-26" data-line-number="26">            printParserErrors(out, p.Errors())</a>
<a class="sourceLine" id="cb253-27" data-line-number="27">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb253-28" data-line-number="28">        }</a>
<a class="sourceLine" id="cb253-29" data-line-number="29"></a>
<a class="sourceLine" id="cb253-30" data-line-number="30">        evaluated := evaluator.Eval(program)</a>
<a class="sourceLine" id="cb253-31" data-line-number="31">        <span class="kw">if</span> evaluated != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb253-32" data-line-number="32">            io.WriteString(out, evaluated.Inspect())</a>
<a class="sourceLine" id="cb253-33" data-line-number="33">            io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb253-34" data-line-number="34">        }</a>
<a class="sourceLine" id="cb253-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb253-36" data-line-number="36">}</a></code></pre></div>
<p>Instead of printing <code>program</code> (the AST returned by the parser) we pass <code>program</code> to <code>Eval</code>. If <code>Eval</code> returns a non-nil value, an <code>object.Object</code>, we print the output of its <code>Inspect()</code> method. In the case of an <code>*object.Integer</code> that would be the string representation of the integer it’s wrapping.</p>
<p>And with that we now have a working REPL:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb254-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb254-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb254-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb254-4" data-line-number="4">&gt;&gt; 5</a>
<a class="sourceLine" id="cb254-5" data-line-number="5">5</a>
<a class="sourceLine" id="cb254-6" data-line-number="6">&gt;&gt; 10</a>
<a class="sourceLine" id="cb254-7" data-line-number="7">10</a>
<a class="sourceLine" id="cb254-8" data-line-number="8">&gt;&gt; 999</a>
<a class="sourceLine" id="cb254-9" data-line-number="9">999</a>
<a class="sourceLine" id="cb254-10" data-line-number="10">&gt;&gt;</a></code></pre></div>
<p>Feels good, doesn’t it? Lexing, parsing, evaluating - it’s all in there. We’ve come a long way.</p>
<h3 id="boolean-literals-1">Boolean Literals</h3>
<p>Boolean literals, just like their integer counterparts, evaluate to themselves. <code>true</code> evaluates to <code>true</code> and <code>false</code> to <code>false</code>. Implementing this in <code>Eval</code> is as easy as adding support for integer literals was. The tests are equally boring:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb255-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb255-2" data-line-number="2"></a>
<a class="sourceLine" id="cb255-3" data-line-number="3"><span class="kw">func</span> TestEvalBooleanExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb255-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb255-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb255-6" data-line-number="6">        expected <span class="dt">bool</span></a>
<a class="sourceLine" id="cb255-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb255-8" data-line-number="8">        {<span class="st">&quot;true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb255-9" data-line-number="9">        {<span class="st">&quot;false&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb255-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb255-11" data-line-number="11"></a>
<a class="sourceLine" id="cb255-12" data-line-number="12">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb255-13" data-line-number="13">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb255-14" data-line-number="14">        testBooleanObject(t, evaluated, tt.expected)</a>
<a class="sourceLine" id="cb255-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb255-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb255-17" data-line-number="17"></a>
<a class="sourceLine" id="cb255-18" data-line-number="18"><span class="kw">func</span> testBooleanObject(t *testing.T, obj object.Object, expected <span class="dt">bool</span>) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb255-19" data-line-number="19">    result, ok := obj.(*object.Boolean)</a>
<a class="sourceLine" id="cb255-20" data-line-number="20">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb255-21" data-line-number="21">        t.Errorf(<span class="st">&quot;object is not Boolean. got=%T (%+v)&quot;</span>, obj, obj)</a>
<a class="sourceLine" id="cb255-22" data-line-number="22">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb255-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb255-24" data-line-number="24">    <span class="kw">if</span> result.Value != expected {</a>
<a class="sourceLine" id="cb255-25" data-line-number="25">        t.Errorf(<span class="st">&quot;object has wrong value. got=%t, want=%t&quot;</span>,</a>
<a class="sourceLine" id="cb255-26" data-line-number="26">            result.Value, expected)</a>
<a class="sourceLine" id="cb255-27" data-line-number="27">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb255-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb255-29" data-line-number="29">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb255-30" data-line-number="30">}</a></code></pre></div>
<p>We’ll extend the <code>tests</code> slice as soon as we support more expressions that result in booleans. For now, we only make sure that we get the correct output when we enter <code>true</code> or <code>false</code>. The tests fail:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb256-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb256-2" data-line-number="2">--- FAIL: TestEvalBooleanExpression (0.00s)</a>
<a class="sourceLine" id="cb256-3" data-line-number="3">  evaluator_test.go:42: object is not Boolean. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb256-4" data-line-number="4">  evaluator_test.go:42: object is not Boolean. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb256-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb256-6" data-line-number="6">FAIL    monkey/evaluator        0.006s</a></code></pre></div>
<p>Making this green is as easy as copying the <code>case</code> branch from <code>*ast.IntegerLiteral</code> and changing two identifiers:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb257-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb257-2" data-line-number="2"></a>
<a class="sourceLine" id="cb257-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb257-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb257-5" data-line-number="5">    <span class="kw">case</span> *ast.Boolean:</a>
<a class="sourceLine" id="cb257-6" data-line-number="6">        <span class="kw">return</span> &amp;object.Boolean{Value: node.Value}</a>
<a class="sourceLine" id="cb257-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb257-8" data-line-number="8">}</a></code></pre></div>
<p>That’s it! Let’s give it a spin in the REPL:</p>
<pre><code>$ go run main.go
Hello mrnugget! This is the Monkey programming language!
Feel free to type in commands
&gt;&gt; true
true
&gt;&gt; false
false
&gt;&gt;</code></pre>
<p>Pretty! But, let me ask you this: the fact that we’re creating a new <code>object.Boolean</code> every time we encounter a <code>true</code> or <code>false</code> is absurd, isn’t it? There is no difference between two <code>true</code>s. The same goes for <code>false</code>. Why use new instances every time? There are only two possible values, so let’s reference them instead of creating new ones.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb259-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb259-2" data-line-number="2"></a>
<a class="sourceLine" id="cb259-3" data-line-number="3"><span class="kw">var</span> (</a>
<a class="sourceLine" id="cb259-4" data-line-number="4">    TRUE  = &amp;object.Boolean{Value: <span class="ot">true</span>}</a>
<a class="sourceLine" id="cb259-5" data-line-number="5">    FALSE = &amp;object.Boolean{Value: <span class="ot">false</span>}</a>
<a class="sourceLine" id="cb259-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb259-7" data-line-number="7"></a>
<a class="sourceLine" id="cb259-8" data-line-number="8"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb259-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb259-10" data-line-number="10">    <span class="kw">case</span> *ast.Boolean:</a>
<a class="sourceLine" id="cb259-11" data-line-number="11">        <span class="kw">return</span> nativeBoolToBooleanObject(node.Value)</a>
<a class="sourceLine" id="cb259-12" data-line-number="12"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb259-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb259-14" data-line-number="14"></a>
<a class="sourceLine" id="cb259-15" data-line-number="15"><span class="kw">func</span> nativeBoolToBooleanObject(input <span class="dt">bool</span>) *object.Boolean {</a>
<a class="sourceLine" id="cb259-16" data-line-number="16">    <span class="kw">if</span> input {</a>
<a class="sourceLine" id="cb259-17" data-line-number="17">        <span class="kw">return</span> TRUE</a>
<a class="sourceLine" id="cb259-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb259-19" data-line-number="19">    <span class="kw">return</span> FALSE</a>
<a class="sourceLine" id="cb259-20" data-line-number="20">}</a></code></pre></div>
<p>Now there are only two instances of <code>object.Boolean</code> in our package: <code>TRUE</code> and <code>FALSE</code> and we reference them instead of allocating new <code>object.Boolean</code>s. That makes much more sense and is a small performance improvement we get without a lot of work. And while we’re at it, let’s take care of null, too.</p>
<h3 id="null-1">Null</h3>
<p>Just as there is only one <code>true</code> and one <code>false</code>, there should only be one reference to a null value. There are no variations of null. No kinda-but-not-quite-null, no half-null and no basically-the-same-as-the-other-null. Either something is this one null, or it isn’t. So let’s create one <code>NULL</code> we can reference throughout our evaluator instead of creating new <code>object.Null</code>s.</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb260-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb260-2" data-line-number="2"></a>
<a class="sourceLine" id="cb260-3" data-line-number="3"><span class="kw">var</span> (</a>
<a class="sourceLine" id="cb260-4" data-line-number="4">    NULL  = &amp;object.Null{}</a>
<a class="sourceLine" id="cb260-5" data-line-number="5">    TRUE  = &amp;object.Boolean{Value: <span class="ot">true</span>}</a>
<a class="sourceLine" id="cb260-6" data-line-number="6">    FALSE = &amp;object.Boolean{Value: <span class="ot">false</span>}</a>
<a class="sourceLine" id="cb260-7" data-line-number="7">)</a></code></pre></div>
<p>And that’s all there is to it. Now we have one <code>NULL</code> we can reference.</p>
<p>With integer literals and our trio of <code>NULL</code>, <code>TRUE</code> and <code>FALSE</code> in place we’re ready to evaluate operator expressions.</p>
<h3 id="prefix-expressions">Prefix Expressions</h3>
<p>The simplest form of operator expressions Monkey supports is the prefix expression, or unary operator expression, where one operand follows the operator. In our parser we treated a lot of language constructs like prefix expressions, because that’s the easiest way to parse them. But in this section prefix expressions are just operator expressions with one operator and one operand. Monkey supports two of these prefix operators: <code>!</code> and <code>-</code>.</p>
<p>Evaluating operator expressions (especially with a prefix operator and one operand) isn’t hard. We’ll do it in small steps and build up the desired behaviour bit by bit. But we also need to pay close attention. What we’re about to implement has far reaching consequences. Remember: in the evaluation process the input language receives meaning; we’re defining the semantics of the Monkey programming language. A small change in the evaluation of operator expressions might cause something unintended in a part of the language that seems entirely unrelated. Tests help us to nail down the desired behaviour and also act as a specification for us.</p>
<p>We’re going to start by implementing support for the <code>!</code> operator. The tests show that the operator should “convert” its operand to a boolean value and negate it:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb261-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb261-2" data-line-number="2"></a>
<a class="sourceLine" id="cb261-3" data-line-number="3"><span class="kw">func</span> TestBangOperator(t *testing.T) {</a>
<a class="sourceLine" id="cb261-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb261-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb261-6" data-line-number="6">        expected <span class="dt">bool</span></a>
<a class="sourceLine" id="cb261-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb261-8" data-line-number="8">        {<span class="st">&quot;!true&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb261-9" data-line-number="9">        {<span class="st">&quot;!false&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb261-10" data-line-number="10">        {<span class="st">&quot;!5&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb261-11" data-line-number="11">        {<span class="st">&quot;!!true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb261-12" data-line-number="12">        {<span class="st">&quot;!!false&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb261-13" data-line-number="13">        {<span class="st">&quot;!!5&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb261-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb261-15" data-line-number="15"></a>
<a class="sourceLine" id="cb261-16" data-line-number="16">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb261-17" data-line-number="17">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb261-18" data-line-number="18">        testBooleanObject(t, evaluated, tt.expected)</a>
<a class="sourceLine" id="cb261-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb261-20" data-line-number="20">}</a></code></pre></div>
<p>As I said, this is where we decide how the language works. The <code>!true</code> and <code>!false</code> expressions and their expected results seem like common sense, but the <code>!5</code> may be something where other language designers feel an error should be returned. But what we’re saying here is that <code>5</code> acts as “truthy”.</p>
<p>The tests don’t pass, of course, because <code>Eval</code> returns <code>nil</code> instead of <code>TRUE</code> or <code>FALSE</code>. The first step to evaluating a prefix expression is to evaluate its operand and then use the result of this evaluation with the operator:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb262-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb262-2" data-line-number="2"></a>
<a class="sourceLine" id="cb262-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb262-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb262-5" data-line-number="5">    <span class="kw">case</span> *ast.PrefixExpression:</a>
<a class="sourceLine" id="cb262-6" data-line-number="6">        right := Eval(node.Right)</a>
<a class="sourceLine" id="cb262-7" data-line-number="7">        <span class="kw">return</span> evalPrefixExpression(node.Operator, right)</a>
<a class="sourceLine" id="cb262-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb262-9" data-line-number="9">}</a></code></pre></div>
<p>After the first call to <code>Eval</code> here, <code>right</code> may be an <code>*object.Integer</code> or an <code>*object.Boolean</code> or maybe even <code>NULL</code>. We then take this <code>right</code> operand and pass it to <code>evalPrefixExpression</code> which checks if the operator is supported:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb263-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb263-2" data-line-number="2"></a>
<a class="sourceLine" id="cb263-3" data-line-number="3"><span class="kw">func</span> evalPrefixExpression(operator <span class="dt">string</span>, right object.Object) object.Object {</a>
<a class="sourceLine" id="cb263-4" data-line-number="4">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb263-5" data-line-number="5">    <span class="kw">case</span> <span class="st">&quot;!&quot;</span>:</a>
<a class="sourceLine" id="cb263-6" data-line-number="6">        <span class="kw">return</span> evalBangOperatorExpression(right)</a>
<a class="sourceLine" id="cb263-7" data-line-number="7">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb263-8" data-line-number="8">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb263-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb263-10" data-line-number="10">}</a></code></pre></div>
<p>If the operator is not supported we return <code>NULL</code>. Is that the best choice? Maybe, maybe not. For now, it’s definitely the easiest choice, since we don’t have any error handling implemented yet.</p>
<p>The <code>evalBangOperatorExpression</code> function is where the behaviour of the <code>!</code> is specified:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb264-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb264-2" data-line-number="2"></a>
<a class="sourceLine" id="cb264-3" data-line-number="3"><span class="kw">func</span> evalBangOperatorExpression(right object.Object) object.Object {</a>
<a class="sourceLine" id="cb264-4" data-line-number="4">    <span class="kw">switch</span> right {</a>
<a class="sourceLine" id="cb264-5" data-line-number="5">    <span class="kw">case</span> TRUE:</a>
<a class="sourceLine" id="cb264-6" data-line-number="6">        <span class="kw">return</span> FALSE</a>
<a class="sourceLine" id="cb264-7" data-line-number="7">    <span class="kw">case</span> FALSE:</a>
<a class="sourceLine" id="cb264-8" data-line-number="8">        <span class="kw">return</span> TRUE</a>
<a class="sourceLine" id="cb264-9" data-line-number="9">    <span class="kw">case</span> NULL:</a>
<a class="sourceLine" id="cb264-10" data-line-number="10">        <span class="kw">return</span> TRUE</a>
<a class="sourceLine" id="cb264-11" data-line-number="11">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb264-12" data-line-number="12">        <span class="kw">return</span> FALSE</a>
<a class="sourceLine" id="cb264-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb264-14" data-line-number="14">}</a></code></pre></div>
<p>And with that the tests pass!</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb265-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb265-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Let’s move on to the <code>-</code> prefix operator. We can extend our <code>TestEvalIntegerExpression</code> test function to incorporate it:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb266-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb266-2" data-line-number="2"></a>
<a class="sourceLine" id="cb266-3" data-line-number="3"><span class="kw">func</span> TestEvalIntegerExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb266-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb266-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb266-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb266-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb266-8" data-line-number="8">        {<span class="st">&quot;5&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb266-9" data-line-number="9">        {<span class="st">&quot;10&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb266-10" data-line-number="10">        {<span class="st">&quot;-5&quot;</span>, <span class="dv">-5</span>},</a>
<a class="sourceLine" id="cb266-11" data-line-number="11">        {<span class="st">&quot;-10&quot;</span>, <span class="dv">-10</span>},</a>
<a class="sourceLine" id="cb266-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb266-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb266-14" data-line-number="14">}</a></code></pre></div>
<p>I choose to extend this test rather than writing a new test function solely for the <code>-</code> prefix operator for two reasons. First, integers are the only supported operands of the <code>-</code> operator in prefix position. And second, because this test function should grow to encompass all integer arithmetic in order to have one place that shows the desired behaviour in a clear and neat way.</p>
<p>We have to extend the <code>evalPrefixExpression</code> function we wrote earlier in order to make the test cases pass. A new branch in the switch statement is needed:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb267-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb267-2" data-line-number="2"></a>
<a class="sourceLine" id="cb267-3" data-line-number="3"><span class="kw">func</span> evalPrefixExpression(operator <span class="dt">string</span>, right object.Object) object.Object {</a>
<a class="sourceLine" id="cb267-4" data-line-number="4">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb267-5" data-line-number="5">    <span class="kw">case</span> <span class="st">&quot;!&quot;</span>:</a>
<a class="sourceLine" id="cb267-6" data-line-number="6">        <span class="kw">return</span> evalBangOperatorExpression(right)</a>
<a class="sourceLine" id="cb267-7" data-line-number="7">    <span class="kw">case</span> <span class="st">&quot;-&quot;</span>:</a>
<a class="sourceLine" id="cb267-8" data-line-number="8">        <span class="kw">return</span> evalMinusPrefixOperatorExpression(right)</a>
<a class="sourceLine" id="cb267-9" data-line-number="9">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb267-10" data-line-number="10">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb267-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb267-12" data-line-number="12">}</a></code></pre></div>
<p>The <code>evalMinusPrefixOperatorExpression</code> function looks like this:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb268-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb268-2" data-line-number="2"></a>
<a class="sourceLine" id="cb268-3" data-line-number="3"><span class="kw">func</span> evalMinusPrefixOperatorExpression(right object.Object) object.Object {</a>
<a class="sourceLine" id="cb268-4" data-line-number="4">    <span class="kw">if</span> right.Type() != object.INTEGER_OBJ {</a>
<a class="sourceLine" id="cb268-5" data-line-number="5">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb268-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb268-7" data-line-number="7"></a>
<a class="sourceLine" id="cb268-8" data-line-number="8">    value := right.(*object.Integer).Value</a>
<a class="sourceLine" id="cb268-9" data-line-number="9">    <span class="kw">return</span> &amp;object.Integer{Value: -value}</a>
<a class="sourceLine" id="cb268-10" data-line-number="10">}</a></code></pre></div>
<p>The first thing we do here is to check if the operand is an integer. If it isn’t, we return <code>NULL</code>. But if it is, we extract the value of the <code>*object.Integer</code>. Then we allocate a new object to wrap a negated version of this value.</p>
<p>That wasn’t a lot of code, was it? But still, it did the job:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb269-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb269-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Excellent! Now we can give our prefix expressions a spin in the REPL before moving on to their infix friends:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb270-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb270-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb270-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb270-4" data-line-number="4">&gt;&gt; -5</a>
<a class="sourceLine" id="cb270-5" data-line-number="5">-5</a>
<a class="sourceLine" id="cb270-6" data-line-number="6">&gt;&gt; !true</a>
<a class="sourceLine" id="cb270-7" data-line-number="7">false</a>
<a class="sourceLine" id="cb270-8" data-line-number="8">&gt;&gt; !-5</a>
<a class="sourceLine" id="cb270-9" data-line-number="9">false</a>
<a class="sourceLine" id="cb270-10" data-line-number="10">&gt;&gt; !!-5</a>
<a class="sourceLine" id="cb270-11" data-line-number="11">true</a>
<a class="sourceLine" id="cb270-12" data-line-number="12">&gt;&gt; !!!!-5</a>
<a class="sourceLine" id="cb270-13" data-line-number="13">true</a>
<a class="sourceLine" id="cb270-14" data-line-number="14">&gt;&gt; -true</a>
<a class="sourceLine" id="cb270-15" data-line-number="15">null</a></code></pre></div>
<p>Amazing!</p>
<h3 id="infix-expressions">Infix Expressions</h3>
<p>As a refresher, here are the eight infix operators that Monkey supports:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb271-1" data-line-number="1"><span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-2" data-line-number="2"><span class="dv">5</span> <span class="op">-</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-3" data-line-number="3"><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-4" data-line-number="4"><span class="dv">5</span> / <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-5" data-line-number="5"></a>
<a class="sourceLine" id="cb271-6" data-line-number="6"><span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-7" data-line-number="7"><span class="dv">5</span> <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-8" data-line-number="8"><span class="dv">5</span> <span class="op">==</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-9" data-line-number="9"><span class="dv">5</span> <span class="op">!=</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>These eight operators can be separated into two groups: one group of operators produces booleans as their result and one group doesn’t. We’ll start by implementing support for the second group: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. And first only in combination with integer operands. As soon as that works, we’ll add support for booleans on either side of the operator.</p>
<p>The test infrastructure is already in place. We’ll just extend our <code>TestEvalIntegerExpression</code> test function with test cases for these new operators:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb272-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb272-2" data-line-number="2"></a>
<a class="sourceLine" id="cb272-3" data-line-number="3"><span class="kw">func</span> TestEvalIntegerExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb272-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb272-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb272-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb272-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb272-8" data-line-number="8">        {<span class="st">&quot;5&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb272-9" data-line-number="9">        {<span class="st">&quot;10&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb272-10" data-line-number="10">        {<span class="st">&quot;-5&quot;</span>, <span class="dv">-5</span>},</a>
<a class="sourceLine" id="cb272-11" data-line-number="11">        {<span class="st">&quot;-10&quot;</span>, <span class="dv">-10</span>},</a>
<a class="sourceLine" id="cb272-12" data-line-number="12">        {<span class="st">&quot;5 + 5 + 5 + 5 - 10&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb272-13" data-line-number="13">        {<span class="st">&quot;2 * 2 * 2 * 2 * 2&quot;</span>, <span class="dv">32</span>},</a>
<a class="sourceLine" id="cb272-14" data-line-number="14">        {<span class="st">&quot;-50 + 100 + -50&quot;</span>, <span class="dv">0</span>},</a>
<a class="sourceLine" id="cb272-15" data-line-number="15">        {<span class="st">&quot;5 * 2 + 10&quot;</span>, <span class="dv">20</span>},</a>
<a class="sourceLine" id="cb272-16" data-line-number="16">        {<span class="st">&quot;5 + 2 * 10&quot;</span>, <span class="dv">25</span>},</a>
<a class="sourceLine" id="cb272-17" data-line-number="17">        {<span class="st">&quot;20 + 2 * -10&quot;</span>, <span class="dv">0</span>},</a>
<a class="sourceLine" id="cb272-18" data-line-number="18">        {<span class="st">&quot;50 / 2 * 2 + 10&quot;</span>, <span class="dv">60</span>},</a>
<a class="sourceLine" id="cb272-19" data-line-number="19">        {<span class="st">&quot;2 * (5 + 10)&quot;</span>, <span class="dv">30</span>},</a>
<a class="sourceLine" id="cb272-20" data-line-number="20">        {<span class="st">&quot;3 * 3 * 3 + 10&quot;</span>, <span class="dv">37</span>},</a>
<a class="sourceLine" id="cb272-21" data-line-number="21">        {<span class="st">&quot;3 * (3 * 3) + 10&quot;</span>, <span class="dv">37</span>},</a>
<a class="sourceLine" id="cb272-22" data-line-number="22">        {<span class="st">&quot;(5 + 10 * 2 + 15 / 3) * 2 + -10&quot;</span>, <span class="dv">50</span>},</a>
<a class="sourceLine" id="cb272-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb272-24" data-line-number="24"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb272-25" data-line-number="25">}</a></code></pre></div>
<p>Yes, there are probably some test cases that can be removed because they duplicate another one and some add nothing new, but to be honest: I was really trigger happy with these tests once I realized that the implementation works and I just couldn’t believe it. “It can’t be that easy, can it?” Well, yes, it can.</p>
<p>To get these test cases to pass, the first thing we need to do is to extend our switch statement in <code>Eval</code>:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb273-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb273-2" data-line-number="2"></a>
<a class="sourceLine" id="cb273-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb273-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb273-5" data-line-number="5">    <span class="kw">case</span> *ast.InfixExpression:</a>
<a class="sourceLine" id="cb273-6" data-line-number="6">        left := Eval(node.Left)</a>
<a class="sourceLine" id="cb273-7" data-line-number="7">        right := Eval(node.Right)</a>
<a class="sourceLine" id="cb273-8" data-line-number="8">        <span class="kw">return</span> evalInfixExpression(node.Operator, left, right)</a>
<a class="sourceLine" id="cb273-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb273-10" data-line-number="10">}</a></code></pre></div>
<p>Just as with <code>*ast.PrefixExpression</code> we evaluate the operands first. And now we have two: the left and the right arm of the AST node. We already know that these may be any other expression - a function call, an integer literal, an operator expression, etc. We don’t care. We let <code>Eval</code> take care of it.</p>
<p>After evaluating the operands we take the returned values and the operator and pass them to <code>evalIntegerInfixExpressions</code>, which looks like this:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb274-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb274-2" data-line-number="2"></a>
<a class="sourceLine" id="cb274-3" data-line-number="3"><span class="kw">func</span> evalInfixExpression(</a>
<a class="sourceLine" id="cb274-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb274-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb274-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb274-7" data-line-number="7">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb274-8" data-line-number="8">    <span class="kw">case</span> left.Type() == object.INTEGER_OBJ &amp;&amp; right.Type() == object.INTEGER_OBJ:</a>
<a class="sourceLine" id="cb274-9" data-line-number="9">        <span class="kw">return</span> evalIntegerInfixExpression(operator, left, right)</a>
<a class="sourceLine" id="cb274-10" data-line-number="10">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb274-11" data-line-number="11">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb274-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb274-13" data-line-number="13">}</a></code></pre></div>
<p>In case the operands aren’t both integers we return <code>NULL</code>, just as I promised. Of course, we’ll extend this function later on, but in order to get the tests to pass, this is enough. The heart of the matter lies in <code>evalIntegerInfixExpression</code>, where the values wrapped by <code>*object.Integer</code>s are added, subtracted, multiplied and divided:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb275-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb275-2" data-line-number="2"></a>
<a class="sourceLine" id="cb275-3" data-line-number="3"><span class="kw">func</span> evalIntegerInfixExpression(</a>
<a class="sourceLine" id="cb275-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb275-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb275-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb275-7" data-line-number="7">    leftVal := left.(*object.Integer).Value</a>
<a class="sourceLine" id="cb275-8" data-line-number="8">    rightVal := right.(*object.Integer).Value</a>
<a class="sourceLine" id="cb275-9" data-line-number="9"></a>
<a class="sourceLine" id="cb275-10" data-line-number="10">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb275-11" data-line-number="11">    <span class="kw">case</span> <span class="st">&quot;+&quot;</span>:</a>
<a class="sourceLine" id="cb275-12" data-line-number="12">        <span class="kw">return</span> &amp;object.Integer{Value: leftVal + rightVal}</a>
<a class="sourceLine" id="cb275-13" data-line-number="13">    <span class="kw">case</span> <span class="st">&quot;-&quot;</span>:</a>
<a class="sourceLine" id="cb275-14" data-line-number="14">        <span class="kw">return</span> &amp;object.Integer{Value: leftVal - rightVal}</a>
<a class="sourceLine" id="cb275-15" data-line-number="15">    <span class="kw">case</span> <span class="st">&quot;*&quot;</span>:</a>
<a class="sourceLine" id="cb275-16" data-line-number="16">        <span class="kw">return</span> &amp;object.Integer{Value: leftVal * rightVal}</a>
<a class="sourceLine" id="cb275-17" data-line-number="17">    <span class="kw">case</span> <span class="st">&quot;/&quot;</span>:</a>
<a class="sourceLine" id="cb275-18" data-line-number="18">        <span class="kw">return</span> &amp;object.Integer{Value: leftVal / rightVal}</a>
<a class="sourceLine" id="cb275-19" data-line-number="19">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb275-20" data-line-number="20">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb275-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb275-22" data-line-number="22">}</a></code></pre></div>
<p>And now, believe it or not, the tests pass. Yes, really, they do:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb276-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb276-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Go on, add a few more. Knock yourself out. And then come back here so we can add support for the operators that result in booleans: <code>==</code>, <code>!=</code>, <code>&lt;</code> and <code>&gt;</code>.</p>
<p>We can extend our <code>TestEvalBooleanExpression</code> test function with test cases for these operators, since they all produce a boolean:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb277-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb277-2" data-line-number="2"></a>
<a class="sourceLine" id="cb277-3" data-line-number="3"><span class="kw">func</span> TestEvalBooleanExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb277-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb277-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb277-6" data-line-number="6">        expected <span class="dt">bool</span></a>
<a class="sourceLine" id="cb277-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb277-8" data-line-number="8">        {<span class="st">&quot;true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb277-9" data-line-number="9">        {<span class="st">&quot;false&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-10" data-line-number="10">        {<span class="st">&quot;1 &lt; 2&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb277-11" data-line-number="11">        {<span class="st">&quot;1 &gt; 2&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-12" data-line-number="12">        {<span class="st">&quot;1 &lt; 1&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-13" data-line-number="13">        {<span class="st">&quot;1 &gt; 1&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-14" data-line-number="14">        {<span class="st">&quot;1 == 1&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb277-15" data-line-number="15">        {<span class="st">&quot;1 != 1&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-16" data-line-number="16">        {<span class="st">&quot;1 == 2&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb277-17" data-line-number="17">        {<span class="st">&quot;1 != 2&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb277-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb277-19" data-line-number="19"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb277-20" data-line-number="20">}</a></code></pre></div>
<p>A few added lines in <code>evalIntegerInfixExpression</code> is all that’s needed to get these tests to pass:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb278-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb278-2" data-line-number="2"></a>
<a class="sourceLine" id="cb278-3" data-line-number="3"><span class="kw">func</span> evalIntegerInfixExpression(</a>
<a class="sourceLine" id="cb278-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb278-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb278-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb278-7" data-line-number="7">    leftVal := left.(*object.Integer).Value</a>
<a class="sourceLine" id="cb278-8" data-line-number="8">    rightVal := right.(*object.Integer).Value</a>
<a class="sourceLine" id="cb278-9" data-line-number="9"></a>
<a class="sourceLine" id="cb278-10" data-line-number="10">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb278-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb278-12" data-line-number="12">    <span class="kw">case</span> <span class="st">&quot;&lt;&quot;</span>:</a>
<a class="sourceLine" id="cb278-13" data-line-number="13">        <span class="kw">return</span> nativeBoolToBooleanObject(leftVal &lt; rightVal)</a>
<a class="sourceLine" id="cb278-14" data-line-number="14">    <span class="kw">case</span> <span class="st">&quot;&gt;&quot;</span>:</a>
<a class="sourceLine" id="cb278-15" data-line-number="15">        <span class="kw">return</span> nativeBoolToBooleanObject(leftVal &gt; rightVal)</a>
<a class="sourceLine" id="cb278-16" data-line-number="16">    <span class="kw">case</span> <span class="st">&quot;==&quot;</span>:</a>
<a class="sourceLine" id="cb278-17" data-line-number="17">        <span class="kw">return</span> nativeBoolToBooleanObject(leftVal == rightVal)</a>
<a class="sourceLine" id="cb278-18" data-line-number="18">    <span class="kw">case</span> <span class="st">&quot;!=&quot;</span>:</a>
<a class="sourceLine" id="cb278-19" data-line-number="19">        <span class="kw">return</span> nativeBoolToBooleanObject(leftVal != rightVal)</a>
<a class="sourceLine" id="cb278-20" data-line-number="20">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb278-21" data-line-number="21">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb278-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb278-23" data-line-number="23">}</a></code></pre></div>
<p>The <code>nativeBoolToBooleanObject</code> function we already used for boolean literals now finds some reuse when we need to return either <code>TRUE</code> or <code>FALSE</code> based on the comparison between the unwrapped values.</p>
<p>And that’s it! Well, at least for integers. We now fully support the eight infix operators when both operands are integers. What’s left in this section is adding support for boolean operands.</p>
<p>Monkey only supports boolean operands for the equality operators <code>==</code> and <code>!=</code>. It doesn’t support adding, subtracting, dividing and multiplying booleans. Checking whether <code>true</code> is greater than <code>false</code> with <code>&lt;</code> or <code>&gt;</code> is also unsupported. That reduces our task to just adding support for two operators.</p>
<p>The first thing we have to do, as you know, is to add tests. And, as before, we can extend an existing test function. In this case, we’ll use <code>TestEvalBooleanExpression</code> and add test cases for the <code>==</code> and <code>!=</code> operators:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb279-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb279-2" data-line-number="2"></a>
<a class="sourceLine" id="cb279-3" data-line-number="3"><span class="kw">func</span> TestEvalBooleanExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb279-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb279-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb279-6" data-line-number="6">        expected <span class="dt">bool</span></a>
<a class="sourceLine" id="cb279-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb279-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb279-9" data-line-number="9">        {<span class="st">&quot;true == true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-10" data-line-number="10">        {<span class="st">&quot;false == false&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-11" data-line-number="11">        {<span class="st">&quot;true == false&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb279-12" data-line-number="12">        {<span class="st">&quot;true != false&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-13" data-line-number="13">        {<span class="st">&quot;false != true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-14" data-line-number="14">        {<span class="st">&quot;(1 &lt; 2) == true&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-15" data-line-number="15">        {<span class="st">&quot;(1 &lt; 2) == false&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb279-16" data-line-number="16">        {<span class="st">&quot;(1 &gt; 2) == true&quot;</span>, <span class="ot">false</span>},</a>
<a class="sourceLine" id="cb279-17" data-line-number="17">        {<span class="st">&quot;(1 &gt; 2) == false&quot;</span>, <span class="ot">true</span>},</a>
<a class="sourceLine" id="cb279-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb279-19" data-line-number="19"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb279-20" data-line-number="20">}</a></code></pre></div>
<p>Strictly speaking, only the first five cases are necessary to test the new and desired behaviour. But let’s throw in the other four too to check the comparison between generated booleans.</p>
<p>So far, so good. Nothing surprising here. Just another set of of failing tests:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb280-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb280-2" data-line-number="2">--- FAIL: TestEvalBooleanExpression (0.00s)</a>
<a class="sourceLine" id="cb280-3" data-line-number="3">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-4" data-line-number="4">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-5" data-line-number="5">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-6" data-line-number="6">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-7" data-line-number="7">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-8" data-line-number="8">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-9" data-line-number="9">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-10" data-line-number="10">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-11" data-line-number="11">  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb280-12" data-line-number="12">FAIL</a>
<a class="sourceLine" id="cb280-13" data-line-number="13">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>And here’s something neat to make those tests pass:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb281-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb281-2" data-line-number="2"></a>
<a class="sourceLine" id="cb281-3" data-line-number="3"><span class="kw">func</span> evalInfixExpression(</a>
<a class="sourceLine" id="cb281-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb281-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb281-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb281-7" data-line-number="7">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb281-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb281-9" data-line-number="9">    <span class="kw">case</span> operator == <span class="st">&quot;==&quot;</span>:</a>
<a class="sourceLine" id="cb281-10" data-line-number="10">        <span class="kw">return</span> nativeBoolToBooleanObject(left == right)</a>
<a class="sourceLine" id="cb281-11" data-line-number="11">    <span class="kw">case</span> operator == <span class="st">&quot;!=&quot;</span>:</a>
<a class="sourceLine" id="cb281-12" data-line-number="12">        <span class="kw">return</span> nativeBoolToBooleanObject(left != right)</a>
<a class="sourceLine" id="cb281-13" data-line-number="13">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb281-14" data-line-number="14">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb281-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb281-16" data-line-number="16">}</a></code></pre></div>
<p>Yes, that’s right. We only add four lines to our existing <code>evalInfixExpression</code> and the tests pass. We’re using pointer comparison here to check for equality between booleans. That works because we’re always using pointers to our objects and in the case of booleans we only ever use two: <code>TRUE</code> and <code>FALSE</code>. So, if something has the same value as <code>TRUE</code> (the memory address that is) then it’s true. This also works with <code>NULL</code>.</p>
<p>This doesn’t work for integers or other data types we might add later on. In the case of <code>*object.Integer</code> we’re always allocating new instances of <code>object.Integer</code> and thus use new pointers. We can’t compare these pointers to different instances, otherwise <code>5 == 5</code> would be false, which is not what we want. In this case we want to explicitly compare the values and not the objects that wrap these values.</p>
<p>That’s why the check for integer operands has to be higher up in the switch statement and match earlier than these newly added <code>case</code> branches. As long as we’re taking care of other operand types before arriving at these pointer comparisons we’re fine and it works.</p>
<p>In ten years, when Monkey is a famous programming language and the discussion about research-ignoring dilettantes designing programming languages is still ongoing and we’re both rich and famous, someone will ask on StackOverflow why integer comparison in Monkey is slower than boolean comparison. The answer will be written by either you or me and one of us will say that Monkey’s object system doesn’t allow pointer comparison for integer objects. It has to unwrap the value before a comparison can be made. Thus the comparison between booleans is faster. We’ll add a “Source: I wrote it.” to the bottom of our answer and earn an unheard of amount of karma.</p>
<p>But I digress. To get back to topic, let me just say: Wow! We did it! I know, I’m pretty lavish with my praise and can spot a cause for celebration pretty easily, but if there ever was a time to pop the champagne, it’s now. Yes, we did it. Just look at what our interpreter can do now:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb282-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb282-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb282-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb282-4" data-line-number="4">&gt;&gt; 5 * 5 + 10</a>
<a class="sourceLine" id="cb282-5" data-line-number="5">35</a>
<a class="sourceLine" id="cb282-6" data-line-number="6">&gt;&gt; 3 + 4 * 5 == 3 * 1 + 4 * 5</a>
<a class="sourceLine" id="cb282-7" data-line-number="7">true</a>
<a class="sourceLine" id="cb282-8" data-line-number="8">&gt;&gt; 5 * 10 &gt; 40 + 5</a>
<a class="sourceLine" id="cb282-9" data-line-number="9">true</a>
<a class="sourceLine" id="cb282-10" data-line-number="10">&gt;&gt; (10 + 2) * 30 == 300 + 20 * 3</a>
<a class="sourceLine" id="cb282-11" data-line-number="11">true</a>
<a class="sourceLine" id="cb282-12" data-line-number="12">&gt;&gt; (5 &gt; 5 == true) != false</a>
<a class="sourceLine" id="cb282-13" data-line-number="13">false</a>
<a class="sourceLine" id="cb282-14" data-line-number="14">&gt;&gt; 500 / 2 != 250</a>
<a class="sourceLine" id="cb282-15" data-line-number="15">false</a></code></pre></div>
<p>So, now we have a fully functional calculator that’s ready to do more. Let’s give him more. Let’s make it look more like a programming language.</p>
<h2 id="conditionals">3.6 - Conditionals</h2>
<p>You’ll be amazed how easy it is to add support for conditionals in our evaluator. The only hard thing about their implementation is deciding when to evaluate what. Because that’s the whole point of conditionals: only ever evaluate something based on a condition. Consider this:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb283-1" data-line-number="1"><span class="cf">if</span> (x <span class="op">&gt;</span> <span class="dv">10</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb283-2" data-line-number="2">  <span class="at">puts</span>(<span class="st">&quot;everything okay!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb283-3" data-line-number="3"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb283-4" data-line-number="4">  <span class="at">puts</span>(<span class="st">&quot;x is too low!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb283-5" data-line-number="5">  <span class="at">shutdownSystem</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb283-6" data-line-number="6"><span class="op">}</span></a></code></pre></div>
<p>When evaluating this if-else-expression the important thing is to only evaluate the correct branch. If the condition is met, we must never evaluate the else-branch, only the if-branch. And if it isn’t met we must only evaluate the else-branch.</p>
<p>In other words: we can only evaluate the else-branch of this conditional if the condition <code>x &gt; 10</code> is not … well, when it’s not what exactly? Should we evaluate the consequence, the <code>&quot;everything okay!&quot;</code> branch, only when the condition expression generates a <code>true</code> or when it generates something “truthy”, something that’s not false or not null?</p>
<p>And <em>that’s</em> the tough part about this, because that’s a design decision, a language design decision to be exact, with wide ranging consequences.</p>
<p>In the case of Monkey, the consequence part of the conditional will be evaluated when the condition is “truthy”. And “truthy” means: it’s not null and it’s not false. It doesn’t necessarily need to be <code>true</code>.</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb284-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb284-2" data-line-number="2"><span class="cf">if</span> (x) <span class="op">{</span></a>
<a class="sourceLine" id="cb284-3" data-line-number="3">  <span class="at">puts</span>(<span class="st">&quot;everything okay!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb284-4" data-line-number="4"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb284-5" data-line-number="5">  <span class="at">puts</span>(<span class="st">&quot;x is too high!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb284-6" data-line-number="6">  <span class="at">shutdownSystem</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb284-7" data-line-number="7"><span class="op">}</span></a></code></pre></div>
<p>In this example <code>&quot;everything okay!&quot;</code> should be printed. Why? Because <code>x</code> is bound to <code>10</code>, evaluates to <code>10</code> and <code>10</code> is not null and not false. That’s how conditionals are supposed to work in Monkey.</p>
<p>Now that we’ve talked about this, we can turn this specification into a set of test cases:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb285-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb285-2" data-line-number="2"></a>
<a class="sourceLine" id="cb285-3" data-line-number="3"><span class="kw">func</span> TestIfElseExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb285-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb285-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb285-6" data-line-number="6">        expected <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb285-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb285-8" data-line-number="8">        {<span class="st">&quot;if (true) { 10 }&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb285-9" data-line-number="9">        {<span class="st">&quot;if (false) { 10 }&quot;</span>, <span class="ot">nil</span>},</a>
<a class="sourceLine" id="cb285-10" data-line-number="10">        {<span class="st">&quot;if (1) { 10 }&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb285-11" data-line-number="11">        {<span class="st">&quot;if (1 &lt; 2) { 10 }&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb285-12" data-line-number="12">        {<span class="st">&quot;if (1 &gt; 2) { 10 }&quot;</span>, <span class="ot">nil</span>},</a>
<a class="sourceLine" id="cb285-13" data-line-number="13">        {<span class="st">&quot;if (1 &gt; 2) { 10 } else { 20 }&quot;</span>, <span class="dv">20</span>},</a>
<a class="sourceLine" id="cb285-14" data-line-number="14">        {<span class="st">&quot;if (1 &lt; 2) { 10 } else { 20 }&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb285-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb285-16" data-line-number="16"></a>
<a class="sourceLine" id="cb285-17" data-line-number="17">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb285-18" data-line-number="18">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb285-19" data-line-number="19">        integer, ok := tt.expected.(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb285-20" data-line-number="20">        <span class="kw">if</span> ok {</a>
<a class="sourceLine" id="cb285-21" data-line-number="21">            testIntegerObject(t, evaluated, <span class="dt">int64</span>(integer))</a>
<a class="sourceLine" id="cb285-22" data-line-number="22">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb285-23" data-line-number="23">            testNullObject(t, evaluated)</a>
<a class="sourceLine" id="cb285-24" data-line-number="24">        }</a>
<a class="sourceLine" id="cb285-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb285-26" data-line-number="26">}</a>
<a class="sourceLine" id="cb285-27" data-line-number="27"></a>
<a class="sourceLine" id="cb285-28" data-line-number="28"><span class="kw">func</span> testNullObject(t *testing.T, obj object.Object) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb285-29" data-line-number="29">    <span class="kw">if</span> obj != NULL {</a>
<a class="sourceLine" id="cb285-30" data-line-number="30">        t.Errorf(<span class="st">&quot;object is not NULL. got=%T (%+v)&quot;</span>, obj, obj)</a>
<a class="sourceLine" id="cb285-31" data-line-number="31">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb285-32" data-line-number="32">    }</a>
<a class="sourceLine" id="cb285-33" data-line-number="33">    <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb285-34" data-line-number="34">}</a></code></pre></div>
<p>This test function also specifies behaviour we haven’t talked about yet. When a conditional doesn’t evaluate to a value it’s supposed to return <code>NULL</code>, e.g.:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb286-1" data-line-number="1"><span class="cf">if</span> (<span class="kw">false</span>) <span class="op">{</span> <span class="dv">10</span> <span class="op">}</span></a></code></pre></div>
<p>The <code>else</code> is missing and thus the conditional should produce <code>NULL</code>.</p>
<p>We have to do a little type assertion and conversion dance to allow <code>nil</code> in our <code>expected</code> field, granted, but the tests are readable and clearly show the desired and hereby specified behaviour. They also fail, because we don’t return any <code>*object.Integer</code>s or <code>NULL</code>:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb287-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb287-2" data-line-number="2">--- FAIL: TestIfElseExpressions (0.00s)</a>
<a class="sourceLine" id="cb287-3" data-line-number="3">  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-4" data-line-number="4">  evaluator_test.go:153: object is not NULL. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-5" data-line-number="5">  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-6" data-line-number="6">  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-7" data-line-number="7">  evaluator_test.go:153: object is not NULL. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-8" data-line-number="8">  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-9" data-line-number="9">  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb287-10" data-line-number="10">FAIL</a>
<a class="sourceLine" id="cb287-11" data-line-number="11">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>Earlier I told you that you’ll be amazed at how easy it is to implement support for conditionals. Didn’t believe me? Well, look at this small amount of code necessary to make the tests pass:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb288-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb288-2" data-line-number="2"></a>
<a class="sourceLine" id="cb288-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb288-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb288-5" data-line-number="5">    <span class="kw">case</span> *ast.BlockStatement:</a>
<a class="sourceLine" id="cb288-6" data-line-number="6">        <span class="kw">return</span> evalStatements(node.Statements)</a>
<a class="sourceLine" id="cb288-7" data-line-number="7"></a>
<a class="sourceLine" id="cb288-8" data-line-number="8">    <span class="kw">case</span> *ast.IfExpression:</a>
<a class="sourceLine" id="cb288-9" data-line-number="9">        <span class="kw">return</span> evalIfExpression(node)</a>
<a class="sourceLine" id="cb288-10" data-line-number="10"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb288-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb288-12" data-line-number="12"></a>
<a class="sourceLine" id="cb288-13" data-line-number="13"><span class="kw">func</span> evalIfExpression(ie *ast.IfExpression) object.Object {</a>
<a class="sourceLine" id="cb288-14" data-line-number="14">    condition := Eval(ie.Condition)</a>
<a class="sourceLine" id="cb288-15" data-line-number="15"></a>
<a class="sourceLine" id="cb288-16" data-line-number="16">    <span class="kw">if</span> isTruthy(condition) {</a>
<a class="sourceLine" id="cb288-17" data-line-number="17">        <span class="kw">return</span> Eval(ie.Consequence)</a>
<a class="sourceLine" id="cb288-18" data-line-number="18">    } <span class="kw">else</span> <span class="kw">if</span> ie.Alternative != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb288-19" data-line-number="19">        <span class="kw">return</span> Eval(ie.Alternative)</a>
<a class="sourceLine" id="cb288-20" data-line-number="20">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb288-21" data-line-number="21">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb288-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb288-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb288-24" data-line-number="24"></a>
<a class="sourceLine" id="cb288-25" data-line-number="25"><span class="kw">func</span> isTruthy(obj object.Object) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb288-26" data-line-number="26">    <span class="kw">switch</span> obj {</a>
<a class="sourceLine" id="cb288-27" data-line-number="27">    <span class="kw">case</span> NULL:</a>
<a class="sourceLine" id="cb288-28" data-line-number="28">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb288-29" data-line-number="29">    <span class="kw">case</span> TRUE:</a>
<a class="sourceLine" id="cb288-30" data-line-number="30">        <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb288-31" data-line-number="31">    <span class="kw">case</span> FALSE:</a>
<a class="sourceLine" id="cb288-32" data-line-number="32">        <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb288-33" data-line-number="33">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb288-34" data-line-number="34">        <span class="kw">return</span> <span class="ot">true</span></a>
<a class="sourceLine" id="cb288-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb288-36" data-line-number="36">}</a></code></pre></div>
<p>As I said: the only hard thing is deciding what to evaluate. And that decision is encapsulated in <code>evalIfExpression</code> where the logic of the behaviour is pretty clear. <code>isTruthy</code> is equally expressive. Besides these two functions we also added the <code>case</code> branch for <code>*ast.BlockStatement</code> to our <code>Eval</code> switch statement, because the <code>.Consequence</code> and <code>.Alternative</code> of <code>*ast.IfExpression</code> are both block statements.</p>
<p>We added two new and concise functions that show the semantics of the Monkey programming language in a clear way, reused another function we already had in place and with doing so added support for conditionals and made the tests pass. Our interpreter now supports if-else-expressions! We’re now leaving calculator territory and heading straight towards programming language land:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb289-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb289-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb289-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb289-4" data-line-number="4">&gt;&gt; if (5 * 5 + 10 &gt; 34) { 99 } else { 100 }</a>
<a class="sourceLine" id="cb289-5" data-line-number="5">99</a>
<a class="sourceLine" id="cb289-6" data-line-number="6">&gt;&gt; if ((1000 / 2) + 250 * 2 == 1000) { 9999 }</a>
<a class="sourceLine" id="cb289-7" data-line-number="7">9999</a>
<a class="sourceLine" id="cb289-8" data-line-number="8">&gt;&gt;</a></code></pre></div>
<h2 id="return-statements">3.7 - Return Statements</h2>
<p>Now here’s something that you won’t find on your standard calculator: return statements. Monkey has them, like a lot of other languages. They can be used in the bodies of functions but also as top-level statements in a Monkey program. But it doesn’t really matter where they’re used, because how they work doesn’t change: return statements stop the evaluation of a series of statements and leave behind the value their expression has evaluated to.</p>
<p>Here is a top-level return statement in a Monkey program:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb290-1" data-line-number="1"><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb290-2" data-line-number="2"><span class="cf">return</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb290-3" data-line-number="3"><span class="dv">9</span> <span class="op">*</span> <span class="dv">9</span> <span class="op">*</span> <span class="dv">9</span><span class="op">;</span></a></code></pre></div>
<p>When evaluated this program should return <code>10</code>. If these statements were the body of a function, calling the function should evaluate to <code>10</code>. The important thing is that the last line, the <code>9 * 9 * 9</code> expression, is never going to be evaluated.</p>
<p>There are a few different ways to implement return statements. In some host languages we could use gotos or exceptions. But in Go a “rescue” or “catch” are not easy to come by and we don’t really have the option of using gotos in a clean way. That’s why, in order to support return statements, we’ll be passing a “return value” through our evaluator. Whenever we encounter a <code>return</code> we’ll wrap the value it’s supposed to return inside an object, so we can keep track of it. And we need to keep track of it so we can later decide whether to stop evaluation or not.</p>
<p>Here is the implementation of said object. Here is <code>object.ReturnValue</code>:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb291-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb291-2" data-line-number="2"></a>
<a class="sourceLine" id="cb291-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb291-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb291-5" data-line-number="5">    RETURN_VALUE_OBJ = <span class="st">&quot;RETURN_VALUE&quot;</span></a>
<a class="sourceLine" id="cb291-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb291-7" data-line-number="7"></a>
<a class="sourceLine" id="cb291-8" data-line-number="8"><span class="kw">type</span> ReturnValue <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb291-9" data-line-number="9">    Value Object</a>
<a class="sourceLine" id="cb291-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb291-11" data-line-number="11"></a>
<a class="sourceLine" id="cb291-12" data-line-number="12"><span class="kw">func</span> (rv *ReturnValue) Type() ObjectType { <span class="kw">return</span> RETURN_VALUE_OBJ }</a>
<a class="sourceLine" id="cb291-13" data-line-number="13"><span class="kw">func</span> (rv *ReturnValue) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> rv.Value.Inspect() }</a></code></pre></div>
<p>Since this is just a wrapper around another object nothing here is surprising. What’s interesting about <code>object.ReturnValue</code> is when and how it’s used.</p>
<p>Here are the tests that demonstrate what we expect of the return statement in the context of a Monkey program:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb292-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb292-2" data-line-number="2"></a>
<a class="sourceLine" id="cb292-3" data-line-number="3"><span class="kw">func</span> TestReturnStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb292-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb292-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb292-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb292-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb292-8" data-line-number="8">        {<span class="st">&quot;return 10;&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb292-9" data-line-number="9">        {<span class="st">&quot;return 10; 9;&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb292-10" data-line-number="10">        {<span class="st">&quot;return 2 * 5; 9;&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb292-11" data-line-number="11">        {<span class="st">&quot;9; return 2 * 5; 9;&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb292-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb292-13" data-line-number="13"></a>
<a class="sourceLine" id="cb292-14" data-line-number="14">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb292-15" data-line-number="15">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb292-16" data-line-number="16">        testIntegerObject(t, evaluated, tt.expected)</a>
<a class="sourceLine" id="cb292-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb292-18" data-line-number="18">}</a></code></pre></div>
<p>In order to get these tests to pass we have to change the <code>evalStatements</code> function we already have and add a <code>case</code> branch for <code>*ast.ReturnStatement</code> to <code>Eval</code>:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb293-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb293-2" data-line-number="2"></a>
<a class="sourceLine" id="cb293-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb293-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb293-5" data-line-number="5">    <span class="kw">case</span> *ast.ReturnStatement:</a>
<a class="sourceLine" id="cb293-6" data-line-number="6">        val := Eval(node.ReturnValue)</a>
<a class="sourceLine" id="cb293-7" data-line-number="7">        <span class="kw">return</span> &amp;object.ReturnValue{Value: val}</a>
<a class="sourceLine" id="cb293-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb293-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb293-10" data-line-number="10"></a>
<a class="sourceLine" id="cb293-11" data-line-number="11"><span class="kw">func</span> evalStatements(stmts []ast.Statement) object.Object {</a>
<a class="sourceLine" id="cb293-12" data-line-number="12">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb293-13" data-line-number="13"></a>
<a class="sourceLine" id="cb293-14" data-line-number="14">    <span class="kw">for</span> _, statement := <span class="kw">range</span> stmts {</a>
<a class="sourceLine" id="cb293-15" data-line-number="15">        result = Eval(statement)</a>
<a class="sourceLine" id="cb293-16" data-line-number="16"></a>
<a class="sourceLine" id="cb293-17" data-line-number="17">        <span class="kw">if</span> returnValue, ok := result.(*object.ReturnValue); ok {</a>
<a class="sourceLine" id="cb293-18" data-line-number="18">            <span class="kw">return</span> returnValue.Value</a>
<a class="sourceLine" id="cb293-19" data-line-number="19">        }</a>
<a class="sourceLine" id="cb293-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb293-21" data-line-number="21"></a>
<a class="sourceLine" id="cb293-22" data-line-number="22">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb293-23" data-line-number="23">}</a></code></pre></div>
<p>The first part of this change is the evaluation of <code>*ast.ReturnValue</code>, where we evaluate the expression associated with the return statement. We then wrap the result of this call to <code>Eval</code> in our new <code>object.ReturnValue</code> so we can keep track of it.</p>
<p>In <code>evalStatements</code>, which is used by <code>evalProgramStatements</code> and <code>evalBlockStatements</code> to evaluate a series of statements, we check if the last evaluation result is such an <code>object.ReturnValue</code> and if so, we stop the evaluation and return the unwrapped value. That’s important. We don’t return an <code>object.ReturnValue</code>, but only the value it’s wrapping, which is what the user expects to be returned.</p>
<p>There’s a problem, though. Sometimes we have to keep track of <code>object.ReturnValue</code>s for longer and can’t unwrap their values on the first encounter. That’s the case with block statements. Take a look at this:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb294-1" data-line-number="1"><span class="cf">if</span> (<span class="dv">10</span> <span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb294-2" data-line-number="2">  <span class="cf">if</span> (<span class="dv">10</span> <span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb294-3" data-line-number="3">    <span class="cf">return</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb294-4" data-line-number="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb294-5" data-line-number="5"></a>
<a class="sourceLine" id="cb294-6" data-line-number="6">  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb294-7" data-line-number="7"><span class="op">}</span></a></code></pre></div>
<p>This program should return <code>10</code>. But with our current implementation, it doesn’t and returns <code>1</code>. A small test case confirms this:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb295-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb295-2" data-line-number="2"></a>
<a class="sourceLine" id="cb295-3" data-line-number="3"><span class="kw">func</span> TestReturnStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb295-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb295-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb295-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb295-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb295-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb295-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb295-10" data-line-number="10">            <span class="st">`</span></a>
<a class="sourceLine" id="cb295-11" data-line-number="11"><span class="st">if (10 &gt; 1) {</span></a>
<a class="sourceLine" id="cb295-12" data-line-number="12"><span class="st">  if (10 &gt; 1) {</span></a>
<a class="sourceLine" id="cb295-13" data-line-number="13"><span class="st">    return 10;</span></a>
<a class="sourceLine" id="cb295-14" data-line-number="14"><span class="st">  }</span></a>
<a class="sourceLine" id="cb295-15" data-line-number="15"></a>
<a class="sourceLine" id="cb295-16" data-line-number="16"><span class="st">  return 1;</span></a>
<a class="sourceLine" id="cb295-17" data-line-number="17"><span class="st">}</span></a>
<a class="sourceLine" id="cb295-18" data-line-number="18"><span class="st">`</span>,</a>
<a class="sourceLine" id="cb295-19" data-line-number="19">            <span class="dv">10</span>,</a>
<a class="sourceLine" id="cb295-20" data-line-number="20">        },</a>
<a class="sourceLine" id="cb295-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb295-22" data-line-number="22"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb295-23" data-line-number="23">}</a></code></pre></div>
<p>This test case fails with the expected message:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb296-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb296-2" data-line-number="2">--- FAIL: TestReturnStatements (0.00s)</a>
<a class="sourceLine" id="cb296-3" data-line-number="3">  evaluator_test.go:159: object has wrong value. got=1, want=10</a>
<a class="sourceLine" id="cb296-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb296-5" data-line-number="5">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>I bet that you’ve already figured out what the problem with our current implementation is. But if you want me to spell it out, here it comes: if we have nested block statements (which is totally legit in a Monkey program!) we can’t unwrap the value of <code>object.ReturnValue</code> on first sight, because we need to further keep track of it so we can stop the execution in the outermost block statement.</p>
<p>Non-nested block statements work fine with our current implementation. But to get nested ones to work, the first thing we have to do is to accept that we can’t reuse our <code>evalStatements</code> function for evaluating block statements. That’s why we’re going to rename it to <code>evalProgram</code> and make it less generic.</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb297-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb297-2" data-line-number="2"></a>
<a class="sourceLine" id="cb297-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb297-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb297-5" data-line-number="5">    <span class="kw">case</span> *ast.Program:</a>
<a class="sourceLine" id="cb297-6" data-line-number="6">        <span class="kw">return</span> evalProgram(node)</a>
<a class="sourceLine" id="cb297-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb297-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb297-9" data-line-number="9"></a>
<a class="sourceLine" id="cb297-10" data-line-number="10"><span class="kw">func</span> evalProgram(program *ast.Program) object.Object {</a>
<a class="sourceLine" id="cb297-11" data-line-number="11">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb297-12" data-line-number="12"></a>
<a class="sourceLine" id="cb297-13" data-line-number="13">    <span class="kw">for</span> _, statement := <span class="kw">range</span> program.Statements {</a>
<a class="sourceLine" id="cb297-14" data-line-number="14">        result = Eval(statement)</a>
<a class="sourceLine" id="cb297-15" data-line-number="15"></a>
<a class="sourceLine" id="cb297-16" data-line-number="16">        <span class="kw">if</span> returnValue, ok := result.(*object.ReturnValue); ok {</a>
<a class="sourceLine" id="cb297-17" data-line-number="17">            <span class="kw">return</span> returnValue.Value</a>
<a class="sourceLine" id="cb297-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb297-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb297-20" data-line-number="20"></a>
<a class="sourceLine" id="cb297-21" data-line-number="21">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb297-22" data-line-number="22">}</a></code></pre></div>
<p>For evaluating an <code>*ast.BlockStatement</code> we introduce a new function called <code>evalBlockStatement</code>:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb298-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb298-2" data-line-number="2"></a>
<a class="sourceLine" id="cb298-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb298-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb298-5" data-line-number="5">    <span class="kw">case</span> *ast.BlockStatement:</a>
<a class="sourceLine" id="cb298-6" data-line-number="6">        <span class="kw">return</span> evalBlockStatement(node)</a>
<a class="sourceLine" id="cb298-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb298-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb298-9" data-line-number="9"></a>
<a class="sourceLine" id="cb298-10" data-line-number="10"><span class="kw">func</span> evalBlockStatement(block *ast.BlockStatement) object.Object {</a>
<a class="sourceLine" id="cb298-11" data-line-number="11">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb298-12" data-line-number="12"></a>
<a class="sourceLine" id="cb298-13" data-line-number="13">    <span class="kw">for</span> _, statement := <span class="kw">range</span> block.Statements {</a>
<a class="sourceLine" id="cb298-14" data-line-number="14">        result = Eval(statement)</a>
<a class="sourceLine" id="cb298-15" data-line-number="15"></a>
<a class="sourceLine" id="cb298-16" data-line-number="16">        <span class="kw">if</span> result != <span class="ot">nil</span> &amp;&amp; result.Type() == object.RETURN_VALUE_OBJ {</a>
<a class="sourceLine" id="cb298-17" data-line-number="17">            <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb298-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb298-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb298-20" data-line-number="20"></a>
<a class="sourceLine" id="cb298-21" data-line-number="21">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb298-22" data-line-number="22">}</a></code></pre></div>
<p>Here we explicitly don’t unwrap the return value and only check the <code>Type()</code> of each evaluation result. If it’s <code>object.RETURN_VALUE_OBJ</code> we simply return the <code>*object.ReturnValue</code>, without unwrapping its <code>.Value</code>, so it stops execution in a possible outer block statement and bubbles up to <code>evalProgram</code>, where it finally get’s unwrapped. (That last part will change when we implement the evaluation of function calls.)</p>
<p>And with that the tests pass:</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb299-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb299-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Return statements are implemented. Now we’re definitely not building a calculator anymore. And since <code>evalProgram</code> and <code>evalBlockStatement</code> are still so fresh in our mind let’s keep working on them.</p>
<h2 id="abort-abort-theres-been-a-mistake-or-error-handling">3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling</h2>
<p>Remember all the <code>NULL</code>s we were returning earlier and I said that you shouldn’t worry and we’ll come back to them? Here we are. It’s time to implement some real error handling in Monkey before it’s too late and we’d have to backpedal too much. Granted, we have to backpedal a little bit and correct previous code, but not much. We didn’t implement error handling as the first thing in our interpreter, because, and to be completely honest, I thought implementing expressions first is a lot more fun than error handling. But we’re now at a point where we need to add it, otherwise debugging and using our interpreter becomes too cumbersome in the near future.</p>
<p>First of all, let’s define what I mean with “real error handling”. It is <em>not</em> user-defined exceptions. It’s internal error handling. Errors for wrong operators, unsupported operations, and other user or internal errors that may arise during execution.</p>
<p>As for the implementation of such errors: this will probably sound weird, but the error handling is implemented in nearly the same way as handling return statements is. The reason for this similarity is easy to find: errors and return statements both stop the evaluation of a series of statements.</p>
<p>The first thing we need is an error object:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb300-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb300-2" data-line-number="2"></a>
<a class="sourceLine" id="cb300-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb300-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb300-5" data-line-number="5">    ERROR_OBJ = <span class="st">&quot;ERROR&quot;</span></a>
<a class="sourceLine" id="cb300-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb300-7" data-line-number="7"></a>
<a class="sourceLine" id="cb300-8" data-line-number="8"><span class="kw">type</span> Error <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb300-9" data-line-number="9">    Message <span class="dt">string</span></a>
<a class="sourceLine" id="cb300-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb300-11" data-line-number="11"></a>
<a class="sourceLine" id="cb300-12" data-line-number="12"><span class="kw">func</span> (e *Error) Type() ObjectType { <span class="kw">return</span> ERROR_OBJ }</a>
<a class="sourceLine" id="cb300-13" data-line-number="13"><span class="kw">func</span> (e *Error) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> <span class="st">&quot;ERROR: &quot;</span> + e.Message }</a></code></pre></div>
<p>As you can see, <code>object.Error</code> is really, really simple. It only wraps a string that serves as error message. In a production-ready interpreter we’d want to attach a stack trace to such error objects, add the line and column numbers of its origin and provide more than just a message. That’s not so hard to do, provided that line and column numbers are attached to the tokens by the lexer. Since our lexer doesn’t do that, to keep things simple, we only use an error message, which still serves us a great deal by giving us some feedback and stopping execution.</p>
<p>We will add support for errors in a few places now. Later, with increased capability of our interpreter, we’ll add more where appropriate. For now, this test function shows what we expect the error handling to do:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb301-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb301-2" data-line-number="2"></a>
<a class="sourceLine" id="cb301-3" data-line-number="3"><span class="kw">func</span> TestErrorHandling(t *testing.T) {</a>
<a class="sourceLine" id="cb301-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb301-5" data-line-number="5">        input           <span class="dt">string</span></a>
<a class="sourceLine" id="cb301-6" data-line-number="6">        expectedMessage <span class="dt">string</span></a>
<a class="sourceLine" id="cb301-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb301-8" data-line-number="8">        {</a>
<a class="sourceLine" id="cb301-9" data-line-number="9">            <span class="st">&quot;5 + true;&quot;</span>,</a>
<a class="sourceLine" id="cb301-10" data-line-number="10">            <span class="st">&quot;type mismatch: INTEGER + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-11" data-line-number="11">        },</a>
<a class="sourceLine" id="cb301-12" data-line-number="12">        {</a>
<a class="sourceLine" id="cb301-13" data-line-number="13">            <span class="st">&quot;5 + true; 5;&quot;</span>,</a>
<a class="sourceLine" id="cb301-14" data-line-number="14">            <span class="st">&quot;type mismatch: INTEGER + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-15" data-line-number="15">        },</a>
<a class="sourceLine" id="cb301-16" data-line-number="16">        {</a>
<a class="sourceLine" id="cb301-17" data-line-number="17">            <span class="st">&quot;-true&quot;</span>,</a>
<a class="sourceLine" id="cb301-18" data-line-number="18">            <span class="st">&quot;unknown operator: -BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-19" data-line-number="19">        },</a>
<a class="sourceLine" id="cb301-20" data-line-number="20">        {</a>
<a class="sourceLine" id="cb301-21" data-line-number="21">            <span class="st">&quot;true + false;&quot;</span>,</a>
<a class="sourceLine" id="cb301-22" data-line-number="22">            <span class="st">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-23" data-line-number="23">        },</a>
<a class="sourceLine" id="cb301-24" data-line-number="24">        {</a>
<a class="sourceLine" id="cb301-25" data-line-number="25">            <span class="st">&quot;5; true + false; 5&quot;</span>,</a>
<a class="sourceLine" id="cb301-26" data-line-number="26">            <span class="st">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-27" data-line-number="27">        },</a>
<a class="sourceLine" id="cb301-28" data-line-number="28">        {</a>
<a class="sourceLine" id="cb301-29" data-line-number="29">            <span class="st">&quot;if (10 &gt; 1) { true + false; }&quot;</span>,</a>
<a class="sourceLine" id="cb301-30" data-line-number="30">            <span class="st">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-31" data-line-number="31">        },</a>
<a class="sourceLine" id="cb301-32" data-line-number="32">        {</a>
<a class="sourceLine" id="cb301-33" data-line-number="33">            <span class="st">`</span></a>
<a class="sourceLine" id="cb301-34" data-line-number="34"><span class="st">if (10 &gt; 1) {</span></a>
<a class="sourceLine" id="cb301-35" data-line-number="35"><span class="st">  if (10 &gt; 1) {</span></a>
<a class="sourceLine" id="cb301-36" data-line-number="36"><span class="st">    return true + false;</span></a>
<a class="sourceLine" id="cb301-37" data-line-number="37"><span class="st">  }</span></a>
<a class="sourceLine" id="cb301-38" data-line-number="38"></a>
<a class="sourceLine" id="cb301-39" data-line-number="39"><span class="st">  return 1;</span></a>
<a class="sourceLine" id="cb301-40" data-line-number="40"><span class="st">}</span></a>
<a class="sourceLine" id="cb301-41" data-line-number="41"><span class="st">`</span>,</a>
<a class="sourceLine" id="cb301-42" data-line-number="42">            <span class="st">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</a>
<a class="sourceLine" id="cb301-43" data-line-number="43">        },</a>
<a class="sourceLine" id="cb301-44" data-line-number="44">    }</a>
<a class="sourceLine" id="cb301-45" data-line-number="45"></a>
<a class="sourceLine" id="cb301-46" data-line-number="46">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb301-47" data-line-number="47">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb301-48" data-line-number="48"></a>
<a class="sourceLine" id="cb301-49" data-line-number="49">        errObj, ok := evaluated.(*object.Error)</a>
<a class="sourceLine" id="cb301-50" data-line-number="50">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb301-51" data-line-number="51">            t.Errorf(<span class="st">&quot;no error object returned. got=%T(%+v)&quot;</span>,</a>
<a class="sourceLine" id="cb301-52" data-line-number="52">                evaluated, evaluated)</a>
<a class="sourceLine" id="cb301-53" data-line-number="53">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb301-54" data-line-number="54">        }</a>
<a class="sourceLine" id="cb301-55" data-line-number="55"></a>
<a class="sourceLine" id="cb301-56" data-line-number="56">        <span class="kw">if</span> errObj.Message != tt.expectedMessage {</a>
<a class="sourceLine" id="cb301-57" data-line-number="57">            t.Errorf(<span class="st">&quot;wrong error message. expected=%q, got=%q&quot;</span>,</a>
<a class="sourceLine" id="cb301-58" data-line-number="58">                tt.expectedMessage, errObj.Message)</a>
<a class="sourceLine" id="cb301-59" data-line-number="59">        }</a>
<a class="sourceLine" id="cb301-60" data-line-number="60">    }</a>
<a class="sourceLine" id="cb301-61" data-line-number="61">}</a></code></pre></div>
<p>When we run the tests we meet our old friend <code>NULL</code> again:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb302-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb302-2" data-line-number="2">--- FAIL: TestErrorHandling (0.00s)</a>
<a class="sourceLine" id="cb302-3" data-line-number="3">  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</a>
<a class="sourceLine" id="cb302-4" data-line-number="4">  evaluator_test.go:193: no error object returned.\</a>
<a class="sourceLine" id="cb302-5" data-line-number="5">    got=*object.Integer(&amp;{Value:5})</a>
<a class="sourceLine" id="cb302-6" data-line-number="6">  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</a>
<a class="sourceLine" id="cb302-7" data-line-number="7">  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</a>
<a class="sourceLine" id="cb302-8" data-line-number="8">  evaluator_test.go:193: no error object returned.\</a>
<a class="sourceLine" id="cb302-9" data-line-number="9">    got=*object.Integer(&amp;{Value:5})</a>
<a class="sourceLine" id="cb302-10" data-line-number="10">  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</a>
<a class="sourceLine" id="cb302-11" data-line-number="11">  evaluator_test.go:193: no error object returned.\</a>
<a class="sourceLine" id="cb302-12" data-line-number="12">    got=*object.Integer(&amp;{Value:10})</a>
<a class="sourceLine" id="cb302-13" data-line-number="13">FAIL</a>
<a class="sourceLine" id="cb302-14" data-line-number="14">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>But there are also unexpected <code>*object.Integer</code>s. That’s because these test cases actually assert two things: that errors are created for unsupported operations and that errors prevent any further evaluation. When the test fails because of an <code>*object.Integer</code> being returned, the evaluation didn’t stop correctly.</p>
<p>Creating errors and passing them around in <code>Eval</code> is easy. We just need a helper function to help us create new <code>*object.Error</code>s and return them when we think we should:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb303-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb303-2" data-line-number="2"></a>
<a class="sourceLine" id="cb303-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb303-4" data-line-number="4">    <span class="co">// [...]</span></a>
<a class="sourceLine" id="cb303-5" data-line-number="5">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb303-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb303-7" data-line-number="7"></a>
<a class="sourceLine" id="cb303-8" data-line-number="8"><span class="kw">func</span> newError(format <span class="dt">string</span>, a ...<span class="kw">interface</span>{}) *object.Error {</a>
<a class="sourceLine" id="cb303-9" data-line-number="9">    <span class="kw">return</span> &amp;object.Error{Message: fmt.Sprintf(format, a...)}</a>
<a class="sourceLine" id="cb303-10" data-line-number="10">}</a></code></pre></div>
<p>This <code>newError</code> function finds its use in every place where we didn’t know what to do before and returned <code>NULL</code> instead:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb304-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb304-2" data-line-number="2"></a>
<a class="sourceLine" id="cb304-3" data-line-number="3"><span class="kw">func</span> evalPrefixExpression(operator <span class="dt">string</span>, right object.Object) object.Object {</a>
<a class="sourceLine" id="cb304-4" data-line-number="4">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb304-5" data-line-number="5"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb304-6" data-line-number="6">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb304-7" data-line-number="7">        <span class="kw">return</span> newError(<span class="st">&quot;unknown operator: %s%s&quot;</span>, operator, right.Type())</a>
<a class="sourceLine" id="cb304-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb304-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb304-10" data-line-number="10"></a>
<a class="sourceLine" id="cb304-11" data-line-number="11"><span class="kw">func</span> evalInfixExpression(</a>
<a class="sourceLine" id="cb304-12" data-line-number="12">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb304-13" data-line-number="13">    left, right object.Object,</a>
<a class="sourceLine" id="cb304-14" data-line-number="14">) object.Object {</a>
<a class="sourceLine" id="cb304-15" data-line-number="15">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb304-16" data-line-number="16"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb304-17" data-line-number="17">    <span class="kw">case</span> left.Type() != right.Type():</a>
<a class="sourceLine" id="cb304-18" data-line-number="18">        <span class="kw">return</span> newError(<span class="st">&quot;type mismatch: %s %s %s&quot;</span>,</a>
<a class="sourceLine" id="cb304-19" data-line-number="19">            left.Type(), operator, right.Type())</a>
<a class="sourceLine" id="cb304-20" data-line-number="20">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb304-21" data-line-number="21">        <span class="kw">return</span> newError(<span class="st">&quot;unknown operator: %s %s %s&quot;</span>,</a>
<a class="sourceLine" id="cb304-22" data-line-number="22">            left.Type(), operator, right.Type())</a>
<a class="sourceLine" id="cb304-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb304-24" data-line-number="24">}</a>
<a class="sourceLine" id="cb304-25" data-line-number="25"></a>
<a class="sourceLine" id="cb304-26" data-line-number="26"><span class="kw">func</span> evalMinusPrefixOperatorExpression(right object.Object) object.Object {</a>
<a class="sourceLine" id="cb304-27" data-line-number="27">    <span class="kw">if</span> right.Type() != object.INTEGER_OBJ {</a>
<a class="sourceLine" id="cb304-28" data-line-number="28">        <span class="kw">return</span> newError(<span class="st">&quot;unknown operator: -%s&quot;</span>, right.Type())</a>
<a class="sourceLine" id="cb304-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb304-30" data-line-number="30"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb304-31" data-line-number="31">}</a>
<a class="sourceLine" id="cb304-32" data-line-number="32"></a>
<a class="sourceLine" id="cb304-33" data-line-number="33"><span class="kw">func</span> evalIntegerInfixExpression(</a>
<a class="sourceLine" id="cb304-34" data-line-number="34">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb304-35" data-line-number="35">    left, right object.Object,</a>
<a class="sourceLine" id="cb304-36" data-line-number="36">) object.Object {</a>
<a class="sourceLine" id="cb304-37" data-line-number="37"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb304-38" data-line-number="38">    <span class="kw">switch</span> operator {</a>
<a class="sourceLine" id="cb304-39" data-line-number="39"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb304-40" data-line-number="40">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb304-41" data-line-number="41">        <span class="kw">return</span> newError(<span class="st">&quot;unknown operator: %s %s %s&quot;</span>,</a>
<a class="sourceLine" id="cb304-42" data-line-number="42">            left.Type(), operator, right.Type())</a>
<a class="sourceLine" id="cb304-43" data-line-number="43">    }</a>
<a class="sourceLine" id="cb304-44" data-line-number="44">}</a></code></pre></div>
<p>With these changes made the number of failing test cases has been reduced to just two:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb305-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb305-2" data-line-number="2">--- FAIL: TestErrorHandling (0.00s)</a>
<a class="sourceLine" id="cb305-3" data-line-number="3">  evaluator_test.go:193: no error object returned.\</a>
<a class="sourceLine" id="cb305-4" data-line-number="4">    got=*object.Integer(&amp;{Value:5})</a>
<a class="sourceLine" id="cb305-5" data-line-number="5">  evaluator_test.go:193: no error object returned.\</a>
<a class="sourceLine" id="cb305-6" data-line-number="6">    got=*object.Integer(&amp;{Value:5})</a>
<a class="sourceLine" id="cb305-7" data-line-number="7">FAIL</a>
<a class="sourceLine" id="cb305-8" data-line-number="8">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>That output tells us that creating errors poses no problem but stopping the evaluation still does. We already know where to look though, don’t we? Yes, that’s right: <code>evalProgram</code> and <code>evalBlockStatement</code>. Here are both functions in their entirety, with newly added support for error handling:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb306-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb306-2" data-line-number="2"></a>
<a class="sourceLine" id="cb306-3" data-line-number="3"><span class="kw">func</span> evalProgram(program *ast.Program) object.Object {</a>
<a class="sourceLine" id="cb306-4" data-line-number="4">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb306-5" data-line-number="5"></a>
<a class="sourceLine" id="cb306-6" data-line-number="6">    <span class="kw">for</span> _, statement := <span class="kw">range</span> program.Statements {</a>
<a class="sourceLine" id="cb306-7" data-line-number="7">        result = Eval(statement)</a>
<a class="sourceLine" id="cb306-8" data-line-number="8"></a>
<a class="sourceLine" id="cb306-9" data-line-number="9">        <span class="kw">switch</span> result := result.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb306-10" data-line-number="10">        <span class="kw">case</span> *object.ReturnValue:</a>
<a class="sourceLine" id="cb306-11" data-line-number="11">            <span class="kw">return</span> result.Value</a>
<a class="sourceLine" id="cb306-12" data-line-number="12">        <span class="kw">case</span> *object.Error:</a>
<a class="sourceLine" id="cb306-13" data-line-number="13">            <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb306-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb306-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb306-16" data-line-number="16"></a>
<a class="sourceLine" id="cb306-17" data-line-number="17">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb306-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb306-19" data-line-number="19"></a>
<a class="sourceLine" id="cb306-20" data-line-number="20"><span class="kw">func</span> evalBlockStatement(block *ast.BlockStatement) object.Object {</a>
<a class="sourceLine" id="cb306-21" data-line-number="21">    <span class="kw">var</span> result object.Object</a>
<a class="sourceLine" id="cb306-22" data-line-number="22"></a>
<a class="sourceLine" id="cb306-23" data-line-number="23">    <span class="kw">for</span> _, statement := <span class="kw">range</span> block.Statements {</a>
<a class="sourceLine" id="cb306-24" data-line-number="24">        result = Eval(statement)</a>
<a class="sourceLine" id="cb306-25" data-line-number="25"></a>
<a class="sourceLine" id="cb306-26" data-line-number="26">        <span class="kw">if</span> result != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb306-27" data-line-number="27">            rt := result.Type()</a>
<a class="sourceLine" id="cb306-28" data-line-number="28">            <span class="kw">if</span> rt == object.RETURN_VALUE_OBJ || rt == object.ERROR_OBJ {</a>
<a class="sourceLine" id="cb306-29" data-line-number="29">                <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb306-30" data-line-number="30">            }</a>
<a class="sourceLine" id="cb306-31" data-line-number="31">        }</a>
<a class="sourceLine" id="cb306-32" data-line-number="32">    }</a>
<a class="sourceLine" id="cb306-33" data-line-number="33"></a>
<a class="sourceLine" id="cb306-34" data-line-number="34">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb306-35" data-line-number="35">}</a></code></pre></div>
<p>The added error handling in <code>evalProgram</code> is easy to spot. It takes slightly more effort to notice the added check for the type of <code>result</code> in <code>evalBlockStatement</code>.</p>
<p>Taken together, these changes did it. Evaluation is stopped at the right places and the tests now pass:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb307-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb307-2" data-line-number="2">ok      monkey/evaluator        0.010s</a></code></pre></div>
<p>There’s still one last thing we need to do. We need to check for errors whenever we call <code>Eval</code> inside of <code>Eval</code>, in order to stop errors from being passed around and then bubbling up far away from their origin:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb308-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb308-2" data-line-number="2"></a>
<a class="sourceLine" id="cb308-3" data-line-number="3"><span class="kw">func</span> isError(obj object.Object) <span class="dt">bool</span> {</a>
<a class="sourceLine" id="cb308-4" data-line-number="4">    <span class="kw">if</span> obj != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb308-5" data-line-number="5">        <span class="kw">return</span> obj.Type() == object.ERROR_OBJ</a>
<a class="sourceLine" id="cb308-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb308-7" data-line-number="7">    <span class="kw">return</span> <span class="ot">false</span></a>
<a class="sourceLine" id="cb308-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb308-9" data-line-number="9"></a>
<a class="sourceLine" id="cb308-10" data-line-number="10"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb308-11" data-line-number="11">    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb308-12" data-line-number="12"></a>
<a class="sourceLine" id="cb308-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb308-14" data-line-number="14">    <span class="kw">case</span> *ast.ReturnStatement:</a>
<a class="sourceLine" id="cb308-15" data-line-number="15">        val := Eval(node.ReturnValue)</a>
<a class="sourceLine" id="cb308-16" data-line-number="16">        <span class="kw">if</span> isError(val) {</a>
<a class="sourceLine" id="cb308-17" data-line-number="17">            <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb308-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb308-19" data-line-number="19">        <span class="kw">return</span> &amp;object.ReturnValue{Value: val}</a>
<a class="sourceLine" id="cb308-20" data-line-number="20"></a>
<a class="sourceLine" id="cb308-21" data-line-number="21"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb308-22" data-line-number="22">    <span class="kw">case</span> *ast.PrefixExpression:</a>
<a class="sourceLine" id="cb308-23" data-line-number="23">        right := Eval(node.Right)</a>
<a class="sourceLine" id="cb308-24" data-line-number="24">        <span class="kw">if</span> isError(right) {</a>
<a class="sourceLine" id="cb308-25" data-line-number="25">            <span class="kw">return</span> right</a>
<a class="sourceLine" id="cb308-26" data-line-number="26">        }</a>
<a class="sourceLine" id="cb308-27" data-line-number="27">        <span class="kw">return</span> evalPrefixExpression(node.Operator, right)</a>
<a class="sourceLine" id="cb308-28" data-line-number="28"></a>
<a class="sourceLine" id="cb308-29" data-line-number="29">    <span class="kw">case</span> *ast.InfixExpression:</a>
<a class="sourceLine" id="cb308-30" data-line-number="30">        left := Eval(node.Left)</a>
<a class="sourceLine" id="cb308-31" data-line-number="31">        <span class="kw">if</span> isError(left) {</a>
<a class="sourceLine" id="cb308-32" data-line-number="32">            <span class="kw">return</span> left</a>
<a class="sourceLine" id="cb308-33" data-line-number="33">        }</a>
<a class="sourceLine" id="cb308-34" data-line-number="34"></a>
<a class="sourceLine" id="cb308-35" data-line-number="35">        right := Eval(node.Right)</a>
<a class="sourceLine" id="cb308-36" data-line-number="36">        <span class="kw">if</span> isError(right) {</a>
<a class="sourceLine" id="cb308-37" data-line-number="37">            <span class="kw">return</span> right</a>
<a class="sourceLine" id="cb308-38" data-line-number="38">        }</a>
<a class="sourceLine" id="cb308-39" data-line-number="39"></a>
<a class="sourceLine" id="cb308-40" data-line-number="40">        <span class="kw">return</span> evalInfixExpression(node.Operator, left, right)</a>
<a class="sourceLine" id="cb308-41" data-line-number="41"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb308-42" data-line-number="42">}</a>
<a class="sourceLine" id="cb308-43" data-line-number="43"></a>
<a class="sourceLine" id="cb308-44" data-line-number="44"><span class="kw">func</span> evalIfExpression(ie *ast.IfExpression) object.Object {</a>
<a class="sourceLine" id="cb308-45" data-line-number="45">    condition := Eval(ie.Condition)</a>
<a class="sourceLine" id="cb308-46" data-line-number="46">    <span class="kw">if</span> isError(condition) {</a>
<a class="sourceLine" id="cb308-47" data-line-number="47">        <span class="kw">return</span> condition</a>
<a class="sourceLine" id="cb308-48" data-line-number="48">    }</a>
<a class="sourceLine" id="cb308-49" data-line-number="49"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb308-50" data-line-number="50">}</a></code></pre></div>
<p>And that’s it. Error handling is in place.</p>
<h2 id="bindings-the-environment">3.9 - Bindings &amp; The Environment</h2>
<p>Up next we’re going to add bindings to our interpreter by adding support for let statements. But not only do we need to support let statements, no, we need to support the evaluation of identifiers, too. Let’s say we have evaluated the following piece of code:</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb309-1" data-line-number="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<p>Only adding support for the evaluation of this statement is not enough. We also need to make sure that the <code>x</code> evaluates to <code>25</code> after interpreting the line above.</p>
<p>So, our task in this section is to evaluate let statements and identifiers. We evaluate let statements by evaluating their value-producing expression and keeping track of the produced value under the specified name. To evaluate identifiers we check if we already have a value bound to the name. If we do, the identifier evaluates to this value, and if we don’t, we return an error.</p>
<p>Sounds like a good plan? Alright, so let’s kick this off with a few tests:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb310-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb310-2" data-line-number="2"></a>
<a class="sourceLine" id="cb310-3" data-line-number="3"><span class="kw">func</span> TestLetStatements(t *testing.T) {</a>
<a class="sourceLine" id="cb310-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb310-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb310-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb310-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb310-8" data-line-number="8">        {<span class="st">&quot;let a = 5; a;&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb310-9" data-line-number="9">        {<span class="st">&quot;let a = 5 * 5; a;&quot;</span>, <span class="dv">25</span>},</a>
<a class="sourceLine" id="cb310-10" data-line-number="10">        {<span class="st">&quot;let a = 5; let b = a; b;&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb310-11" data-line-number="11">        {<span class="st">&quot;let a = 5; let b = a; let c = a + b + 5; c;&quot;</span>, <span class="dv">15</span>},</a>
<a class="sourceLine" id="cb310-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb310-13" data-line-number="13"></a>
<a class="sourceLine" id="cb310-14" data-line-number="14">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb310-15" data-line-number="15">        testIntegerObject(t, testEval(tt.input), tt.expected)</a>
<a class="sourceLine" id="cb310-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb310-17" data-line-number="17">}</a></code></pre></div>
<p>The test cases assert that these two things should work: evaluating the value-producing expression in a let statement and evaluating an identifier that’s bound to a name. But we also need tests to make sure that we get an error when we try to evaluate an unbound identifier. And for that we can simply extend our existing <code>TestErrorHandling</code> function:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb311-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb311-2" data-line-number="2"></a>
<a class="sourceLine" id="cb311-3" data-line-number="3"><span class="kw">func</span> TestErrorHandling(t *testing.T) {</a>
<a class="sourceLine" id="cb311-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb311-5" data-line-number="5">        input           <span class="dt">string</span></a>
<a class="sourceLine" id="cb311-6" data-line-number="6">        expectedMessage <span class="dt">string</span></a>
<a class="sourceLine" id="cb311-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb311-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb311-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb311-10" data-line-number="10">            <span class="st">&quot;foobar&quot;</span>,</a>
<a class="sourceLine" id="cb311-11" data-line-number="11">            <span class="st">&quot;identifier not found: foobar&quot;</span>,</a>
<a class="sourceLine" id="cb311-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb311-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb311-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb311-15" data-line-number="15">}</a></code></pre></div>
<p>How do we make these tests pass? Obviously the first thing we have to do is add a new <code>case</code> branch for <code>*ast.LetStatement</code> to <code>Eval</code>. And in this branch we need to <code>Eval</code> the expression of the let statement, correct? So let’s start with that:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb312-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb312-2" data-line-number="2"></a>
<a class="sourceLine" id="cb312-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node) object.Object {</a>
<a class="sourceLine" id="cb312-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb312-5" data-line-number="5">    <span class="kw">case</span> *ast.LetStatement:</a>
<a class="sourceLine" id="cb312-6" data-line-number="6">        val := Eval(node.Value)</a>
<a class="sourceLine" id="cb312-7" data-line-number="7">        <span class="kw">if</span> isError(val) {</a>
<a class="sourceLine" id="cb312-8" data-line-number="8">            <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb312-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb312-10" data-line-number="10"></a>
<a class="sourceLine" id="cb312-11" data-line-number="11">    <span class="co">// Huh? Now what?</span></a>
<a class="sourceLine" id="cb312-12" data-line-number="12"></a>
<a class="sourceLine" id="cb312-13" data-line-number="13"></a>
<a class="sourceLine" id="cb312-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb312-15" data-line-number="15">}</a></code></pre></div>
<p>The comment is right: now what? How to we keep track of values? We have the value and we have the name we should bind it too, <code>node.Name.Value</code>. How do we associate one with the other?</p>
<p>This is where something called the environment comes into play. The environment is what we use to keep track of value by associating them with a name. The name “environment” is a classic one, used in a lot of other interpreters, especially Lispy ones. But even though the name may sound sophisticated, at its heart the environment is a hash map that associates strings with objects. And that’s exactly what we’re going to use for our implementation.</p>
<p>We’ll add a new <code>Environment</code> struct to the <code>object</code> package. And yes, for now it really is just a thin wrapper around a <code>map</code>:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb313-1" data-line-number="1"><span class="co">// object/environment.go</span></a>
<a class="sourceLine" id="cb313-2" data-line-number="2"></a>
<a class="sourceLine" id="cb313-3" data-line-number="3"><span class="kw">package</span> object</a>
<a class="sourceLine" id="cb313-4" data-line-number="4"></a>
<a class="sourceLine" id="cb313-5" data-line-number="5"><span class="kw">func</span> NewEnvironment() *Environment {</a>
<a class="sourceLine" id="cb313-6" data-line-number="6">    s := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]Object)</a>
<a class="sourceLine" id="cb313-7" data-line-number="7">    <span class="kw">return</span> &amp;Environment{store: s}</a>
<a class="sourceLine" id="cb313-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb313-9" data-line-number="9"></a>
<a class="sourceLine" id="cb313-10" data-line-number="10"><span class="kw">type</span> Environment <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb313-11" data-line-number="11">    store <span class="kw">map</span>[<span class="dt">string</span>]Object</a>
<a class="sourceLine" id="cb313-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb313-13" data-line-number="13"></a>
<a class="sourceLine" id="cb313-14" data-line-number="14"><span class="kw">func</span> (e *Environment) Get(name <span class="dt">string</span>) (Object, <span class="dt">bool</span>) {</a>
<a class="sourceLine" id="cb313-15" data-line-number="15">    obj, ok := e.store[name]</a>
<a class="sourceLine" id="cb313-16" data-line-number="16">    <span class="kw">return</span> obj, ok</a>
<a class="sourceLine" id="cb313-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb313-18" data-line-number="18"></a>
<a class="sourceLine" id="cb313-19" data-line-number="19"><span class="kw">func</span> (e *Environment) Set(name <span class="dt">string</span>, val Object) Object {</a>
<a class="sourceLine" id="cb313-20" data-line-number="20">    e.store[name] = val</a>
<a class="sourceLine" id="cb313-21" data-line-number="21">    <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb313-22" data-line-number="22">}</a></code></pre></div>
<p>Let me guess what you’re thinking: <em>Why not use a map? Why the wrapper?</em> It’ll all make sense as soon as we start implementing functions and function calls in the next section, I promise. This is the groundwork we’ll build upon later.</p>
<p>As it is, the usage of <code>object.Environment</code> itself is self-explanatory. But how do we use it inside <code>Eval</code>? How and where do we keep track of the environment? We pass it around by making it a parameter of <code>Eval</code>:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb314-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb314-2" data-line-number="2"></a>
<a class="sourceLine" id="cb314-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb314-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb314-5" data-line-number="5">}</a></code></pre></div>
<p>With that change nothing compiles anymore, because we have to change every call to <code>Eval</code> make use of the environment. And not only the calls to <code>Eval</code> in <code>Eval</code> itself, but also the ones in functions such as <code>evalProgram</code>, <code>evalIfExpression</code> and so on. This requires more manual editor work than anything else, so I won’t bore you by showing the list of changes here.</p>
<p>The calls to <code>Eval</code> in our REPL and in our test suite need to use an environment too, of course. In the REPL we use a single environment:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb315-1" data-line-number="1"><span class="co">// repl/repl.go</span></a>
<a class="sourceLine" id="cb315-2" data-line-number="2"></a>
<a class="sourceLine" id="cb315-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb315-4" data-line-number="4">    <span class="co">// [...]</span></a>
<a class="sourceLine" id="cb315-5" data-line-number="5">    <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb315-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb315-7" data-line-number="7"></a>
<a class="sourceLine" id="cb315-8" data-line-number="8"><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</a>
<a class="sourceLine" id="cb315-9" data-line-number="9">    scanner := bufio.NewScanner(in)</a>
<a class="sourceLine" id="cb315-10" data-line-number="10">    env := object.NewEnvironment()</a>
<a class="sourceLine" id="cb315-11" data-line-number="11"></a>
<a class="sourceLine" id="cb315-12" data-line-number="12">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb315-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb315-14" data-line-number="14">        evaluated := evaluator.Eval(program, env)</a>
<a class="sourceLine" id="cb315-15" data-line-number="15">        <span class="kw">if</span> evaluated != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb315-16" data-line-number="16">            io.WriteString(out, evaluated.Inspect())</a>
<a class="sourceLine" id="cb315-17" data-line-number="17">            io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb315-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb315-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb315-20" data-line-number="20">}</a></code></pre></div>
<p>The environment we use here, <code>env</code>, persists between calls to <code>Eval</code>. If it didn’t, binding a value to a name in the REPL would be without any effect. As soon as the next line is evaluated, the association wouldn’t be in the new environment.</p>
<p>That’s exactly what we want in our test suite, though. We don’t want to keep state around for each test function and each test case. Each call to <code>testEval</code> should have a fresh environment so we don’t run into weird bugs involving global state caused by the order in which tests are run. Every call to <code>Eval</code> here gets a fresh environment:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb316-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb316-2" data-line-number="2"></a>
<a class="sourceLine" id="cb316-3" data-line-number="3"><span class="kw">func</span> testEval(input <span class="dt">string</span>) object.Object {</a>
<a class="sourceLine" id="cb316-4" data-line-number="4">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb316-5" data-line-number="5">    p := parser.New(l)</a>
<a class="sourceLine" id="cb316-6" data-line-number="6">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb316-7" data-line-number="7">    env := object.NewEnvironment()</a>
<a class="sourceLine" id="cb316-8" data-line-number="8"></a>
<a class="sourceLine" id="cb316-9" data-line-number="9">    <span class="kw">return</span> Eval(program, env)</a>
<a class="sourceLine" id="cb316-10" data-line-number="10">}</a></code></pre></div>
<p>With updated <code>Eval</code> calls the tests compile again and we can start making them pass, which is not too hard with <code>*object.Environment</code> available. In the <code>case</code> branch for <code>*ast.LetStatement</code> we can just use the name and value we already have and save them in the current environment:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb317-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb317-2" data-line-number="2"></a>
<a class="sourceLine" id="cb317-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb317-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb317-5" data-line-number="5">    <span class="kw">case</span> *ast.LetStatement:</a>
<a class="sourceLine" id="cb317-6" data-line-number="6">        val := Eval(node.Value, env)</a>
<a class="sourceLine" id="cb317-7" data-line-number="7">        <span class="kw">if</span> isError(val) {</a>
<a class="sourceLine" id="cb317-8" data-line-number="8">            <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb317-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb317-10" data-line-number="10">        env.Set(node.Name.Value, val)</a>
<a class="sourceLine" id="cb317-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb317-12" data-line-number="12">}</a></code></pre></div>
<p>Now we’re adding associations to the environment when evaluating let statements. But we also need to get these values out when we’re evaluating identifiers. Doing that is pretty easy, too:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb318-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb318-2" data-line-number="2"></a>
<a class="sourceLine" id="cb318-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb318-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb318-5" data-line-number="5">    <span class="kw">case</span> *ast.Identifier:</a>
<a class="sourceLine" id="cb318-6" data-line-number="6">        <span class="kw">return</span> evalIdentifier(node, env)</a>
<a class="sourceLine" id="cb318-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb318-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb318-9" data-line-number="9"></a>
<a class="sourceLine" id="cb318-10" data-line-number="10"><span class="kw">func</span> evalIdentifier(</a>
<a class="sourceLine" id="cb318-11" data-line-number="11">    node *ast.Identifier,</a>
<a class="sourceLine" id="cb318-12" data-line-number="12">    env *object.Environment,</a>
<a class="sourceLine" id="cb318-13" data-line-number="13">) object.Object {</a>
<a class="sourceLine" id="cb318-14" data-line-number="14">    val, ok := env.Get(node.Value)</a>
<a class="sourceLine" id="cb318-15" data-line-number="15">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb318-16" data-line-number="16">        <span class="kw">return</span> newError(<span class="st">&quot;identifier not found: &quot;</span> + node.Value)</a>
<a class="sourceLine" id="cb318-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb318-18" data-line-number="18"></a>
<a class="sourceLine" id="cb318-19" data-line-number="19">    <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb318-20" data-line-number="20">}</a></code></pre></div>
<p><code>evalIdentifier</code> will be extended in the next section. For now it simply checks if a value has been associated with the given name in the current environment. If that’s the case it returns the value, otherwise an error.</p>
<p>Look at this:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb319-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb319-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Yes, you’re right, that’s exactly what this means: we’re now firmly standing in programming language land.</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb320-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb320-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb320-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb320-4" data-line-number="4">&gt;&gt; let a = 5;</a>
<a class="sourceLine" id="cb320-5" data-line-number="5">&gt;&gt; let b = a &gt; 3;</a>
<a class="sourceLine" id="cb320-6" data-line-number="6">&gt;&gt; let c = a * 99;</a>
<a class="sourceLine" id="cb320-7" data-line-number="7">&gt;&gt; if (b) { 10 } else { 1 };</a>
<a class="sourceLine" id="cb320-8" data-line-number="8">10</a>
<a class="sourceLine" id="cb320-9" data-line-number="9">&gt;&gt; let d = if (c &gt; a) { 99 } else { 100 };</a>
<a class="sourceLine" id="cb320-10" data-line-number="10">&gt;&gt; d</a>
<a class="sourceLine" id="cb320-11" data-line-number="11">99</a>
<a class="sourceLine" id="cb320-12" data-line-number="12">&gt;&gt; d * c * a;</a>
<a class="sourceLine" id="cb320-13" data-line-number="13">245025</a></code></pre></div>
<h2 id="functions-function-calls">3.10 - Functions &amp; Function Calls</h2>
<p>This is what we’ve been working towards. This is the third act. We’re going to add support for functions and function calls to our interpreter. When we’re done with this section, we’ll be able to do this in our REPL:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb321-1" data-line-number="1">&gt;&gt; let add = fn(a, b, c, d) { return a + b + c + d };</a>
<a class="sourceLine" id="cb321-2" data-line-number="2">&gt;&gt; add(1, 2, 3, 4);</a>
<a class="sourceLine" id="cb321-3" data-line-number="3">10</a>
<a class="sourceLine" id="cb321-4" data-line-number="4">&gt;&gt; let addThree = fn(x) { return x + 3 };</a>
<a class="sourceLine" id="cb321-5" data-line-number="5">&gt;&gt; addThree(3);</a>
<a class="sourceLine" id="cb321-6" data-line-number="6">6</a>
<a class="sourceLine" id="cb321-7" data-line-number="7">&gt;&gt; let max = fn(x, y) { if (x &gt; y) { x } else { y } };</a>
<a class="sourceLine" id="cb321-8" data-line-number="8">&gt;&gt; max(5, 10)</a>
<a class="sourceLine" id="cb321-9" data-line-number="9">10</a>
<a class="sourceLine" id="cb321-10" data-line-number="10">&gt;&gt; let factorial = fn(n) { if (n == 0) { 1 } else { n * factorial(n - 1) } };</a>
<a class="sourceLine" id="cb321-11" data-line-number="11">&gt;&gt; factorial(5)</a>
<a class="sourceLine" id="cb321-12" data-line-number="12">120</a></code></pre></div>
<p>If that doesn’t impress you then take a look at this. Passing around functions, higher-order functions and closures will also work:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb322-1" data-line-number="1">&gt;&gt; let callTwoTimes = fn(x, func) { func(func(x)) };</a>
<a class="sourceLine" id="cb322-2" data-line-number="2">&gt;&gt; callTwoTimes(3, addThree);</a>
<a class="sourceLine" id="cb322-3" data-line-number="3">9</a>
<a class="sourceLine" id="cb322-4" data-line-number="4">&gt;&gt; callTwoTimes(3, fn(x) { x + 1 });</a>
<a class="sourceLine" id="cb322-5" data-line-number="5">5</a>
<a class="sourceLine" id="cb322-6" data-line-number="6">&gt;&gt; let newAdder = fn(x) { fn(n) { x + n } };</a>
<a class="sourceLine" id="cb322-7" data-line-number="7">&gt;&gt; let addTwo = newAdder(2);</a>
<a class="sourceLine" id="cb322-8" data-line-number="8">&gt;&gt; addTwo(2);</a>
<a class="sourceLine" id="cb322-9" data-line-number="9">4</a></code></pre></div>
<p>Yes, that’s right, we will be able to do all of <em>that</em>.</p>
<p>In order to get from where we currently are to <em>there</em> we need to do two things: define an internal representation of functions in our object system and add support for function calls to <code>Eval</code>.</p>
<p>But don’t worry. It’s easy. The work we did in the last sections now pays off. We can reuse and extend a lot of things we already built. You’ll see that a lot of things just start to fit together at a certain point in this section.</p>
<p>Since “one step at a time” brought us here there’s no reason to abandon this strategy now. The first step is to take care of the internal representation of functions.</p>
<p>The need to represent functions internally comes from the fact that functions in Monkey are treated like any other value: we can bind them to names, use them in expressions, pass them to other functions, return them from functions and so on. And like other values, functions need a representation in our object system, so we can pass around, assign and return them.</p>
<p>But how do we represent a function internally, as an object? Our definition of <code>ast.FunctionLiteral</code> gives us a starting point:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb323-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb323-2" data-line-number="2"></a>
<a class="sourceLine" id="cb323-3" data-line-number="3"><span class="kw">type</span> FunctionLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb323-4" data-line-number="4">    Token      token.Token <span class="co">// The &#39;fn&#39; token</span></a>
<a class="sourceLine" id="cb323-5" data-line-number="5">    Parameters []*Identifier</a>
<a class="sourceLine" id="cb323-6" data-line-number="6">    Body       *BlockStatement</a>
<a class="sourceLine" id="cb323-7" data-line-number="7">}</a></code></pre></div>
<p>We don’t need the <code>Token</code> field in a function object, but <code>Parameters</code> and <code>Body</code> make sense. We can’t evaluate a function without its body and we can’t evaluate the body if we don’t know which parameters the function has. Besides <code>Parameters</code> and <code>Body</code> we also need a third field in our new function object:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb324-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb324-2" data-line-number="2"></a>
<a class="sourceLine" id="cb324-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb324-4" data-line-number="4">    <span class="st">&quot;bytes&quot;</span></a>
<a class="sourceLine" id="cb324-5" data-line-number="5">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb324-6" data-line-number="6">    <span class="st">&quot;monkey/ast&quot;</span></a>
<a class="sourceLine" id="cb324-7" data-line-number="7">    <span class="st">&quot;strings&quot;</span></a>
<a class="sourceLine" id="cb324-8" data-line-number="8">)</a>
<a class="sourceLine" id="cb324-9" data-line-number="9"></a>
<a class="sourceLine" id="cb324-10" data-line-number="10"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb324-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb324-12" data-line-number="12">    FUNCTION_OBJ = <span class="st">&quot;FUNCTION&quot;</span></a>
<a class="sourceLine" id="cb324-13" data-line-number="13">)</a>
<a class="sourceLine" id="cb324-14" data-line-number="14"></a>
<a class="sourceLine" id="cb324-15" data-line-number="15"><span class="kw">type</span> Function <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb324-16" data-line-number="16">    Parameters []*ast.Identifier</a>
<a class="sourceLine" id="cb324-17" data-line-number="17">    Body       *ast.BlockStatement</a>
<a class="sourceLine" id="cb324-18" data-line-number="18">    Env        *Environment</a>
<a class="sourceLine" id="cb324-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb324-20" data-line-number="20"></a>
<a class="sourceLine" id="cb324-21" data-line-number="21"><span class="kw">func</span> (f *Function) Type() ObjectType { <span class="kw">return</span> FUNCTION_OBJ }</a>
<a class="sourceLine" id="cb324-22" data-line-number="22"><span class="kw">func</span> (f *Function) Inspect() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb324-23" data-line-number="23">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb324-24" data-line-number="24"></a>
<a class="sourceLine" id="cb324-25" data-line-number="25">    params := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb324-26" data-line-number="26">    <span class="kw">for</span> _, p := <span class="kw">range</span> f.Parameters {</a>
<a class="sourceLine" id="cb324-27" data-line-number="27">        params = <span class="bu">append</span>(params, p.String())</a>
<a class="sourceLine" id="cb324-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb324-29" data-line-number="29"></a>
<a class="sourceLine" id="cb324-30" data-line-number="30">    out.WriteString(<span class="st">&quot;fn&quot;</span>)</a>
<a class="sourceLine" id="cb324-31" data-line-number="31">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb324-32" data-line-number="32">    out.WriteString(strings.Join(params, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb324-33" data-line-number="33">    out.WriteString(<span class="st">&quot;) {</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb324-34" data-line-number="34">    out.WriteString(f.Body.String())</a>
<a class="sourceLine" id="cb324-35" data-line-number="35">    out.WriteString(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">}&quot;</span>)</a>
<a class="sourceLine" id="cb324-36" data-line-number="36"></a>
<a class="sourceLine" id="cb324-37" data-line-number="37">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb324-38" data-line-number="38">}</a></code></pre></div>
<p>This definition of <code>object.Function</code> has the <code>Parameters</code> and <code>Body</code> fields. But it also has <code>Env</code>, a field that holds a pointer to an <code>object.Environment</code>, because functions in Monkey carry their own environment with them. That allows for closures, which “close over” the environment they’re defined in and can later access it. That will make more sense when we start using the <code>Env</code> field. You’ll see.</p>
<p>With that definition done, we can now write a test to assert that our interpreter knows how to build functions:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb325-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb325-2" data-line-number="2"></a>
<a class="sourceLine" id="cb325-3" data-line-number="3"><span class="kw">func</span> TestFunctionObject(t *testing.T) {</a>
<a class="sourceLine" id="cb325-4" data-line-number="4">    input := <span class="st">&quot;fn(x) { x + 2; };&quot;</span></a>
<a class="sourceLine" id="cb325-5" data-line-number="5"></a>
<a class="sourceLine" id="cb325-6" data-line-number="6">    evaluated := testEval(input)</a>
<a class="sourceLine" id="cb325-7" data-line-number="7">    fn, ok := evaluated.(*object.Function)</a>
<a class="sourceLine" id="cb325-8" data-line-number="8">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb325-9" data-line-number="9">        t.Fatalf(<span class="st">&quot;object is not Function. got=%T (%+v)&quot;</span>, evaluated, evaluated)</a>
<a class="sourceLine" id="cb325-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb325-11" data-line-number="11"></a>
<a class="sourceLine" id="cb325-12" data-line-number="12">    <span class="kw">if</span> <span class="bu">len</span>(fn.Parameters) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb325-13" data-line-number="13">        t.Fatalf(<span class="st">&quot;function has wrong parameters. Parameters=%+v&quot;</span>,</a>
<a class="sourceLine" id="cb325-14" data-line-number="14">            fn.Parameters)</a>
<a class="sourceLine" id="cb325-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb325-16" data-line-number="16"></a>
<a class="sourceLine" id="cb325-17" data-line-number="17">    <span class="kw">if</span> fn.Parameters[<span class="dv">0</span>].String() != <span class="st">&quot;x&quot;</span> {</a>
<a class="sourceLine" id="cb325-18" data-line-number="18">        t.Fatalf(<span class="st">&quot;parameter is not &#39;x&#39;. got=%q&quot;</span>, fn.Parameters[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb325-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb325-20" data-line-number="20"></a>
<a class="sourceLine" id="cb325-21" data-line-number="21">    expectedBody := <span class="st">&quot;(x + 2)&quot;</span></a>
<a class="sourceLine" id="cb325-22" data-line-number="22"></a>
<a class="sourceLine" id="cb325-23" data-line-number="23">    <span class="kw">if</span> fn.Body.String() != expectedBody {</a>
<a class="sourceLine" id="cb325-24" data-line-number="24">        t.Fatalf(<span class="st">&quot;body is not %q. got=%q&quot;</span>, expectedBody, fn.Body.String())</a>
<a class="sourceLine" id="cb325-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb325-26" data-line-number="26">}</a></code></pre></div>
<p>This test function asserts that evaluating a function literal results in the correct <code>*object.Function</code> being returned, with correct parameters and the correct body. The function’s environment will be tested later on in other tests, implicitly. Making this test pass takes just a few lines of code added to <code>Eval</code> in the form of a new <code>case</code> branch:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb326-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb326-2" data-line-number="2"></a>
<a class="sourceLine" id="cb326-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb326-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb326-5" data-line-number="5">    <span class="kw">case</span> *ast.FunctionLiteral:</a>
<a class="sourceLine" id="cb326-6" data-line-number="6">        params := node.Parameters</a>
<a class="sourceLine" id="cb326-7" data-line-number="7">        body := node.Body</a>
<a class="sourceLine" id="cb326-8" data-line-number="8">        <span class="kw">return</span> &amp;object.Function{Parameters: params, Env: env, Body: body}</a>
<a class="sourceLine" id="cb326-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb326-10" data-line-number="10">}</a></code></pre></div>
<p>Easy, right? The test passes. We just reuse the <code>Parameters</code> and <code>Body</code> fields of the AST node. Notice how we use the current environment when building the function object.</p>
<p>With that relatively low-level test passing and thus having made sure that we build the internal representation of functions correctly, we can turn to the topic of function application. That means, extending our interpreter so that we can call functions. The tests for this are much more readable and easier to write:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb327-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb327-2" data-line-number="2"></a>
<a class="sourceLine" id="cb327-3" data-line-number="3"><span class="kw">func</span> TestFunctionApplication(t *testing.T) {</a>
<a class="sourceLine" id="cb327-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb327-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb327-6" data-line-number="6">        expected <span class="dt">int64</span></a>
<a class="sourceLine" id="cb327-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb327-8" data-line-number="8">        {<span class="st">&quot;let identity = fn(x) { x; }; identity(5);&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb327-9" data-line-number="9">        {<span class="st">&quot;let identity = fn(x) { return x; }; identity(5);&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb327-10" data-line-number="10">        {<span class="st">&quot;let double = fn(x) { x * 2; }; double(5);&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb327-11" data-line-number="11">        {<span class="st">&quot;let add = fn(x, y) { x + y; }; add(5, 5);&quot;</span>, <span class="dv">10</span>},</a>
<a class="sourceLine" id="cb327-12" data-line-number="12">        {<span class="st">&quot;let add = fn(x, y) { x + y; }; add(5 + 5, add(5, 5));&quot;</span>, <span class="dv">20</span>},</a>
<a class="sourceLine" id="cb327-13" data-line-number="13">        {<span class="st">&quot;fn(x) { x; }(5)&quot;</span>, <span class="dv">5</span>},</a>
<a class="sourceLine" id="cb327-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb327-15" data-line-number="15"></a>
<a class="sourceLine" id="cb327-16" data-line-number="16">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb327-17" data-line-number="17">        testIntegerObject(t, testEval(tt.input), tt.expected)</a>
<a class="sourceLine" id="cb327-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb327-19" data-line-number="19">}</a></code></pre></div>
<p>Each test case here does the same thing: define a function, apply it to arguments and then make an assertion about the produced value. But with their slight differences they test multiple important things: returning values implicitly, returning values using <code>return</code> statements, using parameters in expressions, multiple parameters and evaluating arguments before passing them to the function.</p>
<p>We are also testing two possible forms of <code>*ast.CallExpression</code> here. One where the function is an identifier that evaluates to a function object, and the second one where the function is a function literal. The neat thing is that it doesn’t really matter. We already know how to evaluate identifiers and function literals:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb328-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb328-2" data-line-number="2"></a>
<a class="sourceLine" id="cb328-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb328-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb328-5" data-line-number="5">    <span class="kw">case</span> *ast.CallExpression:</a>
<a class="sourceLine" id="cb328-6" data-line-number="6">        function := Eval(node.Function, env)</a>
<a class="sourceLine" id="cb328-7" data-line-number="7">        <span class="kw">if</span> isError(function) {</a>
<a class="sourceLine" id="cb328-8" data-line-number="8">            <span class="kw">return</span> function</a>
<a class="sourceLine" id="cb328-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb328-10" data-line-number="10"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb328-11" data-line-number="11">}</a></code></pre></div>
<p>Yes, we’re just using <code>Eval</code> to get the function we want to call. Whether that’s an <code>*ast.Identifier</code> or an <code>*ast.FunctionLiteral</code>: <code>Eval</code> returns an <code>*object.Function</code> (if there’s no error, of course).</p>
<p>But how do we do call this <code>*object.Function</code>? The first step is to evaluate the arguments of a call expression. The reason is simple:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb329-1" data-line-number="1"><span class="kw">let</span> add <span class="op">=</span> <span class="at">fn</span>(x<span class="op">,</span> y) <span class="op">{</span> x <span class="op">+</span> y <span class="op">};</span></a>
<a class="sourceLine" id="cb329-2" data-line-number="2"><span class="at">add</span>(<span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">5</span>)<span class="op">;</span></a></code></pre></div>
<p>Here we want to pass <code>4</code> and <code>10</code> to the <code>add</code> function as arguments and not the expressions <code>2 + 2</code> and <code>5 + 5</code>.</p>
<p>Evaluating the arguments is nothing more than evaluating a list of expressions and keeping track of the produced values. But we also have to stop the evaluation process as soon as it encounters an error. That leads us to this code:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb330-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb330-2" data-line-number="2"></a>
<a class="sourceLine" id="cb330-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb330-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb330-5" data-line-number="5">    <span class="kw">case</span> *ast.CallExpression:</a>
<a class="sourceLine" id="cb330-6" data-line-number="6">        function := Eval(node.Function, env)</a>
<a class="sourceLine" id="cb330-7" data-line-number="7">        <span class="kw">if</span> isError(function) {</a>
<a class="sourceLine" id="cb330-8" data-line-number="8">            <span class="kw">return</span> function</a>
<a class="sourceLine" id="cb330-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb330-10" data-line-number="10">        args := evalExpressions(node.Arguments, env)</a>
<a class="sourceLine" id="cb330-11" data-line-number="11">        <span class="kw">if</span> <span class="bu">len</span>(args) == <span class="dv">1</span> &amp;&amp; isError(args[<span class="dv">0</span>]) {</a>
<a class="sourceLine" id="cb330-12" data-line-number="12">            <span class="kw">return</span> args[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb330-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb330-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb330-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb330-16" data-line-number="16"></a>
<a class="sourceLine" id="cb330-17" data-line-number="17"><span class="kw">func</span> evalExpressions(</a>
<a class="sourceLine" id="cb330-18" data-line-number="18">    exps []ast.Expression,</a>
<a class="sourceLine" id="cb330-19" data-line-number="19">    env *object.Environment,</a>
<a class="sourceLine" id="cb330-20" data-line-number="20">) []object.Object {</a>
<a class="sourceLine" id="cb330-21" data-line-number="21">    <span class="kw">var</span> result []object.Object</a>
<a class="sourceLine" id="cb330-22" data-line-number="22"></a>
<a class="sourceLine" id="cb330-23" data-line-number="23">    <span class="kw">for</span> _, e := <span class="kw">range</span> exps {</a>
<a class="sourceLine" id="cb330-24" data-line-number="24">        evaluated := Eval(e, env)</a>
<a class="sourceLine" id="cb330-25" data-line-number="25">        <span class="kw">if</span> isError(evaluated) {</a>
<a class="sourceLine" id="cb330-26" data-line-number="26">            <span class="kw">return</span> []object.Object{evaluated}</a>
<a class="sourceLine" id="cb330-27" data-line-number="27">        }</a>
<a class="sourceLine" id="cb330-28" data-line-number="28">        result = <span class="bu">append</span>(result, evaluated)</a>
<a class="sourceLine" id="cb330-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb330-30" data-line-number="30"></a>
<a class="sourceLine" id="cb330-31" data-line-number="31">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb330-32" data-line-number="32">}</a></code></pre></div>
<p>Nothing fancy going on here. We just iterate over a list of <code>ast.Expression</code>s and evaluate them in the context of the current environment. If we encounter an error, we stop the evaluation and return the error. This is also the part where we decided to evaluate the arguments from left-to-right. Hopefully we won’t be writing code in Monkey that makes assertions about the order of argument evaluation, but if we do, we’re on the conservative and safe side of programming language design.</p>
<p>So! Now that we have both the function and the list of evaluated arguments, how do we “call the function”? How do we apply the function to the arguments?</p>
<p>The obvious answer is that we have to evaluate the body of the function, which is just a block statement. We already know how to evaluate those, so why not just call <code>Eval</code> and pass it the body of the function? One word: arguments. The body of the function can contain references to the parameters of the function and just evaluating the body in the current environment would result in references to unknown names, which would lead to errors, which is not what we want. Evaluating the body as it is, in the current environment, does not work.</p>
<p>What we need to do instead is change the environment in which the function is evaluated, so that the references to parameters in the function’s body resolve to the correct arguments. But we can’t just add these arguments to the current environment. That could lead to previous bindings being overwritten, which is not what we want. We want this to work:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb331-1" data-line-number="1"><span class="kw">let</span> i <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb331-2" data-line-number="2"><span class="kw">let</span> printNum <span class="op">=</span> <span class="at">fn</span>(i) <span class="op">{</span></a>
<a class="sourceLine" id="cb331-3" data-line-number="3">  <span class="at">puts</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb331-4" data-line-number="4"><span class="op">};</span></a>
<a class="sourceLine" id="cb331-5" data-line-number="5"></a>
<a class="sourceLine" id="cb331-6" data-line-number="6"><span class="at">printNum</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb331-7" data-line-number="7"><span class="at">puts</span>(i)<span class="op">;</span></a></code></pre></div>
<p>With a <code>puts</code> function that prints lines, this should print two lines, containing <code>10</code> and <code>5</code> respectively. If we were to overwrite the current environment before evaluating the body of <code>printNum</code>, the last line would also result in <code>10</code> being printed.</p>
<p>So adding the arguments of the function call to the current environment in order to make them accessible in the function’s body does not work. What we need to do instead is to preserve previous bindings while at the same time making new ones available - we’ll call that “extending the environment”.</p>
<p>Extending the environment means that we create a new instance of <code>object.Environment</code> with a pointer to the environment it should extend. By doing that we enclose a fresh and empty environment with an existing one.</p>
<p>When the new environment’s <code>Get</code> method is called and it itself doesn’t have a value associated with the given name, it calls the <code>Get</code> of the enclosing environment. That’s the environment it’s extending. And if that enclosing environment can’t find the value, it calls its own enclosing environment and so on until there is no enclosing environment anymore and we can safely say that we have an “ERROR: unknown identifier: foobar”.</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb332-1" data-line-number="1"><span class="co">// object/environment.go</span></a>
<a class="sourceLine" id="cb332-2" data-line-number="2"></a>
<a class="sourceLine" id="cb332-3" data-line-number="3"><span class="kw">package</span> object</a>
<a class="sourceLine" id="cb332-4" data-line-number="4"></a>
<a class="sourceLine" id="cb332-5" data-line-number="5"><span class="kw">func</span> NewEnclosedEnvironment(outer *Environment) *Environment {</a>
<a class="sourceLine" id="cb332-6" data-line-number="6">    env := NewEnvironment()</a>
<a class="sourceLine" id="cb332-7" data-line-number="7">    env.outer = outer</a>
<a class="sourceLine" id="cb332-8" data-line-number="8">    <span class="kw">return</span> env</a>
<a class="sourceLine" id="cb332-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb332-10" data-line-number="10"></a>
<a class="sourceLine" id="cb332-11" data-line-number="11"><span class="kw">func</span> NewEnvironment() *Environment {</a>
<a class="sourceLine" id="cb332-12" data-line-number="12">    s := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]Object)</a>
<a class="sourceLine" id="cb332-13" data-line-number="13">    <span class="kw">return</span> &amp;Environment{store: s, outer: <span class="ot">nil</span>}</a>
<a class="sourceLine" id="cb332-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb332-15" data-line-number="15"></a>
<a class="sourceLine" id="cb332-16" data-line-number="16"><span class="kw">type</span> Environment <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb332-17" data-line-number="17">    store <span class="kw">map</span>[<span class="dt">string</span>]Object</a>
<a class="sourceLine" id="cb332-18" data-line-number="18">    outer *Environment</a>
<a class="sourceLine" id="cb332-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb332-20" data-line-number="20"></a>
<a class="sourceLine" id="cb332-21" data-line-number="21"><span class="kw">func</span> (e *Environment) Get(name <span class="dt">string</span>) (Object, <span class="dt">bool</span>) {</a>
<a class="sourceLine" id="cb332-22" data-line-number="22">    obj, ok := e.store[name]</a>
<a class="sourceLine" id="cb332-23" data-line-number="23">    <span class="kw">if</span> !ok &amp;&amp; e.outer != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb332-24" data-line-number="24">        obj, ok = e.outer.Get(name)</a>
<a class="sourceLine" id="cb332-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb332-26" data-line-number="26">    <span class="kw">return</span> obj, ok</a>
<a class="sourceLine" id="cb332-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb332-28" data-line-number="28"></a>
<a class="sourceLine" id="cb332-29" data-line-number="29"><span class="kw">func</span> (e *Environment) Set(name <span class="dt">string</span>, val Object) Object {</a>
<a class="sourceLine" id="cb332-30" data-line-number="30">    e.store[name] = val</a>
<a class="sourceLine" id="cb332-31" data-line-number="31">    <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb332-32" data-line-number="32">}</a></code></pre></div>
<p><code>object.Environment</code> now has a new field called <code>outer</code> that can contain a reference to another <code>object.Environment</code>, which is the enclosing environment, the one it’s extending. The <code>NewEnclosedEnvironment</code> function makes creating such an enclosed environment easy. The <code>Get</code> method has also been changed. It now checks the enclosing environment for the given name, too.</p>
<p>This new behaviour mirrors how we think about variable scopes. There are an inner scope and an outer scope. If something is not found in the inner scope, it’s looked up in the outer scope. The outer scope <em>encloses</em> the inner scope. And the inner scope <em>extends</em> the outer one.</p>
<p>With our updated <code>object.Environment</code> functionality we can correctly evaluate function bodies. Remember, the problem was this: possibly overwriting existing bindings in a environment when binding the arguments of a function call to the parameter names of the function. Now, instead of overwriting bindings, we create a new environment that’s enclosed by the current environment and add our bindings to this fresh and empty environment.</p>
<p>But we won’t use the current environment as the enclosing environment, no. Instead we’ll use the environment our <code>*object.Function</code> carries around. Remember that one? That’s the environment our function was defined in.</p>
<p>Here is the updated version of <code>Eval</code> that handles function calls completely and correctly:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb333-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb333-2" data-line-number="2"></a>
<a class="sourceLine" id="cb333-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb333-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb333-5" data-line-number="5">    <span class="kw">case</span> *ast.CallExpression:</a>
<a class="sourceLine" id="cb333-6" data-line-number="6">        function := Eval(node.Function, env)</a>
<a class="sourceLine" id="cb333-7" data-line-number="7">        <span class="kw">if</span> isError(function) {</a>
<a class="sourceLine" id="cb333-8" data-line-number="8">            <span class="kw">return</span> function</a>
<a class="sourceLine" id="cb333-9" data-line-number="9">        }</a>
<a class="sourceLine" id="cb333-10" data-line-number="10">        args := evalExpressions(node.Arguments, env)</a>
<a class="sourceLine" id="cb333-11" data-line-number="11">        <span class="kw">if</span> <span class="bu">len</span>(args) == <span class="dv">1</span> &amp;&amp; isError(args[<span class="dv">0</span>]) {</a>
<a class="sourceLine" id="cb333-12" data-line-number="12">            <span class="kw">return</span> args[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb333-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb333-14" data-line-number="14"></a>
<a class="sourceLine" id="cb333-15" data-line-number="15">        <span class="kw">return</span> applyFunction(function, args)</a>
<a class="sourceLine" id="cb333-16" data-line-number="16"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb333-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb333-18" data-line-number="18"></a>
<a class="sourceLine" id="cb333-19" data-line-number="19"><span class="kw">func</span> applyFunction(fn object.Object, args []object.Object) object.Object {</a>
<a class="sourceLine" id="cb333-20" data-line-number="20">    function, ok := fn.(*object.Function)</a>
<a class="sourceLine" id="cb333-21" data-line-number="21">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb333-22" data-line-number="22">        <span class="kw">return</span> newError(<span class="st">&quot;not a function: %s&quot;</span>, fn.Type())</a>
<a class="sourceLine" id="cb333-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb333-24" data-line-number="24"></a>
<a class="sourceLine" id="cb333-25" data-line-number="25">    extendedEnv := extendFunctionEnv(function, args)</a>
<a class="sourceLine" id="cb333-26" data-line-number="26">    evaluated := Eval(function.Body, extendedEnv)</a>
<a class="sourceLine" id="cb333-27" data-line-number="27">    <span class="kw">return</span> unwrapReturnValue(evaluated)</a>
<a class="sourceLine" id="cb333-28" data-line-number="28">}</a>
<a class="sourceLine" id="cb333-29" data-line-number="29"></a>
<a class="sourceLine" id="cb333-30" data-line-number="30"><span class="kw">func</span> extendFunctionEnv(</a>
<a class="sourceLine" id="cb333-31" data-line-number="31">    fn *object.Function,</a>
<a class="sourceLine" id="cb333-32" data-line-number="32">    args []object.Object,</a>
<a class="sourceLine" id="cb333-33" data-line-number="33">) *object.Environment {</a>
<a class="sourceLine" id="cb333-34" data-line-number="34">    env := object.NewEnclosedEnvironment(fn.Env)</a>
<a class="sourceLine" id="cb333-35" data-line-number="35"></a>
<a class="sourceLine" id="cb333-36" data-line-number="36">    <span class="kw">for</span> paramIdx, param := <span class="kw">range</span> fn.Parameters {</a>
<a class="sourceLine" id="cb333-37" data-line-number="37">        env.Set(param.Value, args[paramIdx])</a>
<a class="sourceLine" id="cb333-38" data-line-number="38">    }</a>
<a class="sourceLine" id="cb333-39" data-line-number="39"></a>
<a class="sourceLine" id="cb333-40" data-line-number="40">    <span class="kw">return</span> env</a>
<a class="sourceLine" id="cb333-41" data-line-number="41">}</a>
<a class="sourceLine" id="cb333-42" data-line-number="42"></a>
<a class="sourceLine" id="cb333-43" data-line-number="43"><span class="kw">func</span> unwrapReturnValue(obj object.Object) object.Object {</a>
<a class="sourceLine" id="cb333-44" data-line-number="44">    <span class="kw">if</span> returnValue, ok := obj.(*object.ReturnValue); ok {</a>
<a class="sourceLine" id="cb333-45" data-line-number="45">        <span class="kw">return</span> returnValue.Value</a>
<a class="sourceLine" id="cb333-46" data-line-number="46">    }</a>
<a class="sourceLine" id="cb333-47" data-line-number="47"></a>
<a class="sourceLine" id="cb333-48" data-line-number="48">    <span class="kw">return</span> obj</a>
<a class="sourceLine" id="cb333-49" data-line-number="49">}</a></code></pre></div>
<p>In the new <code>applyFunction</code> function we not only check that we really have a <code>*object.Function</code> at hand but also convert the <code>fn</code> parameter to a <code>*object.Function</code> reference in order to get access to the function’s <code>.Env</code> and <code>.Body</code> fields (which <code>object.Object</code> doesn’t define).</p>
<p>The <code>extendFunctionEnv</code> function creates a new <code>*object.Environment</code> that’s enclosed by the function’s environment. In this new, enclosed environment it binds the arguments of the function call to the function’s parameter names.</p>
<p>And this newly enclosed and updated environment is then the environment in which the function’s body is evaluated. The result of this evaluation is unwrapped if it’s an <code>*object.ReturnValue</code>. That’s necessary, because otherwise a <code>return</code> statement would bubble up through several functions and stop the evaluation in all of them. But we only want to stop the evaluation of the last called function’s body. That’s why we need unwrap it, so that <code>evalBlockStatement</code> won’t stop evaluating statements in “outer” functions. I also added a few test cases to our previous <code>TestReturnStatements</code> function to make sure that this works.</p>
<p>Those were the last missing pieces. <em>What? Really?</em> Yeah! Take a look a this:</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb334-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb334-2" data-line-number="2">ok      monkey/evaluator        0.007s</a>
<a class="sourceLine" id="cb334-3" data-line-number="3">$ go run main.go</a>
<a class="sourceLine" id="cb334-4" data-line-number="4">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb334-5" data-line-number="5">Feel free to type in commands</a>
<a class="sourceLine" id="cb334-6" data-line-number="6">&gt;&gt; let addTwo = fn(x) { x + 2; };</a>
<a class="sourceLine" id="cb334-7" data-line-number="7">&gt;&gt; addTwo(2)</a>
<a class="sourceLine" id="cb334-8" data-line-number="8">4</a>
<a class="sourceLine" id="cb334-9" data-line-number="9">&gt;&gt; let multiply = fn(x, y) { x * y };</a>
<a class="sourceLine" id="cb334-10" data-line-number="10">&gt;&gt; multiply(50 / 2, 1 * 2)</a>
<a class="sourceLine" id="cb334-11" data-line-number="11">50</a>
<a class="sourceLine" id="cb334-12" data-line-number="12">&gt;&gt; fn(x) { x == 10 }(5)</a>
<a class="sourceLine" id="cb334-13" data-line-number="13">false</a>
<a class="sourceLine" id="cb334-14" data-line-number="14">&gt;&gt; fn(x) { x == 10 }(10)</a>
<a class="sourceLine" id="cb334-15" data-line-number="15">true</a></code></pre></div>
<p><em>Whaaat?</em> Yes! It works! We can now finally define and call functions! There’s a saying that goes “this is nothing to write home about”. Well, this is! But before we put on our party hats, it’s worth taking a closer look at the interaction between functions and their environment and what it means for function application. Because what we’ve seen is not all we can do, there is a lot more.</p>
<p>So, I bet that one question still bugs you: “Why extend the function’s environment and not the current environment?” The short answer is this:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb335-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb335-2" data-line-number="2"></a>
<a class="sourceLine" id="cb335-3" data-line-number="3"><span class="kw">func</span> TestClosures(t *testing.T) {</a>
<a class="sourceLine" id="cb335-4" data-line-number="4">    input := <span class="st">`</span></a>
<a class="sourceLine" id="cb335-5" data-line-number="5"><span class="st">let newAdder = fn(x) {</span></a>
<a class="sourceLine" id="cb335-6" data-line-number="6"><span class="st">  fn(y) { x + y };</span></a>
<a class="sourceLine" id="cb335-7" data-line-number="7"><span class="st">};</span></a>
<a class="sourceLine" id="cb335-8" data-line-number="8"></a>
<a class="sourceLine" id="cb335-9" data-line-number="9"><span class="st">let addTwo = newAdder(2);</span></a>
<a class="sourceLine" id="cb335-10" data-line-number="10"><span class="st">addTwo(2);`</span></a>
<a class="sourceLine" id="cb335-11" data-line-number="11"></a>
<a class="sourceLine" id="cb335-12" data-line-number="12">    testIntegerObject(t, testEval(input), <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb335-13" data-line-number="13">}</a></code></pre></div>
<p>This test passes. Yes, really:</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb336-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb336-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb336-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb336-4" data-line-number="4">&gt;&gt; let newAdder = fn(x) { fn(y) { x + y } };</a>
<a class="sourceLine" id="cb336-5" data-line-number="5">&gt;&gt; let addTwo = newAdder(2);</a>
<a class="sourceLine" id="cb336-6" data-line-number="6">&gt;&gt; addTwo(3);</a>
<a class="sourceLine" id="cb336-7" data-line-number="7">5</a>
<a class="sourceLine" id="cb336-8" data-line-number="8">&gt;&gt; let addThree = newAdder(3);</a>
<a class="sourceLine" id="cb336-9" data-line-number="9">&gt;&gt; addThree(10);</a>
<a class="sourceLine" id="cb336-10" data-line-number="10">13</a></code></pre></div>
<p>Monkey has closures and they already work in our interpreter. How cool is that? Exactly. Very cool. But the connection between closures and the original question might not be so clear yet. Closures are functions that “close over” the environment they were defined in. They carry their own environment around and whenever they’re called they can access it.</p>
<p>The two important lines from the example above are these:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb337-1" data-line-number="1"><span class="kw">let</span> newAdder <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span> <span class="at">fn</span>(y) <span class="op">{</span> x <span class="op">+</span> y <span class="op">}</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb337-2" data-line-number="2"><span class="kw">let</span> addTwo <span class="op">=</span> <span class="at">newAdder</span>(<span class="dv">2</span>)<span class="op">;</span></a></code></pre></div>
<p><code>newAdder</code> here is a higher-order function. Higher-order functions are functions that either return other functions or receive them as arguments. In this case <code>newAdder</code> returns another function. But not just any function: a closure. <code>addTwo</code> is bound to the closure that’s returned when calling <code>newAdder</code> with <code>2</code> as the sole argument.</p>
<p>And what makes <code>addTwo</code> a closure? The bindings it has access to when called.</p>
<p>When <code>addTwo</code> is called it not only has access to the arguments of the call, the <code>y</code> parameter, but it can also reach the value <code>x</code> was bound to at the time of the <code>newAdder(2)</code> call, even though that binding is long out of scope and not existent in the current environment anymore:</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb338-1" data-line-number="1">&gt;&gt; let newAdder = fn(x) { fn(y) { x + y } };</a>
<a class="sourceLine" id="cb338-2" data-line-number="2">&gt;&gt; let addTwo = newAdder(2);</a>
<a class="sourceLine" id="cb338-3" data-line-number="3">&gt;&gt; x</a>
<a class="sourceLine" id="cb338-4" data-line-number="4">ERROR: identifier not found: x</a></code></pre></div>
<p><code>x</code> is not bound to a value in our top-level environment. But <code>addTwo</code> still has access to it:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb339-1" data-line-number="1">&gt;&gt; addTwo(3);</a>
<a class="sourceLine" id="cb339-2" data-line-number="2">5</a></code></pre></div>
<p>In other words: the closure <code>addTwo</code> still has access to the environment that was the current environment at the time of its definition. Which is when the last line of <code>newAdder</code>’s body was evaluated. This last line is a function literal. Remember: when function literals are evaluated we build an <code>object.Function</code> and keep a reference to the current environment in its <code>.Env</code> field.</p>
<p>When we later on evaluate the body of <code>addTwo</code>, we don’t evaluate it in the current environment, but instead in the function’s environment. And we do that by extending the function’s environment and passing it to <code>Eval</code> instead of the current environment. Why? So it can still access it. Why? So we can use closures. Why? Because they’re freaking amazing and I love them!</p>
<p>And since we’re talking about amazing things, it’s worth mentioning that we not only support returning functions from other functions but also accepting functions as arguments in a function call. Yes, functions are first-class citizens in Monkey and we can pass them around like any other value:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb340-1" data-line-number="1">&gt;&gt; let add = fn(a, b) { a + b };</a>
<a class="sourceLine" id="cb340-2" data-line-number="2">&gt;&gt; let sub = fn(a, b) { a - b };</a>
<a class="sourceLine" id="cb340-3" data-line-number="3">&gt;&gt; let applyFunc = fn(a, b, func) { func(a, b) };</a>
<a class="sourceLine" id="cb340-4" data-line-number="4">&gt;&gt; applyFunc(2, 2, add);</a>
<a class="sourceLine" id="cb340-5" data-line-number="5">4</a>
<a class="sourceLine" id="cb340-6" data-line-number="6">&gt;&gt; applyFunc(10, 2, sub);</a>
<a class="sourceLine" id="cb340-7" data-line-number="7">8</a></code></pre></div>
<p>Here we pass the <code>add</code> and <code>sub</code> functions as arguments to <code>applyFunc</code>. <code>applyFunc</code> then calls this function without any problems: the <code>func</code> parameter resolves to the function object which then gets called with two arguments. There is not much more to it, everything works already in our interpreter.</p>
<p>I know what you’re thinking right now and here is a template for the message you want to send:</p>
<p><strong>Dear NAME_OF_FRIEND, remember when I said that someday I’ll be someone and do something great people will remember me for? Well, today’s the day. My Monkey interpreter works and it supports functions, higher-order functions, closures and integers and arithmetic and long story short: I’ve never been happier in my life!</strong></p>
<p>We did it. We built a fully working Monkey interpreter that supports functions and function calls, higher-order functions and closures. Go on, celebrate! I’ll be waiting here.</p>
<h2 id="whos-taking-the-trash-out">3.11 - Who’s taking the trash out?</h2>
<p>At the beginning of this book I promised you that we wouldn’t take any shortcuts and build a fully functional interpreter with our own hands, from scratch and without any third party tools. And we did! But now I have a small confession to make.</p>
<p>Consider what happens when we run this snippet of Monkey code in our interpreter:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb341-1" data-line-number="1"><span class="kw">let</span> counter <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span></a>
<a class="sourceLine" id="cb341-2" data-line-number="2">  <span class="cf">if</span> (x <span class="op">&gt;</span> <span class="dv">100</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb341-3" data-line-number="3">    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb341-4" data-line-number="4">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb341-5" data-line-number="5">    <span class="kw">let</span> foobar <span class="op">=</span> <span class="dv">9999</span><span class="op">;</span></a>
<a class="sourceLine" id="cb341-6" data-line-number="6">    <span class="at">counter</span>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb341-7" data-line-number="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb341-8" data-line-number="8"><span class="op">};</span></a>
<a class="sourceLine" id="cb341-9" data-line-number="9"></a>
<a class="sourceLine" id="cb341-10" data-line-number="10"><span class="at">counter</span>(<span class="dv">0</span>)<span class="op">;</span></a></code></pre></div>
<p>Obviously, it would return ‘true’ after evaluating the body of <code>counter</code> 101 times. But a lot is happening until the last of these recursive calls to <code>counter</code> returns.</p>
<p>The first thing is the evaluation if-else-expression condition: <code>x &gt; 100</code>. If the produced value is not truthy, the alternative of the if-else-expression gets evaluated. In the alternative the integer literal <code>9999</code> gets bound to the name <code>foobar</code>, which is never referenced again. Then <code>x + 1</code> is evaluated. The result of that call to <code>Eval</code> is then passed to another call to <code>counter</code>. And then it all starts again, until <code>x &gt; 100</code> evaluates to <code>TRUE</code>.</p>
<p>The point is this: in each call to <code>counter</code> a lot of objects are allocated. Or to put it in terms of our <code>Eval</code> function and our object system: each evaluation of <code>counter</code>’s body results in a lot of <code>object.Integer</code> being allocated and instantiated. The unused <code>9999</code> integer literal and the result of <code>x + 1</code> are obvious. But even the literals <code>100</code> and <code>1</code> produce new <code>object.Integer</code>s every time the body of <code>counter</code> is evaluated.</p>
<p>If we were to modify our <code>Eval</code> function to track every instance of <code>&amp;object.Integer{}</code>, we’d see that running this small snippet of code results in around 400 allocated <code>object.Integer</code>s.</p>
<p>What’s the problem with that?</p>
<p>Our objects are stored in memory. The more objects we use the more memory we need. And even though the number of objects in the example is tiny compared to other programs memory is not infinite.</p>
<p>With each call to <code>counter</code> the memory usage of our interpreter process should rise until it eventually runs out of memory and the operating system kills it. But if we were to monitor memory usage while running the snippet above, we’d see that it doesn’t steadily rise and never goes down. Instead it increases and decreases. Why?</p>
<p>The answer to that question is the heart of the confession I have to make: we’re reusing Go’s garbage collector as a garbage collector for our guest language. We do not need to write our own.</p>
<p>Go’s garbage collector (GC) is the reason why we don’t run out of memory. It manages memory for us. Even when we call the <code>counter</code> function from above many, many times and thus add a lot more unused integer literals and object allocations, we won’t run out of memory. Because the GC keeps track of which <code>object.Integer</code> are still reachable by us and which are not. When it notices that an object is not reachable anymore it makes the object’s memory available again.</p>
<p>The example above generates a lot of integer objects that are unreachable after a call to <code>counter</code>: the literals <code>1</code> and <code>100</code> and the nonsense <code>9999</code> bound to <code>foobar</code>. There is no way to access these objects after <code>counter</code> returns. In the case of <code>1</code> and <code>100</code> it’s clear that they’re unreachable, since they’re not bound to a name. But even the <code>9999</code> bound to <code>foobar</code> is unreachable since <code>foobar</code> is out of scope when the function returns. The environment that was constructed for the evaluation of <code>counter</code>’s body gets destroyed (also by Go’s GC, mind you!) and with it the <code>foobar</code> binding.</p>
<p>These unreachable objects are useless and take up memory. That’s why the GC collects them and frees up the memory they used.</p>
<p>And that’s super handy for us! That saves us a lot of work! If we were to write our interpreter in a language like C, where we don’t have a GC, we’d need to implement one ourselves to manage memory for users of the interpreter.</p>
<p>What would such a hypothetical GC need to do? In short: keep track of object allocations and references to objects, make enough memory available for future object allocations and give memory back when it’s not needed anymore. This last point is what garbage collection is all about. Without it the programs would “leak” and finally run out of memory.</p>
<p>There are a myriad ways to accomplish all of the above, involving different algorithms and implementations. For example, there’s the basic “mark and sweep” algorithm. In order to implement it one has to decide whether the GC will be a generational GC or not, or whether it’s a stop-the-world GC or a concurrent GC, or how it’s organizing memory and handling memory fragmentation. Having decided all of that an efficient implementation is still a lot of hard work.</p>
<p>But maybe you’re asking yourself: <em>Okay, so we have the GC of Go available. But can’t we just write our own GC for the guest language and use that one instead?</em></p>
<p>Unfortunately, no. We’d have to disable Go’s GC and find a way to take over all of its duties. That’s easier said than done. It’s a huge undertaking since we would also have to take care of allocating and freeing memory ourselves - in a language that per default prohibits exactly that.</p>
<p>That’s why I decided to not add a “Let’s write our own GC next to Go’s GC” section to this book and to instead reuse Go’s GC. Garbage collection itself is a huge topic and adding the dimension of working around an existing GC blows it out of the scope of this book. But still, I hope that this section gave you a rough idea of what a GC does and which problems it solves. Maybe you even know now what to do if you were to translate the interpreter we built here into another host language without garbage collection.</p>
<p>And with that… we’re done! Our interpreter works. All that’s left for us is to extend it and make it more useful by adding more data types and functions.</p>
<h1 id="extending-the-interpreter">Extending the Interpreter</h1>
<h2 id="data-types-functions">4.1 - Data Types &amp; Functions</h2>
<p>Even though our interpreter works amazingly well and has some mind-blowing features, like first-class functions and closures, the only data types we had available as users of Monkey were integers and booleans. That’s not especially useful and a lot less than what we’re used to from other programming languages. In this chapter we’re going to change that. We’re going to add new data types to our interpreter.</p>
<p>The great thing about this endeavor is that it takes us through the whole interpreter again. We will add new token types, modify the lexer, extend the parser and finally add support for the data types to our evaluator and the object system.</p>
<p>Even better is that the data types we’re going to add are already present in Go. That means that we only need to make them available in Monkey. We don’t need to implement them from scratch, which is pretty handy, since this book isn’t called “Implementing Common Data Structures In Go” and we can concentrate on our interpreter.</p>
<p>In addition to that we’re also going to make the interpreter much more powerful by adding some new functions. Of course, as users of our interpreter we could define functions ourselves just fine, but those were limited in what they could do. These new ones, called built-in functions, will be much more powerful, since they have access to the inner workings of the Monkey programming language.</p>
<p>The first thing we’re going to do is add a data type we all know: the string. Nearly every programming language has it and Monkey shall have it too.</p>
<h2 id="strings">4.2 - Strings</h2>
<p>In Monkey strings are a sequence of characters. They are first-class values, can be bound to identifiers, used as arguments in functions calls and be returned by functions. They look just like the strings in many other programming languages: characters enclosed by double quotes.</p>
<p>Besides the data type itself, in this section we’ll also add support for string concatenation by supporting the infix operator <code>+</code> for strings.</p>
<p>At the end, we’ll be able to do this:</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb342-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb342-2" data-line-number="2">Hello mrnugget! This is micro, your own programming language!</a>
<a class="sourceLine" id="cb342-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb342-4" data-line-number="4">&gt;&gt; let firstName = &quot;Thorsten&quot;;</a>
<a class="sourceLine" id="cb342-5" data-line-number="5">&gt;&gt; let lastName = &quot;Ball&quot;;</a>
<a class="sourceLine" id="cb342-6" data-line-number="6">&gt;&gt; let fullName = fn(first, last) { first + &quot; &quot; + last };</a>
<a class="sourceLine" id="cb342-7" data-line-number="7">&gt;&gt; fullName(firstName, lastName);</a>
<a class="sourceLine" id="cb342-8" data-line-number="8">Thorsten Ball</a></code></pre></div>
<h3 id="supporting-strings-in-our-lexer">Supporting Strings in our Lexer</h3>
<p>The first thing we have to do is add support for string literals to our lexer. The basic structure of strings is this:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb343-1" data-line-number="1">&quot;&lt;sequence of characters&gt;&quot;</a></code></pre></div>
<p>That’s not too hard, right? A sequence of characters enclosed by double quotes.</p>
<p>What we want from our lexer is a single token for each string literal. So in the case of <code>&quot;Hello World&quot;</code> we want a single token, instead of tokens for <code>&quot;</code>, <code>Hello</code>, <code>World</code> and <code>&quot;</code>. A single token for string literals makes handling them in our parser a lot easier and we move the bulk of the work to one small method in the lexer.</p>
<p>Of course, the approach using multiple tokens is also valid and maybe beneficial in some cases/parsers. We could use <code>&quot;</code> surrounding <code>token.IDENT</code> tokens. But in our case, we’ll mirror the <code>token.INT</code> integer tokens we already have and carry the string literal itself around in the <code>.Literal</code> field of the token.</p>
<p>And with that being clear, it’s time to work on our tokens and our lexer again. We haven’t touched those since the first chapter, but I’m sure we’ll do just fine.</p>
<p>The first thing we need to do is add a new <code>STRING</code> token type to our <code>token</code> package:</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb344-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb344-2" data-line-number="2"></a>
<a class="sourceLine" id="cb344-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb344-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb344-5" data-line-number="5">    STRING = <span class="st">&quot;STRING&quot;</span></a>
<a class="sourceLine" id="cb344-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb344-7" data-line-number="7">)</a></code></pre></div>
<p>With that in place we can add a test case for our lexer to see if strings are properly supported. To do that we just extend the <code>input</code> in our <code>TestNextToken</code> test function:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb345-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb345-2" data-line-number="2"></a>
<a class="sourceLine" id="cb345-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb345-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb345-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb345-6" data-line-number="6"></a>
<a class="sourceLine" id="cb345-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb345-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb345-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb345-10" data-line-number="10"></a>
<a class="sourceLine" id="cb345-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb345-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb345-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb345-14" data-line-number="14"></a>
<a class="sourceLine" id="cb345-15" data-line-number="15"><span class="st">if (5 &lt; 10) {</span></a>
<a class="sourceLine" id="cb345-16" data-line-number="16"><span class="st">    return true;</span></a>
<a class="sourceLine" id="cb345-17" data-line-number="17"><span class="st">} else {</span></a>
<a class="sourceLine" id="cb345-18" data-line-number="18"><span class="st">    return false;</span></a>
<a class="sourceLine" id="cb345-19" data-line-number="19"><span class="st">}</span></a>
<a class="sourceLine" id="cb345-20" data-line-number="20"></a>
<a class="sourceLine" id="cb345-21" data-line-number="21"><span class="st">10 == 10;</span></a>
<a class="sourceLine" id="cb345-22" data-line-number="22"><span class="st">10 != 9;</span></a>
<a class="sourceLine" id="cb345-23" data-line-number="23"><span class="st">&quot;foobar&quot;</span></a>
<a class="sourceLine" id="cb345-24" data-line-number="24"><span class="st">&quot;foo bar&quot;</span></a>
<a class="sourceLine" id="cb345-25" data-line-number="25"><span class="st">`</span></a>
<a class="sourceLine" id="cb345-26" data-line-number="26"></a>
<a class="sourceLine" id="cb345-27" data-line-number="27">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb345-28" data-line-number="28">        expectedType    token.TokenType</a>
<a class="sourceLine" id="cb345-29" data-line-number="29">        expectedLiteral <span class="dt">string</span></a>
<a class="sourceLine" id="cb345-30" data-line-number="30">    }{</a>
<a class="sourceLine" id="cb345-31" data-line-number="31"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb345-32" data-line-number="32">        {token.STRING, <span class="st">&quot;foobar&quot;</span>},</a>
<a class="sourceLine" id="cb345-33" data-line-number="33">        {token.STRING, <span class="st">&quot;foo bar&quot;</span>},</a>
<a class="sourceLine" id="cb345-34" data-line-number="34">        {token.EOF, <span class="st">&quot;&quot;</span>},</a>
<a class="sourceLine" id="cb345-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb345-36" data-line-number="36"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb345-37" data-line-number="37">}</a></code></pre></div>
<p>The <code>input</code> now has two more lines containing the string literals we want to turn into tokens. There’s <code>&quot;foobar&quot;</code> to make sure that lexing of string literals works and <code>&quot;foo bar&quot;</code> to make sure that it still works even with whitespace inside a literal.</p>
<p>Of course, the tests fail, because we haven’t changed anything in the <code>Lexer</code> yet:</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb346-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb346-2" data-line-number="2">--- FAIL: TestNextToken (0.00s)</a>
<a class="sourceLine" id="cb346-3" data-line-number="3">  lexer_test.go:122: tests[73] - tokentype wrong. expected=&quot;STRING&quot;,\</a>
<a class="sourceLine" id="cb346-4" data-line-number="4">    got=&quot;ILLEGAL&quot;</a>
<a class="sourceLine" id="cb346-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb346-6" data-line-number="6">FAIL    monkey/lexer    0.006s</a></code></pre></div>
<p>Fixing the tests is easier than you might think. All we need to do is add a <code>case</code> branch for <code>&quot;</code> to the switch statement in our <code>Lexer</code> and add a small helper method:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb347-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb347-2" data-line-number="2"></a>
<a class="sourceLine" id="cb347-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb347-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb347-5" data-line-number="5"></a>
<a class="sourceLine" id="cb347-6" data-line-number="6">    <span class="kw">switch</span> l.ch {</a>
<a class="sourceLine" id="cb347-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb347-8" data-line-number="8">    <span class="kw">case</span> <span class="ch">&#39;&quot;&#39;</span>:</a>
<a class="sourceLine" id="cb347-9" data-line-number="9">        tok.Type = token.STRING</a>
<a class="sourceLine" id="cb347-10" data-line-number="10">        tok.Literal = l.readString()</a>
<a class="sourceLine" id="cb347-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb347-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb347-13" data-line-number="13"></a>
<a class="sourceLine" id="cb347-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb347-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb347-16" data-line-number="16"></a>
<a class="sourceLine" id="cb347-17" data-line-number="17"><span class="kw">func</span> (l *Lexer) readString() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb347-18" data-line-number="18">    position := l.position + <span class="dv">1</span></a>
<a class="sourceLine" id="cb347-19" data-line-number="19">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb347-20" data-line-number="20">        l.readChar()</a>
<a class="sourceLine" id="cb347-21" data-line-number="21">        <span class="kw">if</span> l.ch == <span class="ch">&#39;&quot;&#39;</span> || l.ch == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb347-22" data-line-number="22">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb347-23" data-line-number="23">        }</a>
<a class="sourceLine" id="cb347-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb347-25" data-line-number="25">    <span class="kw">return</span> l.input[position:l.position]</a>
<a class="sourceLine" id="cb347-26" data-line-number="26">}</a></code></pre></div>
<p>There’s really nothing mysterious about these changes. A new <code>case</code> branch and a helper function called <code>readString</code> that calls <code>readChar</code> until it encounters either a closing double quote or the end of the input.</p>
<p>If you think that this is too easy, feel free to make <code>readString</code> report an error instead of simply returning when it reaches the end of the input. Or you can add support for character escaping so that string literals like <code>&quot;hello \&quot;world\&quot;&quot;</code>, <code>&quot;hello\n world&quot;</code> and <code>&quot;hello\t\t\tworld&quot;</code> work.</p>
<p>Meanwhile, our tests are passing:</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb348-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb348-2" data-line-number="2">ok      monkey/lexer    0.006s</a></code></pre></div>
<p>Great! Our lexer now knows how to handle string literals. It’s time to teach the parser how to do the same.</p>
<h3 id="parsing-strings">Parsing Strings</h3>
<p>In order for our parser to turn <code>token.STRING</code> into a string literal AST node we need to define said node. Thankfully the definition couldn’t be simpler. It looks really similar to <code>ast.IntegerLiteral</code>, except that the <code>Value</code> field now contains a <code>string</code> instead of an <code>int64</code>.</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb349-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb349-2" data-line-number="2"></a>
<a class="sourceLine" id="cb349-3" data-line-number="3"><span class="kw">type</span> StringLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb349-4" data-line-number="4">    Token token.Token</a>
<a class="sourceLine" id="cb349-5" data-line-number="5">    Value <span class="dt">string</span></a>
<a class="sourceLine" id="cb349-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb349-7" data-line-number="7"></a>
<a class="sourceLine" id="cb349-8" data-line-number="8"><span class="kw">func</span> (sl *StringLiteral) expressionNode()      {}</a>
<a class="sourceLine" id="cb349-9" data-line-number="9"><span class="kw">func</span> (sl *StringLiteral) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> sl.Token.Literal }</a>
<a class="sourceLine" id="cb349-10" data-line-number="10"><span class="kw">func</span> (sl *StringLiteral) String() <span class="dt">string</span>       { <span class="kw">return</span> sl.Token.Literal }</a></code></pre></div>
<p>Of course, string literals are expressions and not statements. They evaluate to the string.</p>
<p>With that definition we can write a small test case that makes sure the parser knows how to handle <code>token.STRING</code> tokens and outputs <code>*ast.StringLiteral</code>s:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb350-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb350-2" data-line-number="2"></a>
<a class="sourceLine" id="cb350-3" data-line-number="3"><span class="kw">func</span> TestStringLiteralExpression(t *testing.T) {</a>
<a class="sourceLine" id="cb350-4" data-line-number="4">    input := <span class="st">`&quot;hello world&quot;;`</span></a>
<a class="sourceLine" id="cb350-5" data-line-number="5"></a>
<a class="sourceLine" id="cb350-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb350-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb350-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb350-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb350-10" data-line-number="10"></a>
<a class="sourceLine" id="cb350-11" data-line-number="11">    stmt := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb350-12" data-line-number="12">    literal, ok := stmt.Expression.(*ast.StringLiteral)</a>
<a class="sourceLine" id="cb350-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb350-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp not *ast.StringLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb350-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb350-16" data-line-number="16"></a>
<a class="sourceLine" id="cb350-17" data-line-number="17">    <span class="kw">if</span> literal.Value != <span class="st">&quot;hello world&quot;</span> {</a>
<a class="sourceLine" id="cb350-18" data-line-number="18">        t.Errorf(<span class="st">&quot;literal.Value not %q. got=%q&quot;</span>, <span class="st">&quot;hello world&quot;</span>, literal.Value)</a>
<a class="sourceLine" id="cb350-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb350-20" data-line-number="20">}</a></code></pre></div>
<p>Running the tests results in a well known type of parser error:</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb351-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb351-2" data-line-number="2">--- FAIL: TestStringLiteralExpression (0.00s)</a>
<a class="sourceLine" id="cb351-3" data-line-number="3">  parser_test.go:888: parser has 1 errors</a>
<a class="sourceLine" id="cb351-4" data-line-number="4">  parser_test.go:890: parser error: &quot;no prefix parse function for STRING found&quot;</a>
<a class="sourceLine" id="cb351-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb351-6" data-line-number="6">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>We’ve seen that many times before and we know how to fix it. All we have to do is register a new <code>prefixParseFn</code> for <code>token.STRING</code> tokens. This parse function then returns an <code>*ast.StringLiteral</code>:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb352-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb352-2" data-line-number="2"></a>
<a class="sourceLine" id="cb352-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb352-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb352-5" data-line-number="5">    p.registerPrefix(token.STRING, p.parseStringLiteral)</a>
<a class="sourceLine" id="cb352-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb352-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb352-8" data-line-number="8"></a>
<a class="sourceLine" id="cb352-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseStringLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb352-10" data-line-number="10">    <span class="kw">return</span> &amp;ast.StringLiteral{Token: p.curToken, Value: p.curToken.Literal}</a>
<a class="sourceLine" id="cb352-11" data-line-number="11">}</a></code></pre></div>
<p>Three new lines! That’s all it takes to make the tests pass:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb353-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb353-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>So now our lexer turns string literals into <code>token.STRING</code> tokens and the parser turns those into <code>*ast.StringLiteral</code> nodes. We’re now ready to make changes to our object system and the evaluator.</p>
<h3 id="evaluating-strings">Evaluating Strings</h3>
<p>Representing a string in our object system is as easy as representing integers. And the biggest reason why it’s so easy is that we reuse Go’s <code>string</code> data type. Imagine adding a data type to the guest language that can’t be represented with built-in data structures of the host language. E.g.: strings in C. That’s a lot more work. But instead, all we have to do is define a new object that holds a string:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb354-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb354-2" data-line-number="2"></a>
<a class="sourceLine" id="cb354-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb354-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb354-5" data-line-number="5">    STRING_OBJ = <span class="st">&quot;STRING&quot;</span></a>
<a class="sourceLine" id="cb354-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb354-7" data-line-number="7"></a>
<a class="sourceLine" id="cb354-8" data-line-number="8"><span class="kw">type</span> String <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb354-9" data-line-number="9">    Value <span class="dt">string</span></a>
<a class="sourceLine" id="cb354-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb354-11" data-line-number="11"></a>
<a class="sourceLine" id="cb354-12" data-line-number="12"><span class="kw">func</span> (s *String) Type() ObjectType { <span class="kw">return</span> STRING_OBJ }</a>
<a class="sourceLine" id="cb354-13" data-line-number="13"><span class="kw">func</span> (s *String) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> s.Value }</a></code></pre></div>
<p>Now we need to extend our evaluator so it turns <code>*ast.StringLiteral</code> in <code>object.String</code> objects. The test to make sure that this works is tiny:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb355-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb355-2" data-line-number="2"></a>
<a class="sourceLine" id="cb355-3" data-line-number="3"><span class="kw">func</span> TestStringLiteral(t *testing.T) {</a>
<a class="sourceLine" id="cb355-4" data-line-number="4">    input := <span class="st">`&quot;Hello World!&quot;`</span></a>
<a class="sourceLine" id="cb355-5" data-line-number="5"></a>
<a class="sourceLine" id="cb355-6" data-line-number="6">    evaluated := testEval(input)</a>
<a class="sourceLine" id="cb355-7" data-line-number="7">    str, ok := evaluated.(*object.String)</a>
<a class="sourceLine" id="cb355-8" data-line-number="8">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb355-9" data-line-number="9">        t.Fatalf(<span class="st">&quot;object is not String. got=%T (%+v)&quot;</span>, evaluated, evaluated)</a>
<a class="sourceLine" id="cb355-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb355-11" data-line-number="11"></a>
<a class="sourceLine" id="cb355-12" data-line-number="12">    <span class="kw">if</span> str.Value != <span class="st">&quot;Hello World!&quot;</span> {</a>
<a class="sourceLine" id="cb355-13" data-line-number="13">        t.Errorf(<span class="st">&quot;String has wrong value. got=%q&quot;</span>, str.Value)</a>
<a class="sourceLine" id="cb355-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb355-15" data-line-number="15">}</a></code></pre></div>
<p>The call to <code>Eval</code> doesn’t return an <code>*object.String</code> yet but <code>nil</code>:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb356-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb356-2" data-line-number="2">--- FAIL: TestStringLiteral (0.00s)</a>
<a class="sourceLine" id="cb356-3" data-line-number="3">  evaluator_test.go:317: object is not String. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb356-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb356-5" data-line-number="5">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>Getting this test to pass needs even fewer lines than in the parser. Just two:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb357-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb357-2" data-line-number="2"></a>
<a class="sourceLine" id="cb357-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb357-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb357-5" data-line-number="5"></a>
<a class="sourceLine" id="cb357-6" data-line-number="6">    <span class="kw">case</span> *ast.StringLiteral:</a>
<a class="sourceLine" id="cb357-7" data-line-number="7">        <span class="kw">return</span> &amp;object.String{Value: node.Value}</a>
<a class="sourceLine" id="cb357-8" data-line-number="8"></a>
<a class="sourceLine" id="cb357-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb357-10" data-line-number="10">}</a></code></pre></div>
<p>That makes the tests pass and we can now use strings in our REPL:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb358-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb358-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb358-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb358-4" data-line-number="4">&gt;&gt; &quot;Hello world!&quot;</a>
<a class="sourceLine" id="cb358-5" data-line-number="5">Hello world!</a>
<a class="sourceLine" id="cb358-6" data-line-number="6">&gt;&gt; let hello = &quot;Hello there, fellow Monkey users and fans!&quot;</a>
<a class="sourceLine" id="cb358-7" data-line-number="7">&gt;&gt; hello</a>
<a class="sourceLine" id="cb358-8" data-line-number="8">Hello there, fellow Monkey users and fans!</a>
<a class="sourceLine" id="cb358-9" data-line-number="9">&gt;&gt; let giveMeHello = fn() { &quot;Hello!&quot; }</a>
<a class="sourceLine" id="cb358-10" data-line-number="10">&gt;&gt; giveMeHello()</a>
<a class="sourceLine" id="cb358-11" data-line-number="11">Hello!</a></code></pre></div>
<p>We now have full support for strings in our interpreter! Sweet! Or should I say…</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb359-1" data-line-number="1">&gt;&gt; &quot;This is amazing!&quot;</a>
<a class="sourceLine" id="cb359-2" data-line-number="2">This is amazing!</a></code></pre></div>
<h3 id="string-concatenation">String Concatenation</h3>
<p>Having the string data type available is great. But we can’t do much with strings yet, besides creating them. Let’s change that! In this section we’re going to add string concatenation to our interpreter. And we’ll do that by adding support for the <code>+</code> infix operator with string operands.</p>
<p>What we want is perfectly described by this test:</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb360-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb360-2" data-line-number="2"></a>
<a class="sourceLine" id="cb360-3" data-line-number="3"><span class="kw">func</span> TestStringConcatenation(t *testing.T) {</a>
<a class="sourceLine" id="cb360-4" data-line-number="4">    input := <span class="st">`&quot;Hello&quot; + &quot; &quot; + &quot;World!&quot;`</span></a>
<a class="sourceLine" id="cb360-5" data-line-number="5"></a>
<a class="sourceLine" id="cb360-6" data-line-number="6">    evaluated := testEval(input)</a>
<a class="sourceLine" id="cb360-7" data-line-number="7">    str, ok := evaluated.(*object.String)</a>
<a class="sourceLine" id="cb360-8" data-line-number="8">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb360-9" data-line-number="9">        t.Fatalf(<span class="st">&quot;object is not String. got=%T (%+v)&quot;</span>, evaluated, evaluated)</a>
<a class="sourceLine" id="cb360-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb360-11" data-line-number="11"></a>
<a class="sourceLine" id="cb360-12" data-line-number="12">    <span class="kw">if</span> str.Value != <span class="st">&quot;Hello World!&quot;</span> {</a>
<a class="sourceLine" id="cb360-13" data-line-number="13">        t.Errorf(<span class="st">&quot;String has wrong value. got=%q&quot;</span>, str.Value)</a>
<a class="sourceLine" id="cb360-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb360-15" data-line-number="15">}</a></code></pre></div>
<p>We can also extend our <code>TestErrorHandling</code> function to make sure that we only add support for the <code>+</code> operator and nothing more:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb361-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb361-2" data-line-number="2"></a>
<a class="sourceLine" id="cb361-3" data-line-number="3"><span class="kw">func</span> TestErrorHandling(t *testing.T) {</a>
<a class="sourceLine" id="cb361-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb361-5" data-line-number="5">        input           <span class="dt">string</span></a>
<a class="sourceLine" id="cb361-6" data-line-number="6">        expectedMessage <span class="dt">string</span></a>
<a class="sourceLine" id="cb361-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb361-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb361-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb361-10" data-line-number="10">            <span class="st">`&quot;Hello&quot; - &quot;World&quot;`</span>,</a>
<a class="sourceLine" id="cb361-11" data-line-number="11">            <span class="st">&quot;unknown operator: STRING - STRING&quot;</span>,</a>
<a class="sourceLine" id="cb361-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb361-13" data-line-number="13"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb361-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb361-15" data-line-number="15"></a>
<a class="sourceLine" id="cb361-16" data-line-number="16"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb361-17" data-line-number="17">}</a></code></pre></div>
<p>This test case is already green and acts more as specification and regression testing than as a guide for an implementation. But our concatenation test is failing:</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb362-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb362-2" data-line-number="2">--- FAIL: TestStringConcatenation (0.00s)</a>
<a class="sourceLine" id="cb362-3" data-line-number="3">  evaluator_test.go:336: object is not String. got=*object.Error\</a>
<a class="sourceLine" id="cb362-4" data-line-number="4">    (&amp;{Message:unknown operator: STRING + STRING})</a>
<a class="sourceLine" id="cb362-5" data-line-number="5">FAIL</a>
<a class="sourceLine" id="cb362-6" data-line-number="6">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>The place where we need to make changes is <code>evalInfixExpression</code>. Here we need to add a new branch to the existing switch statement that’s evaluated when both operands are strings:</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb363-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb363-2" data-line-number="2"></a>
<a class="sourceLine" id="cb363-3" data-line-number="3"><span class="kw">func</span> evalInfixExpression(</a>
<a class="sourceLine" id="cb363-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb363-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb363-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb363-7" data-line-number="7">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb363-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb363-9" data-line-number="9">    <span class="kw">case</span> left.Type() == object.STRING_OBJ &amp;&amp; right.Type() == object.STRING_OBJ:</a>
<a class="sourceLine" id="cb363-10" data-line-number="10">        <span class="kw">return</span> evalStringInfixExpression(operator, left, right)</a>
<a class="sourceLine" id="cb363-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb363-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb363-13" data-line-number="13">}</a></code></pre></div>
<p>The <code>evalStringInfixExpression</code> is the most minimal implementation possible:</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb364-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb364-2" data-line-number="2"></a>
<a class="sourceLine" id="cb364-3" data-line-number="3"><span class="kw">func</span> evalStringInfixExpression(</a>
<a class="sourceLine" id="cb364-4" data-line-number="4">    operator <span class="dt">string</span>,</a>
<a class="sourceLine" id="cb364-5" data-line-number="5">    left, right object.Object,</a>
<a class="sourceLine" id="cb364-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb364-7" data-line-number="7">    <span class="kw">if</span> operator != <span class="st">&quot;+&quot;</span> {</a>
<a class="sourceLine" id="cb364-8" data-line-number="8">        <span class="kw">return</span> newError(<span class="st">&quot;unknown operator: %s %s %s&quot;</span>,</a>
<a class="sourceLine" id="cb364-9" data-line-number="9">            left.Type(), operator, right.Type())</a>
<a class="sourceLine" id="cb364-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb364-11" data-line-number="11"></a>
<a class="sourceLine" id="cb364-12" data-line-number="12">    leftVal := left.(*object.String).Value</a>
<a class="sourceLine" id="cb364-13" data-line-number="13">    rightVal := right.(*object.String).Value</a>
<a class="sourceLine" id="cb364-14" data-line-number="14">    <span class="kw">return</span> &amp;object.String{Value: leftVal + rightVal}</a>
<a class="sourceLine" id="cb364-15" data-line-number="15">}</a></code></pre></div>
<p>The first thing here is the check for the correct operator. If it’s the supported <code>+</code> we unwrap the string objects and construct a new string that’s a concatenation of both operands.</p>
<p>If we want to support more operators for strings this is the place where to add them. Also, if we want to support comparison of strings with the <code>==</code> and <code>!=</code> we’d need to add this here too. Pointer comparison doesn’t work for strings, at least not in the way we want it to: with strings we want to compare values and not pointers.</p>
<p>And that’s it! Our tests pass:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb365-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb365-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>We can now use string literals, pass them around, bind them to names, return them from functions and also concatenate them:</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb366-1" data-line-number="1">&gt;&gt; let makeGreeter = fn(greeting) { fn(name) { greeting + &quot; &quot; + name + &quot;!&quot; } };</a>
<a class="sourceLine" id="cb366-2" data-line-number="2">&gt;&gt; let hello = makeGreeter(&quot;Hello&quot;);</a>
<a class="sourceLine" id="cb366-3" data-line-number="3">&gt;&gt; hello(&quot;Thorsten&quot;);</a>
<a class="sourceLine" id="cb366-4" data-line-number="4">Hello Thorsten!</a>
<a class="sourceLine" id="cb366-5" data-line-number="5">&gt;&gt; let heythere = makeGreeter(&quot;Hey there&quot;);</a>
<a class="sourceLine" id="cb366-6" data-line-number="6">&gt;&gt; heythere(&quot;Thorsten&quot;);</a>
<a class="sourceLine" id="cb366-7" data-line-number="7">Hey there Thorsten!</a></code></pre></div>
<p>Alright! I’d say strings are now working very well in our interpreter. But we can still add something else to work with them…</p>
<h2 id="built-in-functions">4.3 - Built-in Functions</h2>
<p>In this section we’re going to add built-in functions to our interpreter. They’re called “built-in”, because they’re not defined by a user of the interpreter and they’re not Monkey code - they are built right into the interpreter, into the language itself.</p>
<p>These built-in functions are defined by us, in Go, and bridge the world of Monkey with the world of our interpreter implementation. A lot of language implementations provide such functions to offer functionality to the language’s user that’s not provided “inside” the language.</p>
<p>Here’s an example: a function that returns the current time. In order to get the current time one could ask the kernel (or another computer, etc.). Asking and talking to the kernel is normally done via something called system calls. But if the programming language doesn’t offer users to make such system calls themselves, then the language implementation, be it the compiler or the interpreter, has to provide something to make these system calls on behalf of the users instead.</p>
<p>So, again, the built-in functions we’re going to add are defined by us, the implementers of the interpreter. The user of the interpreter can call them, but we define them. What these functions can do, we leave open. The only restriction they have is that they need to accept zero or more <code>object.Object</code> as arguments and return an <code>object.Object</code>.</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb367-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb367-2" data-line-number="2"></a>
<a class="sourceLine" id="cb367-3" data-line-number="3"><span class="kw">type</span> BuiltinFunction <span class="kw">func</span>(args ...Object) Object</a></code></pre></div>
<p>That’s the type definition of a callable Go function. But since we need to make these <code>BuiltinFunction</code>s available to our users we need to fit them into our object system. We do that by wrapping them:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb368-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb368-2" data-line-number="2"></a>
<a class="sourceLine" id="cb368-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb368-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb368-5" data-line-number="5">    BUILTIN_OBJ = <span class="st">&quot;BUILTIN&quot;</span></a>
<a class="sourceLine" id="cb368-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb368-7" data-line-number="7"></a>
<a class="sourceLine" id="cb368-8" data-line-number="8"><span class="kw">type</span> Builtin <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb368-9" data-line-number="9">    Fn BuiltinFunction</a>
<a class="sourceLine" id="cb368-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb368-11" data-line-number="11"></a>
<a class="sourceLine" id="cb368-12" data-line-number="12"><span class="kw">func</span> (b *Builtin) Type() ObjectType { <span class="kw">return</span> BUILTIN_OBJ }</a>
<a class="sourceLine" id="cb368-13" data-line-number="13"><span class="kw">func</span> (b *Builtin) Inspect() <span class="dt">string</span>  { <span class="kw">return</span> <span class="st">&quot;builtin function&quot;</span> }</a></code></pre></div>
<p>There’s not much to <code>object.Builtin</code>, as you can see. It’s clearly just a wrapper. But in combination with <code>object.BuiltinFunction</code> it’s enough to get us started.</p>
<h3 id="len">len</h3>
<p>The first built-in function we’re going to add to our interpreter is <code>len</code>. Its job is to return the number of characters in a string. It’s impossible to define this function as a user of Monkey. That’s why we need it to be built-in. What we want from <code>len</code> is this:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb369-1" data-line-number="1">&gt;&gt; len(&quot;Hello World!&quot;)</a>
<a class="sourceLine" id="cb369-2" data-line-number="2">12</a>
<a class="sourceLine" id="cb369-3" data-line-number="3">&gt;&gt; len(&quot;&quot;)</a>
<a class="sourceLine" id="cb369-4" data-line-number="4">0</a>
<a class="sourceLine" id="cb369-5" data-line-number="5">&gt;&gt; len(&quot;Hey Bob, how ya doin?&quot;)</a>
<a class="sourceLine" id="cb369-6" data-line-number="6">21</a></code></pre></div>
<p>I think that makes the idea behind <code>len</code> pretty clear. So clear in fact, that we can easily write a test for it:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb370-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb370-2" data-line-number="2"></a>
<a class="sourceLine" id="cb370-3" data-line-number="3"><span class="kw">func</span> TestBuiltinFunctions(t *testing.T) {</a>
<a class="sourceLine" id="cb370-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb370-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb370-6" data-line-number="6">        expected <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb370-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb370-8" data-line-number="8">        {<span class="st">`len(&quot;&quot;)`</span>, <span class="dv">0</span>},</a>
<a class="sourceLine" id="cb370-9" data-line-number="9">        {<span class="st">`len(&quot;four&quot;)`</span>, <span class="dv">4</span>},</a>
<a class="sourceLine" id="cb370-10" data-line-number="10">        {<span class="st">`len(&quot;hello world&quot;)`</span>, <span class="dv">11</span>},</a>
<a class="sourceLine" id="cb370-11" data-line-number="11">        {<span class="st">`len(1)`</span>, <span class="st">&quot;argument to `len` not supported, got INTEGER&quot;</span>},</a>
<a class="sourceLine" id="cb370-12" data-line-number="12">        {<span class="st">`len(&quot;one&quot;, &quot;two&quot;)`</span>, <span class="st">&quot;wrong number of arguments. got=2, want=1&quot;</span>},</a>
<a class="sourceLine" id="cb370-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb370-14" data-line-number="14"></a>
<a class="sourceLine" id="cb370-15" data-line-number="15">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb370-16" data-line-number="16">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb370-17" data-line-number="17"></a>
<a class="sourceLine" id="cb370-18" data-line-number="18">        <span class="kw">switch</span> expected := tt.expected.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb370-19" data-line-number="19">        <span class="kw">case</span> <span class="dt">int</span>:</a>
<a class="sourceLine" id="cb370-20" data-line-number="20">            testIntegerObject(t, evaluated, <span class="dt">int64</span>(expected))</a>
<a class="sourceLine" id="cb370-21" data-line-number="21">        <span class="kw">case</span> <span class="dt">string</span>:</a>
<a class="sourceLine" id="cb370-22" data-line-number="22">            errObj, ok := evaluated.(*object.Error)</a>
<a class="sourceLine" id="cb370-23" data-line-number="23">            <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb370-24" data-line-number="24">                t.Errorf(<span class="st">&quot;object is not Error. got=%T (%+v)&quot;</span>,</a>
<a class="sourceLine" id="cb370-25" data-line-number="25">                    evaluated, evaluated)</a>
<a class="sourceLine" id="cb370-26" data-line-number="26">                <span class="kw">continue</span></a>
<a class="sourceLine" id="cb370-27" data-line-number="27">            }</a>
<a class="sourceLine" id="cb370-28" data-line-number="28">            <span class="kw">if</span> errObj.Message != expected {</a>
<a class="sourceLine" id="cb370-29" data-line-number="29">                t.Errorf(<span class="st">&quot;wrong error message. expected=%q, got=%q&quot;</span>,</a>
<a class="sourceLine" id="cb370-30" data-line-number="30">                    expected, errObj.Message)</a>
<a class="sourceLine" id="cb370-31" data-line-number="31">            }</a>
<a class="sourceLine" id="cb370-32" data-line-number="32">        }</a>
<a class="sourceLine" id="cb370-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb370-34" data-line-number="34">}</a></code></pre></div>
<p>So here we have a few test cases that run <code>len</code> through its paces: an empty string, a normal string and a string containing whitespace. It really shouldn’t matter if there’s whitespace in the string, but you’ll never know, so I put the test case in. The last two test cases are more interesting: we want to make sure that <code>len</code> returns an <code>*object.Error</code> when called with an integer or with the wrong number of arguments.</p>
<p>If we run the tests we can see that calling <code>len</code> gives us an error, but not the one expected in our test case:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb371-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb371-2" data-line-number="2">--- FAIL: TestBuiltinFunctions (0.00s)</a>
<a class="sourceLine" id="cb371-3" data-line-number="3">  evaluator_test.go:389: object is not Integer. got=*object.Error\</a>
<a class="sourceLine" id="cb371-4" data-line-number="4">    (&amp;{Message:identifier not found: len})</a>
<a class="sourceLine" id="cb371-5" data-line-number="5">  evaluator_test.go:389: object is not Integer. got=*object.Error\</a>
<a class="sourceLine" id="cb371-6" data-line-number="6">    (&amp;{Message:identifier not found: len})</a>
<a class="sourceLine" id="cb371-7" data-line-number="7">  evaluator_test.go:389: object is not Integer. got=*object.Error\</a>
<a class="sourceLine" id="cb371-8" data-line-number="8">    (&amp;{Message:identifier not found: len})</a>
<a class="sourceLine" id="cb371-9" data-line-number="9">  evaluator_test.go:371: wrong error message.\</a>
<a class="sourceLine" id="cb371-10" data-line-number="10">    expected=&quot;argument to `len` not supported, got INTEGER&quot;,\</a>
<a class="sourceLine" id="cb371-11" data-line-number="11">    got=&quot;identifier not found: len&quot;</a>
<a class="sourceLine" id="cb371-12" data-line-number="12">FAIL</a>
<a class="sourceLine" id="cb371-13" data-line-number="13">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p><code>len</code> can’t be found, which isn’t that baffling considering that we haven’t defined it yet.</p>
<p>In order to do that, the first thing we have to do is provide a way for built-in functions to be found. One option is to add them to the top-level <code>object.Environment</code>, that gets passed into <code>Eval</code>. But instead we’re going to keep a separate environment of built-in functions:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb372-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb372-2" data-line-number="2"></a>
<a class="sourceLine" id="cb372-3" data-line-number="3"><span class="kw">package</span> evaluator</a>
<a class="sourceLine" id="cb372-4" data-line-number="4"></a>
<a class="sourceLine" id="cb372-5" data-line-number="5"><span class="kw">import</span> <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb372-6" data-line-number="6"></a>
<a class="sourceLine" id="cb372-7" data-line-number="7"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb372-8" data-line-number="8">    <span class="st">&quot;len&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb372-9" data-line-number="9">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb372-10" data-line-number="10">            <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb372-11" data-line-number="11">        },</a>
<a class="sourceLine" id="cb372-12" data-line-number="12">    },</a>
<a class="sourceLine" id="cb372-13" data-line-number="13">}</a></code></pre></div>
<p>In order to make use of that, we need to edit our <code>evalIdentifier</code> function to lookup built-in functions as a fallback when the given identifier is not bound to a value in the current environment:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb373-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb373-2" data-line-number="2"></a>
<a class="sourceLine" id="cb373-3" data-line-number="3"><span class="kw">func</span> evalIdentifier(</a>
<a class="sourceLine" id="cb373-4" data-line-number="4">    node *ast.Identifier,</a>
<a class="sourceLine" id="cb373-5" data-line-number="5">    env *object.Environment,</a>
<a class="sourceLine" id="cb373-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb373-7" data-line-number="7">    <span class="kw">if</span> val, ok := env.Get(node.Value); ok {</a>
<a class="sourceLine" id="cb373-8" data-line-number="8">        <span class="kw">return</span> val</a>
<a class="sourceLine" id="cb373-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb373-10" data-line-number="10"></a>
<a class="sourceLine" id="cb373-11" data-line-number="11">    <span class="kw">if</span> builtin, ok := builtins[node.Value]; ok {</a>
<a class="sourceLine" id="cb373-12" data-line-number="12">        <span class="kw">return</span> builtin</a>
<a class="sourceLine" id="cb373-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb373-14" data-line-number="14"></a>
<a class="sourceLine" id="cb373-15" data-line-number="15">    <span class="kw">return</span> newError(<span class="st">&quot;identifier not found: &quot;</span> + node.Value)</a>
<a class="sourceLine" id="cb373-16" data-line-number="16">}</a></code></pre></div>
<p>So now <code>len</code> is found when looking up the <code>len</code> identifier, calling it doesn’t work yet:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb374-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb374-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb374-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb374-4" data-line-number="4">&gt;&gt; len()</a>
<a class="sourceLine" id="cb374-5" data-line-number="5">ERROR: not a function: BUILTIN</a>
<a class="sourceLine" id="cb374-6" data-line-number="6">&gt;&gt;</a></code></pre></div>
<p>Running the tests gives us the same error. We need to teach our <code>applyFunction</code> about <code>*object.Builtin</code> and <code>object.BuiltinFunction</code>:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb375-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb375-2" data-line-number="2"></a>
<a class="sourceLine" id="cb375-3" data-line-number="3"><span class="kw">func</span> applyFunction(fn object.Object, args []object.Object) object.Object {</a>
<a class="sourceLine" id="cb375-4" data-line-number="4">    <span class="kw">switch</span> fn := fn.(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb375-5" data-line-number="5"></a>
<a class="sourceLine" id="cb375-6" data-line-number="6">    <span class="kw">case</span> *object.Function:</a>
<a class="sourceLine" id="cb375-7" data-line-number="7">        extendedEnv := extendFunctionEnv(fn, args)</a>
<a class="sourceLine" id="cb375-8" data-line-number="8">        evaluated := Eval(fn.Body, extendedEnv)</a>
<a class="sourceLine" id="cb375-9" data-line-number="9">        <span class="kw">return</span> unwrapReturnValue(evaluated)</a>
<a class="sourceLine" id="cb375-10" data-line-number="10"></a>
<a class="sourceLine" id="cb375-11" data-line-number="11">    <span class="kw">case</span> *object.Builtin:</a>
<a class="sourceLine" id="cb375-12" data-line-number="12">        <span class="kw">return</span> fn.Fn(args...)</a>
<a class="sourceLine" id="cb375-13" data-line-number="13"></a>
<a class="sourceLine" id="cb375-14" data-line-number="14">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb375-15" data-line-number="15">        <span class="kw">return</span> newError(<span class="st">&quot;not a function: %s&quot;</span>, fn.Type())</a>
<a class="sourceLine" id="cb375-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb375-17" data-line-number="17">}</a></code></pre></div>
<p>Besides moving the existing lines around, what changed here is the addition of the <code>case *object.Builtin</code> branch, in which we call the <code>object.BuiltinFunction</code>. Doing so is as easy as using the <code>args</code> slice as arguments and calling the function.</p>
<p>Of note is that we don’t need to <code>unwrapReturnValue</code> when calling a built-in function. That’s because we never return an <code>*object.ReturnValue</code> from these functions.</p>
<p>Now the tests are rightfully complaining about <code>NULL</code> being returned when calling <code>len</code>:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb376-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb376-2" data-line-number="2">--- FAIL: TestBuiltinFunctions (0.00s)</a>
<a class="sourceLine" id="cb376-3" data-line-number="3">  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb376-4" data-line-number="4">  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb376-5" data-line-number="5">  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb376-6" data-line-number="6">  evaluator_test.go:366: object is not Error. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb376-7" data-line-number="7">  evaluator_test.go:366: object is not Error. got=*object.Null (&amp;{})</a>
<a class="sourceLine" id="cb376-8" data-line-number="8">FAIL</a>
<a class="sourceLine" id="cb376-9" data-line-number="9">FAIL    monkey/evaluator        0.007s</a></code></pre></div>
<p>That means that calling <code>len</code> works though! It’s just that it returns only <code>NULL</code>. But fixing this is as easy as writing any other Go function:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb377-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb377-2" data-line-number="2"></a>
<a class="sourceLine" id="cb377-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb377-4" data-line-number="4">    <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb377-5" data-line-number="5">)</a>
<a class="sourceLine" id="cb377-6" data-line-number="6"></a>
<a class="sourceLine" id="cb377-7" data-line-number="7"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb377-8" data-line-number="8">    <span class="st">&quot;len&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb377-9" data-line-number="9">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb377-10" data-line-number="10">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb377-11" data-line-number="11">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</a>
<a class="sourceLine" id="cb377-12" data-line-number="12">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb377-13" data-line-number="13">            }</a>
<a class="sourceLine" id="cb377-14" data-line-number="14"></a>
<a class="sourceLine" id="cb377-15" data-line-number="15">            <span class="kw">switch</span> arg := args[<span class="dv">0</span>].(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb377-16" data-line-number="16">            <span class="kw">case</span> *object.String:</a>
<a class="sourceLine" id="cb377-17" data-line-number="17">                <span class="kw">return</span> &amp;object.Integer{Value: <span class="dt">int64</span>(<span class="bu">len</span>(arg.Value))}</a>
<a class="sourceLine" id="cb377-18" data-line-number="18">            <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb377-19" data-line-number="19">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `len` not supported, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb377-20" data-line-number="20">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb377-21" data-line-number="21">            }</a>
<a class="sourceLine" id="cb377-22" data-line-number="22">        },</a>
<a class="sourceLine" id="cb377-23" data-line-number="23">    },</a>
<a class="sourceLine" id="cb377-24" data-line-number="24">}</a></code></pre></div>
<p>The most important part of this function is the call to Go’s <code>len</code> and the returning of a newly allocated <code>object.Integer</code>. Besides that we have error checking that makes sure that we can’t call this function with the wrong number of arguments or with an argument of an unsupported type. And alas, our tests pass:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb378-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb378-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>That means we can take <code>len</code> on a test drive in our REPL:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb379-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb379-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb379-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb379-4" data-line-number="4">&gt;&gt; len(&quot;1234&quot;)</a>
<a class="sourceLine" id="cb379-5" data-line-number="5">4</a>
<a class="sourceLine" id="cb379-6" data-line-number="6">&gt;&gt; len(&quot;Hello World!&quot;)</a>
<a class="sourceLine" id="cb379-7" data-line-number="7">12</a>
<a class="sourceLine" id="cb379-8" data-line-number="8">&gt;&gt; len(&quot;Woooooohooo!&quot;, &quot;len works!!&quot;)</a>
<a class="sourceLine" id="cb379-9" data-line-number="9">ERROR: wrong number of arguments. got=2, want=1</a>
<a class="sourceLine" id="cb379-10" data-line-number="10">&gt;&gt; len(12345)</a>
<a class="sourceLine" id="cb379-11" data-line-number="11">ERROR: argument to `len` not supported, got INTEGER</a></code></pre></div>
<p>Perfect! Our first built-in function works and is ready to go.</p>
<h2 id="array">4.4 - Array</h2>
<p>The data type we’re going to add to our Monkey interpreter in this section is the array. In Monkey an array is an ordered list of elements of possibly different types. Each element in the array can be accessed individually. Arrays are constructed by using their literal form: a comma separated list of elements, enclosed by brackets.</p>
<p>Initializing a new array, binding it to a name and accessing individual elements will look like this:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb380-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> myArray <span class="op">=</span> [<span class="st">&quot;Thorsten&quot;</span><span class="op">,</span> <span class="st">&quot;Ball&quot;</span><span class="op">,</span> <span class="dv">28</span><span class="op">,</span> <span class="at">fn</span>(x) <span class="op">{</span> x <span class="op">*</span> x <span class="op">}</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb380-2" data-line-number="2"><span class="op">&gt;&gt;</span> myArray[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb380-3" data-line-number="3">Thorsten</a>
<a class="sourceLine" id="cb380-4" data-line-number="4"><span class="op">&gt;&gt;</span> myArray[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb380-5" data-line-number="5"><span class="dv">28</span></a>
<a class="sourceLine" id="cb380-6" data-line-number="6"><span class="op">&gt;&gt;</span> myArray[<span class="dv">3</span>](<span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb380-7" data-line-number="7"><span class="dv">4</span></a></code></pre></div>
<p>As you can see, Monkey arrays really don’t care about the types of their elements. Every possible value in Monkey can be an element in an array. In this example <code>myArray</code> holds two strings, an integer and a function.</p>
<p>Accessing individual elements by their index in the array, as seen in the last three lines, is done with a new operator, called the index operator: <code>array[index]</code>.</p>
<p>In this section we’ll also add support for arrays to our newly added <code>len</code> function and also add a few more built-in functions that work with arrays:</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb381-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> myArray <span class="op">=</span> [<span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">,</span> <span class="st">&quot;three&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb381-2" data-line-number="2"><span class="op">&gt;&gt;</span> <span class="at">len</span>(myArray)</a>
<a class="sourceLine" id="cb381-3" data-line-number="3"><span class="dv">3</span></a>
<a class="sourceLine" id="cb381-4" data-line-number="4"><span class="op">&gt;&gt;</span> <span class="at">first</span>(myArray)</a>
<a class="sourceLine" id="cb381-5" data-line-number="5">one</a>
<a class="sourceLine" id="cb381-6" data-line-number="6"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(myArray)</a>
<a class="sourceLine" id="cb381-7" data-line-number="7">[two<span class="op">,</span> three]</a>
<a class="sourceLine" id="cb381-8" data-line-number="8"><span class="op">&gt;&gt;</span> <span class="at">last</span>(myArray)</a>
<a class="sourceLine" id="cb381-9" data-line-number="9">three</a>
<a class="sourceLine" id="cb381-10" data-line-number="10"><span class="op">&gt;&gt;</span> <span class="at">push</span>(myArray<span class="op">,</span> <span class="st">&quot;four&quot;</span>)</a>
<a class="sourceLine" id="cb381-11" data-line-number="11">[one<span class="op">,</span> two<span class="op">,</span> three<span class="op">,</span> four]</a></code></pre></div>
<p>The basis for our implementation of the Monkey array in our interpreter will be a Go slice of type <code>[]object.Object</code>. That means that we don’t have to implement a new data structure. We can just reuse Go’s slice.</p>
<p>Sounds awesome? Good! The first thing we have to do is teach our lexer a few new tokens.</p>
<h3 id="supporting-arrays-in-our-lexer">Supporting Arrays in our Lexer</h3>
<p>In order to correctly parse array literals and the index operator, our lexer needs to be able to identify more tokens than it currently does. All the tokens we need in order to construct and use arrays in Monkey are <code>[</code>, <code>]</code> and <code>,</code>. The lexer already knows about <code>,</code> so we only need to add support for <code>[</code> and <code>]</code>.</p>
<p>The first step is to define these new token types in the <code>token</code> package:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb382-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb382-2" data-line-number="2"></a>
<a class="sourceLine" id="cb382-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb382-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb382-5" data-line-number="5"></a>
<a class="sourceLine" id="cb382-6" data-line-number="6">    LBRACKET = <span class="st">&quot;[&quot;</span></a>
<a class="sourceLine" id="cb382-7" data-line-number="7">    RBRACKET = <span class="st">&quot;]&quot;</span></a>
<a class="sourceLine" id="cb382-8" data-line-number="8"></a>
<a class="sourceLine" id="cb382-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb382-10" data-line-number="10">)</a></code></pre></div>
<p>The second step is to extend the test suite of the lexer, which is easy, since we’ve done this many times before:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb383-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb383-2" data-line-number="2"></a>
<a class="sourceLine" id="cb383-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb383-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb383-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb383-6" data-line-number="6"></a>
<a class="sourceLine" id="cb383-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb383-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb383-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb383-10" data-line-number="10"></a>
<a class="sourceLine" id="cb383-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb383-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb383-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb383-14" data-line-number="14"></a>
<a class="sourceLine" id="cb383-15" data-line-number="15"><span class="st">if (5 &lt; 10) {</span></a>
<a class="sourceLine" id="cb383-16" data-line-number="16"><span class="st">    return true;</span></a>
<a class="sourceLine" id="cb383-17" data-line-number="17"><span class="st">} else {</span></a>
<a class="sourceLine" id="cb383-18" data-line-number="18"><span class="st">    return false;</span></a>
<a class="sourceLine" id="cb383-19" data-line-number="19"><span class="st">}</span></a>
<a class="sourceLine" id="cb383-20" data-line-number="20"></a>
<a class="sourceLine" id="cb383-21" data-line-number="21"><span class="st">10 == 10;</span></a>
<a class="sourceLine" id="cb383-22" data-line-number="22"><span class="st">10 != 9;</span></a>
<a class="sourceLine" id="cb383-23" data-line-number="23"><span class="st">&quot;foobar&quot;</span></a>
<a class="sourceLine" id="cb383-24" data-line-number="24"><span class="st">&quot;foo bar&quot;</span></a>
<a class="sourceLine" id="cb383-25" data-line-number="25"><span class="st">[1, 2];</span></a>
<a class="sourceLine" id="cb383-26" data-line-number="26"><span class="st">`</span></a>
<a class="sourceLine" id="cb383-27" data-line-number="27"></a>
<a class="sourceLine" id="cb383-28" data-line-number="28">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb383-29" data-line-number="29">        expectedType    token.TokenType</a>
<a class="sourceLine" id="cb383-30" data-line-number="30">        expectedLiteral <span class="dt">string</span></a>
<a class="sourceLine" id="cb383-31" data-line-number="31">    }{</a>
<a class="sourceLine" id="cb383-32" data-line-number="32"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb383-33" data-line-number="33">        {token.LBRACKET, <span class="st">&quot;[&quot;</span>},</a>
<a class="sourceLine" id="cb383-34" data-line-number="34">        {token.INT, <span class="st">&quot;1&quot;</span>},</a>
<a class="sourceLine" id="cb383-35" data-line-number="35">        {token.COMMA, <span class="st">&quot;,&quot;</span>},</a>
<a class="sourceLine" id="cb383-36" data-line-number="36">        {token.INT, <span class="st">&quot;2&quot;</span>},</a>
<a class="sourceLine" id="cb383-37" data-line-number="37">        {token.RBRACKET, <span class="st">&quot;]&quot;</span>},</a>
<a class="sourceLine" id="cb383-38" data-line-number="38">        {token.SEMICOLON, <span class="st">&quot;;&quot;</span>},</a>
<a class="sourceLine" id="cb383-39" data-line-number="39">        {token.EOF, <span class="st">&quot;&quot;</span>},</a>
<a class="sourceLine" id="cb383-40" data-line-number="40">    }</a>
<a class="sourceLine" id="cb383-41" data-line-number="41"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb383-42" data-line-number="42">}</a></code></pre></div>
<p>Again the <code>input</code> is extended to include new tokens (<code>[1, 2]</code> in this case) and new <code>tests</code> have been added to make sure the lexer’s <code>NextToken</code> method really returns <code>token.LBRACKET</code> and <code>token.RBRACKET</code>.</p>
<p>Making the test pass is as easy as adding these <em>four</em> lines to our <code>NextToken()</code> method. Yes, just four:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb384-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb384-2" data-line-number="2"></a>
<a class="sourceLine" id="cb384-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb384-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb384-5" data-line-number="5"></a>
<a class="sourceLine" id="cb384-6" data-line-number="6">    <span class="kw">case</span> <span class="ch">&#39;[&#39;</span>:</a>
<a class="sourceLine" id="cb384-7" data-line-number="7">        tok = newToken(token.LBRACKET, l.ch)</a>
<a class="sourceLine" id="cb384-8" data-line-number="8">    <span class="kw">case</span> <span class="ch">&#39;]&#39;</span>:</a>
<a class="sourceLine" id="cb384-9" data-line-number="9">        tok = newToken(token.RBRACKET, l.ch)</a>
<a class="sourceLine" id="cb384-10" data-line-number="10"></a>
<a class="sourceLine" id="cb384-11" data-line-number="11"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb384-12" data-line-number="12">}</a></code></pre></div>
<p>Alright! The tests are passing:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb385-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb385-2" data-line-number="2">ok      monkey/lexer    0.006s</a></code></pre></div>
<p>In our parser we’ll now use <code>token.LBRACKET</code> and <code>token.RBRACKET</code> to parse arrays.</p>
<h3 id="parsing-array-literals">Parsing Array Literals</h3>
<p>As we saw before, an array literal in Monkey is a comma-separated list of expressions enclosed by an opening and a closing bracket.</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb386-1" data-line-number="1">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">3</span><span class="op">,</span> <span class="at">fn</span>(x) <span class="op">{</span> x <span class="op">},</span> <span class="at">add</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>Yes, the elements in an array literal can be any type of expression. Integer literals, function literals, infix or prefix expressions.</p>
<p>If that sounds complicated, don’t worry. We already know how to parse comma-separated lists of expressions - function call arguments are just that. And we also know how to parse something enclosed by matching tokens. In other words: let’s get to it!</p>
<p>The first thing we have to do is define the AST node for array literals. Since we already have the essential pieces in place for this, the definition is rather self-explanatory:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb387-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb387-2" data-line-number="2"></a>
<a class="sourceLine" id="cb387-3" data-line-number="3"><span class="kw">type</span> ArrayLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb387-4" data-line-number="4">    Token    token.Token <span class="co">// the &#39;[&#39; token</span></a>
<a class="sourceLine" id="cb387-5" data-line-number="5">    Elements []Expression</a>
<a class="sourceLine" id="cb387-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb387-7" data-line-number="7"></a>
<a class="sourceLine" id="cb387-8" data-line-number="8"><span class="kw">func</span> (al *ArrayLiteral) expressionNode()      {}</a>
<a class="sourceLine" id="cb387-9" data-line-number="9"><span class="kw">func</span> (al *ArrayLiteral) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> al.Token.Literal }</a>
<a class="sourceLine" id="cb387-10" data-line-number="10"><span class="kw">func</span> (al *ArrayLiteral) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb387-11" data-line-number="11">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb387-12" data-line-number="12"></a>
<a class="sourceLine" id="cb387-13" data-line-number="13">    elements := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb387-14" data-line-number="14">    <span class="kw">for</span> _, el := <span class="kw">range</span> al.Elements {</a>
<a class="sourceLine" id="cb387-15" data-line-number="15">        elements = <span class="bu">append</span>(elements, el.String())</a>
<a class="sourceLine" id="cb387-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb387-17" data-line-number="17"></a>
<a class="sourceLine" id="cb387-18" data-line-number="18">    out.WriteString(<span class="st">&quot;[&quot;</span>)</a>
<a class="sourceLine" id="cb387-19" data-line-number="19">    out.WriteString(strings.Join(elements, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb387-20" data-line-number="20">    out.WriteString(<span class="st">&quot;]&quot;</span>)</a>
<a class="sourceLine" id="cb387-21" data-line-number="21"></a>
<a class="sourceLine" id="cb387-22" data-line-number="22">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb387-23" data-line-number="23">}</a></code></pre></div>
<p>The following test function makes sure that parsing array literals results in a <code>*ast.ArrayLiteral</code> being returned. (I also added a test function for empty array literals to make sure that we don’t run into nasty edge-cases)</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb388-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb388-2" data-line-number="2"></a>
<a class="sourceLine" id="cb388-3" data-line-number="3"><span class="kw">func</span> TestParsingArrayLiterals(t *testing.T) {</a>
<a class="sourceLine" id="cb388-4" data-line-number="4">    input := <span class="st">&quot;[1, 2 * 2, 3 + 3]&quot;</span></a>
<a class="sourceLine" id="cb388-5" data-line-number="5"></a>
<a class="sourceLine" id="cb388-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb388-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb388-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb388-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb388-10" data-line-number="10"></a>
<a class="sourceLine" id="cb388-11" data-line-number="11">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb388-12" data-line-number="12">    array, ok := stmt.Expression.(*ast.ArrayLiteral)</a>
<a class="sourceLine" id="cb388-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb388-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp not ast.ArrayLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb388-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb388-16" data-line-number="16"></a>
<a class="sourceLine" id="cb388-17" data-line-number="17">    <span class="kw">if</span> <span class="bu">len</span>(array.Elements) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb388-18" data-line-number="18">        t.Fatalf(<span class="st">&quot;len(array.Elements) not 3. got=%d&quot;</span>, <span class="bu">len</span>(array.Elements))</a>
<a class="sourceLine" id="cb388-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb388-20" data-line-number="20"></a>
<a class="sourceLine" id="cb388-21" data-line-number="21">    testIntegerLiteral(t, array.Elements[<span class="dv">0</span>], <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb388-22" data-line-number="22">    testInfixExpression(t, array.Elements[<span class="dv">1</span>], <span class="dv">2</span>, <span class="st">&quot;*&quot;</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb388-23" data-line-number="23">    testInfixExpression(t, array.Elements[<span class="dv">2</span>], <span class="dv">3</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb388-24" data-line-number="24">}</a></code></pre></div>
<p>Just to make sure that the parsing of expressions really works the test input contains two different infix operator expressions, even though integer or boolean literals would be enough. Other than that the test is pretty boring and asserts that the parser really returns an <code>*ast.ArrayLiteral</code> with the correct number of elements.</p>
<p>In order to get the tests to pass we need to register a new <code>prefixParseFn</code> in our parser, since the opening <code>token.LBRACKET</code> of an array literal is in prefix position.</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb389-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb389-2" data-line-number="2"></a>
<a class="sourceLine" id="cb389-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb389-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb389-5" data-line-number="5"></a>
<a class="sourceLine" id="cb389-6" data-line-number="6">    p.registerPrefix(token.LBRACKET, p.parseArrayLiteral)</a>
<a class="sourceLine" id="cb389-7" data-line-number="7"></a>
<a class="sourceLine" id="cb389-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb389-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb389-10" data-line-number="10"></a>
<a class="sourceLine" id="cb389-11" data-line-number="11"><span class="kw">func</span> (p *Parser) parseArrayLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb389-12" data-line-number="12">    array := &amp;ast.ArrayLiteral{Token: p.curToken}</a>
<a class="sourceLine" id="cb389-13" data-line-number="13"></a>
<a class="sourceLine" id="cb389-14" data-line-number="14">    array.Elements = p.parseExpressionList(token.RBRACKET)</a>
<a class="sourceLine" id="cb389-15" data-line-number="15"></a>
<a class="sourceLine" id="cb389-16" data-line-number="16">    <span class="kw">return</span> array</a>
<a class="sourceLine" id="cb389-17" data-line-number="17">}</a></code></pre></div>
<p>We’ve added <code>prefixParseFn</code>s before, so that part’s not really exciting. What’s interesting here is the new method called <code>parseExpressionList</code>. This method is a modified and generalized version of <code>parseCallArguments</code>, which we used before in <code>parseCallExpression</code> to parse a list of comma separated arguments:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb390-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb390-2" data-line-number="2"></a>
<a class="sourceLine" id="cb390-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseExpressionList(end token.TokenType) []ast.Expression {</a>
<a class="sourceLine" id="cb390-4" data-line-number="4">    list := []ast.Expression{}</a>
<a class="sourceLine" id="cb390-5" data-line-number="5"></a>
<a class="sourceLine" id="cb390-6" data-line-number="6">    <span class="kw">if</span> p.peekTokenIs(end) {</a>
<a class="sourceLine" id="cb390-7" data-line-number="7">        p.nextToken()</a>
<a class="sourceLine" id="cb390-8" data-line-number="8">        <span class="kw">return</span> list</a>
<a class="sourceLine" id="cb390-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb390-10" data-line-number="10"></a>
<a class="sourceLine" id="cb390-11" data-line-number="11">    p.nextToken()</a>
<a class="sourceLine" id="cb390-12" data-line-number="12">    list = <span class="bu">append</span>(list, p.parseExpression(LOWEST))</a>
<a class="sourceLine" id="cb390-13" data-line-number="13"></a>
<a class="sourceLine" id="cb390-14" data-line-number="14">    <span class="kw">for</span> p.peekTokenIs(token.COMMA) {</a>
<a class="sourceLine" id="cb390-15" data-line-number="15">        p.nextToken()</a>
<a class="sourceLine" id="cb390-16" data-line-number="16">        p.nextToken()</a>
<a class="sourceLine" id="cb390-17" data-line-number="17">        list = <span class="bu">append</span>(list, p.parseExpression(LOWEST))</a>
<a class="sourceLine" id="cb390-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb390-19" data-line-number="19"></a>
<a class="sourceLine" id="cb390-20" data-line-number="20">    <span class="kw">if</span> !p.expectPeek(end) {</a>
<a class="sourceLine" id="cb390-21" data-line-number="21">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb390-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb390-23" data-line-number="23"></a>
<a class="sourceLine" id="cb390-24" data-line-number="24">    <span class="kw">return</span> list</a>
<a class="sourceLine" id="cb390-25" data-line-number="25">}</a></code></pre></div>
<p>Again, we’ve seen this before under the name <code>parseCallArguments</code>. The only change is that this new version now accepts an <code>end</code> parameter that tells the method which token signifies the end of the list. The updated <code>parseCallExpression</code> method, in which we used <code>parseCallArguments</code> before, now looks like this:</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb391-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb391-2" data-line-number="2"></a>
<a class="sourceLine" id="cb391-3" data-line-number="3"><span class="kw">func</span> (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb391-4" data-line-number="4">    exp := &amp;ast.CallExpression{Token: p.curToken, Function: function}</a>
<a class="sourceLine" id="cb391-5" data-line-number="5">    exp.Arguments = p.parseExpressionList(token.RPAREN)</a>
<a class="sourceLine" id="cb391-6" data-line-number="6">    <span class="kw">return</span> exp</a>
<a class="sourceLine" id="cb391-7" data-line-number="7">}</a></code></pre></div>
<p>The only change is the call to <code>parseExpressionList</code> with <code>token.RPAREN</code> (which signifies the end of the arguments list). We could reuse a relatively big method by changing a few lines. Great! And the best of all? The tests are passing:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb392-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb392-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>We can mark “parsing array literals” as “done”.</p>
<h3 id="parsing-index-operator-expressions">Parsing Index Operator Expressions</h3>
<p>To fully support arrays in Monkey we not only need to be able to parse array literals but also index operator expressions. Maybe the name “index operator” doesn’t ring a bell, but I bet you know what it is. Index operator expressions look like this:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb393-1" data-line-number="1">myArray[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb393-2" data-line-number="2">myArray[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb393-3" data-line-number="3">myArray[<span class="dv">2</span>]<span class="op">;</span></a></code></pre></div>
<p>That’s the basic form at least, but there are many. Take a look at these examples to spot the structure underlying them all:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb394-1" data-line-number="1">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>][<span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb394-2" data-line-number="2"></a>
<a class="sourceLine" id="cb394-3" data-line-number="3"><span class="kw">let</span> myArray <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb394-4" data-line-number="4">myArray[<span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb394-5" data-line-number="5"></a>
<a class="sourceLine" id="cb394-6" data-line-number="6">myArray[<span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb394-7" data-line-number="7"></a>
<a class="sourceLine" id="cb394-8" data-line-number="8"><span class="at">returnsArray</span>()[<span class="dv">1</span>]<span class="op">;</span></a></code></pre></div>
<p>Yep, you’re totally correct! The basic structure is this one:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb395-1" data-line-number="1">&lt;expression&gt;[&lt;expression&gt;]</a></code></pre></div>
<p>That seems simple enough. We can define a new AST node, called <code>ast.IndexExpression</code>, that reflects this structure:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb396-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb396-2" data-line-number="2"></a>
<a class="sourceLine" id="cb396-3" data-line-number="3"><span class="kw">type</span> IndexExpression <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb396-4" data-line-number="4">    Token token.Token <span class="co">// The [ token</span></a>
<a class="sourceLine" id="cb396-5" data-line-number="5">    Left  Expression</a>
<a class="sourceLine" id="cb396-6" data-line-number="6">    Index Expression</a>
<a class="sourceLine" id="cb396-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb396-8" data-line-number="8"></a>
<a class="sourceLine" id="cb396-9" data-line-number="9"><span class="kw">func</span> (ie *IndexExpression) expressionNode()      {}</a>
<a class="sourceLine" id="cb396-10" data-line-number="10"><span class="kw">func</span> (ie *IndexExpression) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> ie.Token.Literal }</a>
<a class="sourceLine" id="cb396-11" data-line-number="11"><span class="kw">func</span> (ie *IndexExpression) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb396-12" data-line-number="12">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb396-13" data-line-number="13"></a>
<a class="sourceLine" id="cb396-14" data-line-number="14">    out.WriteString(<span class="st">&quot;(&quot;</span>)</a>
<a class="sourceLine" id="cb396-15" data-line-number="15">    out.WriteString(ie.Left.String())</a>
<a class="sourceLine" id="cb396-16" data-line-number="16">    out.WriteString(<span class="st">&quot;[&quot;</span>)</a>
<a class="sourceLine" id="cb396-17" data-line-number="17">    out.WriteString(ie.Index.String())</a>
<a class="sourceLine" id="cb396-18" data-line-number="18">    out.WriteString(<span class="st">&quot;])&quot;</span>)</a>
<a class="sourceLine" id="cb396-19" data-line-number="19"></a>
<a class="sourceLine" id="cb396-20" data-line-number="20">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb396-21" data-line-number="21">}</a></code></pre></div>
<p>It’s important to note that both <code>Left</code> and <code>Index</code> are just <code>Expression</code>s. <code>Left</code> is the object that’s being accessed and we’ve seen that it can be of any type: an identifier, an array literal, a function call. The same goes for <code>Index</code>. It can be any expression. Syntactically it doesn’t make a difference which one it is, but semantically it has to produce an integer.</p>
<p>The fact that both <code>Left</code> and <code>Index</code> are expressions makes the parsing process easier, because we can use our <code>parseExpression</code> method to parse them. But first things first! Here is the test case that makes sure our parser knows how to return an <code>*ast.IndexExpression</code>:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb397-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb397-2" data-line-number="2"></a>
<a class="sourceLine" id="cb397-3" data-line-number="3"><span class="kw">func</span> TestParsingIndexExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb397-4" data-line-number="4">    input := <span class="st">&quot;myArray[1 + 1]&quot;</span></a>
<a class="sourceLine" id="cb397-5" data-line-number="5"></a>
<a class="sourceLine" id="cb397-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb397-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb397-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb397-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb397-10" data-line-number="10"></a>
<a class="sourceLine" id="cb397-11" data-line-number="11">    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb397-12" data-line-number="12">    indexExp, ok := stmt.Expression.(*ast.IndexExpression)</a>
<a class="sourceLine" id="cb397-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb397-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp not *ast.IndexExpression. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb397-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb397-16" data-line-number="16"></a>
<a class="sourceLine" id="cb397-17" data-line-number="17">    <span class="kw">if</span> !testIdentifier(t, indexExp.Left, <span class="st">&quot;myArray&quot;</span>) {</a>
<a class="sourceLine" id="cb397-18" data-line-number="18">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb397-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb397-20" data-line-number="20"></a>
<a class="sourceLine" id="cb397-21" data-line-number="21">    <span class="kw">if</span> !testInfixExpression(t, indexExp.Index, <span class="dv">1</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb397-22" data-line-number="22">        <span class="kw">return</span></a>
<a class="sourceLine" id="cb397-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb397-24" data-line-number="24">}</a></code></pre></div>
<p>Now, this test only asserts that the parser outputs the correct AST for a single expression statement containing an index expression. But equally important is that the parser handles the precedence of the index operator correctly. The index operator has to have the highest precedence of all operators yet. Making sure of that is as easy as extending our existing <code>TestOperatorPrecedenceParsing</code> test function:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb398-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb398-2" data-line-number="2"></a>
<a class="sourceLine" id="cb398-3" data-line-number="3"><span class="kw">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</a>
<a class="sourceLine" id="cb398-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb398-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb398-6" data-line-number="6">        expected <span class="dt">string</span></a>
<a class="sourceLine" id="cb398-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb398-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb398-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb398-10" data-line-number="10">            <span class="st">&quot;a * [1, 2, 3, 4][b * c] * d&quot;</span>,</a>
<a class="sourceLine" id="cb398-11" data-line-number="11">            <span class="st">&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;</span>,</a>
<a class="sourceLine" id="cb398-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb398-13" data-line-number="13">        {</a>
<a class="sourceLine" id="cb398-14" data-line-number="14">            <span class="st">&quot;add(a * b[2], b[1], 2 * [1, 2][1])&quot;</span>,</a>
<a class="sourceLine" id="cb398-15" data-line-number="15">            <span class="st">&quot;add((a * (b[2])), (b[1]), (2 * ([1, 2][1])))&quot;</span>,</a>
<a class="sourceLine" id="cb398-16" data-line-number="16">        },</a>
<a class="sourceLine" id="cb398-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb398-18" data-line-number="18"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb398-19" data-line-number="19">}</a></code></pre></div>
<p>The additional <code>(</code> and <code>)</code> in the <code>String()</code> output of <code>*ast.IndexExpression</code> help us when writing these tests, since they make the precedence of the index operator visible. In these added test cases we expect that the precedence of the index operator is higher than the precedence of call expressions or even the <code>*</code> operator in infix expressions.</p>
<p>The tests fail because the parser doesn’t know anything about index expressions yet:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb399-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb399-2" data-line-number="2">--- FAIL: TestOperatorPrecedenceParsing (0.00s)</a>
<a class="sourceLine" id="cb399-3" data-line-number="3">  parser_test.go:393: expected=&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;,\</a>
<a class="sourceLine" id="cb399-4" data-line-number="4">    got=&quot;(a * [1, 2, 3, 4])([(b * c)] * d)&quot;</a>
<a class="sourceLine" id="cb399-5" data-line-number="5">  parser_test.go:968: parser has 4 errors</a>
<a class="sourceLine" id="cb399-6" data-line-number="6">  parser_test.go:970: parser error: &quot;expected next token to be ), got [ instead&quot;</a>
<a class="sourceLine" id="cb399-7" data-line-number="7">  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb399-8" data-line-number="8">  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb399-9" data-line-number="9">  parser_test.go:970: parser error: &quot;no prefix parse function for ) found&quot;</a>
<a class="sourceLine" id="cb399-10" data-line-number="10">--- FAIL: TestParsingIndexExpressions (0.00s)</a>
<a class="sourceLine" id="cb399-11" data-line-number="11">  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier</a>
<a class="sourceLine" id="cb399-12" data-line-number="12">FAIL</a>
<a class="sourceLine" id="cb399-13" data-line-number="13">FAIL    monkey/parser   0.007s</a></code></pre></div>
<p>Even though the tests complain about a missing <code>prefixParseFn</code> what we want is an <code>infixParseFn</code>. Yes, index operator expressions do not really have a single operator between operands on each side. But in order to parse them without a lot of trouble it’s of advantage to act like they do, just like we did with call expressions. Specifically, that means treating the <code>[</code> in <code>myArray[0]</code> as the infix operator, <code>myArray</code> as the left operand and <code>0</code> as the right operand.</p>
<p>Doing this makes the implementation fit really nicely into our parser:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb400-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb400-2" data-line-number="2"></a>
<a class="sourceLine" id="cb400-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb400-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb400-5" data-line-number="5"></a>
<a class="sourceLine" id="cb400-6" data-line-number="6">    p.registerInfix(token.LBRACKET, p.parseIndexExpression)</a>
<a class="sourceLine" id="cb400-7" data-line-number="7"></a>
<a class="sourceLine" id="cb400-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb400-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb400-10" data-line-number="10"></a>
<a class="sourceLine" id="cb400-11" data-line-number="11"><span class="kw">func</span> (p *Parser) parseIndexExpression(left ast.Expression) ast.Expression {</a>
<a class="sourceLine" id="cb400-12" data-line-number="12">    exp := &amp;ast.IndexExpression{Token: p.curToken, Left: left}</a>
<a class="sourceLine" id="cb400-13" data-line-number="13"></a>
<a class="sourceLine" id="cb400-14" data-line-number="14">    p.nextToken()</a>
<a class="sourceLine" id="cb400-15" data-line-number="15">    exp.Index = p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb400-16" data-line-number="16"></a>
<a class="sourceLine" id="cb400-17" data-line-number="17">    <span class="kw">if</span> !p.expectPeek(token.RBRACKET) {</a>
<a class="sourceLine" id="cb400-18" data-line-number="18">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb400-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb400-20" data-line-number="20"></a>
<a class="sourceLine" id="cb400-21" data-line-number="21">    <span class="kw">return</span> exp</a>
<a class="sourceLine" id="cb400-22" data-line-number="22">}</a></code></pre></div>
<p>Neat! But that doesn’t fix our tests:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb401-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb401-2" data-line-number="2">--- FAIL: TestOperatorPrecedenceParsing (0.00s)</a>
<a class="sourceLine" id="cb401-3" data-line-number="3">  parser_test.go:393: expected=&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;,\</a>
<a class="sourceLine" id="cb401-4" data-line-number="4">    got=&quot;(a * [1, 2, 3, 4])([(b * c)] * d)&quot;</a>
<a class="sourceLine" id="cb401-5" data-line-number="5">  parser_test.go:968: parser has 4 errors</a>
<a class="sourceLine" id="cb401-6" data-line-number="6">  parser_test.go:970: parser error: &quot;expected next token to be ), got [ instead&quot;</a>
<a class="sourceLine" id="cb401-7" data-line-number="7">  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb401-8" data-line-number="8">  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</a>
<a class="sourceLine" id="cb401-9" data-line-number="9">  parser_test.go:970: parser error: &quot;no prefix parse function for ) found&quot;</a>
<a class="sourceLine" id="cb401-10" data-line-number="10">--- FAIL: TestParsingIndexExpressions (0.00s)</a>
<a class="sourceLine" id="cb401-11" data-line-number="11">  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier</a>
<a class="sourceLine" id="cb401-12" data-line-number="12">FAIL</a>
<a class="sourceLine" id="cb401-13" data-line-number="13">FAIL    monkey/parser   0.008s</a></code></pre></div>
<p>That’s because the whole idea behind our Pratt parser hinges on the idea of precedences and we haven’t defined the precedence of our index operator yet:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb402-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb402-2" data-line-number="2"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb402-3" data-line-number="3">    _ <span class="dt">int</span> = <span class="ot">iota</span></a>
<a class="sourceLine" id="cb402-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb402-5" data-line-number="5">    INDEX       <span class="co">// array[index]</span></a>
<a class="sourceLine" id="cb402-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb402-7" data-line-number="7"></a>
<a class="sourceLine" id="cb402-8" data-line-number="8"><span class="kw">var</span> precedences = <span class="kw">map</span>[token.TokenType]<span class="dt">int</span>{</a>
<a class="sourceLine" id="cb402-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb402-10" data-line-number="10">    token.LBRACKET: INDEX,</a>
<a class="sourceLine" id="cb402-11" data-line-number="11">}</a></code></pre></div>
<p>It’s important that the definition of <code>INDEX</code> is the last line in the <code>const</code> block. That gives <code>INDEX</code> the highest value of all defined precedence constants, thanks to the <code>iota</code>. The added entry in <code>precedences</code> gives <code>token.LBRACKET</code> this highest precedence of all, <code>INDEX</code>. And, well, it does wonders:</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb403-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb403-2" data-line-number="2">ok      monkey/parser   0.007s</a></code></pre></div>
<p>Lexer done, parser done. See you in the evaluator!</p>
<h3 id="evaluating-array-literals">Evaluating Array Literals</h3>
<p>Evaluating array literals is not hard. Mapping Monkey arrays to Go’s slices makes life pretty, pretty sweet. We don’t have to implement a new data structure. We only need to define a new <code>object.Array</code> type, since that’s what the evaluation of array literals produces. And the definition of <code>object.Array</code> is simple, since arrays in Monkey are simple: they are just a list of objects.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb404-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb404-2" data-line-number="2"></a>
<a class="sourceLine" id="cb404-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb404-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb404-5" data-line-number="5">    ARRAY_OBJ = <span class="st">&quot;ARRAY&quot;</span></a>
<a class="sourceLine" id="cb404-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb404-7" data-line-number="7"></a>
<a class="sourceLine" id="cb404-8" data-line-number="8"><span class="kw">type</span> Array <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb404-9" data-line-number="9">    Elements []Object</a>
<a class="sourceLine" id="cb404-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb404-11" data-line-number="11"></a>
<a class="sourceLine" id="cb404-12" data-line-number="12"><span class="kw">func</span> (ao *Array) Type() ObjectType { <span class="kw">return</span> ARRAY_OBJ }</a>
<a class="sourceLine" id="cb404-13" data-line-number="13"><span class="kw">func</span> (ao *Array) Inspect() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb404-14" data-line-number="14">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb404-15" data-line-number="15"></a>
<a class="sourceLine" id="cb404-16" data-line-number="16">    elements := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb404-17" data-line-number="17">    <span class="kw">for</span> _, e := <span class="kw">range</span> ao.Elements {</a>
<a class="sourceLine" id="cb404-18" data-line-number="18">        elements = <span class="bu">append</span>(elements, e.Inspect())</a>
<a class="sourceLine" id="cb404-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb404-20" data-line-number="20"></a>
<a class="sourceLine" id="cb404-21" data-line-number="21">    out.WriteString(<span class="st">&quot;[&quot;</span>)</a>
<a class="sourceLine" id="cb404-22" data-line-number="22">    out.WriteString(strings.Join(elements, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb404-23" data-line-number="23">    out.WriteString(<span class="st">&quot;]&quot;</span>)</a>
<a class="sourceLine" id="cb404-24" data-line-number="24"></a>
<a class="sourceLine" id="cb404-25" data-line-number="25">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb404-26" data-line-number="26">}</a></code></pre></div>
<p>I think you’ll agree with me when I say that the most complicated thing about this definition is the <code>Inspect</code> method. And even that one is pretty easy to understand.</p>
<p>Here is the evaluator test for array literals:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb405-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb405-2" data-line-number="2"></a>
<a class="sourceLine" id="cb405-3" data-line-number="3"><span class="kw">func</span> TestArrayLiterals(t *testing.T) {</a>
<a class="sourceLine" id="cb405-4" data-line-number="4">    input := <span class="st">&quot;[1, 2 * 2, 3 + 3]&quot;</span></a>
<a class="sourceLine" id="cb405-5" data-line-number="5"></a>
<a class="sourceLine" id="cb405-6" data-line-number="6">    evaluated := testEval(input)</a>
<a class="sourceLine" id="cb405-7" data-line-number="7">    result, ok := evaluated.(*object.Array)</a>
<a class="sourceLine" id="cb405-8" data-line-number="8">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb405-9" data-line-number="9">        t.Fatalf(<span class="st">&quot;object is not Array. got=%T (%+v)&quot;</span>, evaluated, evaluated)</a>
<a class="sourceLine" id="cb405-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb405-11" data-line-number="11"></a>
<a class="sourceLine" id="cb405-12" data-line-number="12">    <span class="kw">if</span> <span class="bu">len</span>(result.Elements) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb405-13" data-line-number="13">        t.Fatalf(<span class="st">&quot;array has wrong num of elements. got=%d&quot;</span>,</a>
<a class="sourceLine" id="cb405-14" data-line-number="14">            <span class="bu">len</span>(result.Elements))</a>
<a class="sourceLine" id="cb405-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb405-16" data-line-number="16"></a>
<a class="sourceLine" id="cb405-17" data-line-number="17">    testIntegerObject(t, result.Elements[<span class="dv">0</span>], <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb405-18" data-line-number="18">    testIntegerObject(t, result.Elements[<span class="dv">1</span>], <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb405-19" data-line-number="19">    testIntegerObject(t, result.Elements[<span class="dv">2</span>], <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb405-20" data-line-number="20">}</a></code></pre></div>
<p>We can reuse some existing code to get this test to pass, just like we did in our parser. And again the code we’re reusing was originally written for call expressions. Here is the <code>case</code> branch that evaluates <code>*ast.ArrayLiteral</code>s and produces array objects:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb406-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb406-2" data-line-number="2"></a>
<a class="sourceLine" id="cb406-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb406-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb406-5" data-line-number="5"></a>
<a class="sourceLine" id="cb406-6" data-line-number="6">    <span class="kw">case</span> *ast.ArrayLiteral:</a>
<a class="sourceLine" id="cb406-7" data-line-number="7">        elements := evalExpressions(node.Elements, env)</a>
<a class="sourceLine" id="cb406-8" data-line-number="8">        <span class="kw">if</span> <span class="bu">len</span>(elements) == <span class="dv">1</span> &amp;&amp; isError(elements[<span class="dv">0</span>]) {</a>
<a class="sourceLine" id="cb406-9" data-line-number="9">            <span class="kw">return</span> elements[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb406-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb406-11" data-line-number="11">        <span class="kw">return</span> &amp;object.Array{Elements: elements}</a>
<a class="sourceLine" id="cb406-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb406-13" data-line-number="13"></a>
<a class="sourceLine" id="cb406-14" data-line-number="14"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb406-15" data-line-number="15">}</a></code></pre></div>
<p>Isn’t that one of the great joys of programming? Reusing existing code without having to turn it into a super generic, over-engineered spaceship.</p>
<p>The tests are passing and we can use array literals in our REPL to produce arrays:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb407-1" data-line-number="1">$ go run <span class="va">main</span>.<span class="at">go</span></a>
<a class="sourceLine" id="cb407-2" data-line-number="2">Hello mrnugget<span class="op">!</span> This is the Monkey programming language<span class="op">!</span></a>
<a class="sourceLine" id="cb407-3" data-line-number="3">Feel free to type <span class="kw">in</span> commands</a>
<a class="sourceLine" id="cb407-4" data-line-number="4"><span class="op">&gt;&gt;</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb407-5" data-line-number="5">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb407-6" data-line-number="6"><span class="op">&gt;&gt;</span> <span class="kw">let</span> double <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span> x <span class="op">*</span> <span class="dv">2</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb407-7" data-line-number="7"><span class="op">&gt;&gt;</span> [<span class="dv">1</span><span class="op">,</span> <span class="at">double</span>(<span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span> <span class="op">-</span> <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb407-8" data-line-number="8">[<span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb407-9" data-line-number="9"><span class="op">&gt;&gt;</span></a></code></pre></div>
<p>Amazing, isn’t it? But what we can’t do yet is accessing single elements of the array by using the index operator.</p>
<h3 id="evaluating-index-operator-expressions">Evaluating Index Operator Expressions</h3>
<p>Great news: much harder than evaluating index expressions is parsing them. And we already did that. The only problem left is the possibility of off-by-one errors when accessing and retrieving the elements in an array. But for that we’ll just add a few tests to our test suite:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb408-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb408-2" data-line-number="2"></a>
<a class="sourceLine" id="cb408-3" data-line-number="3"><span class="kw">func</span> TestArrayIndexExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb408-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb408-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb408-6" data-line-number="6">        expected <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb408-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb408-8" data-line-number="8">        {</a>
<a class="sourceLine" id="cb408-9" data-line-number="9">            <span class="st">&quot;[1, 2, 3][0]&quot;</span>,</a>
<a class="sourceLine" id="cb408-10" data-line-number="10">            <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb408-11" data-line-number="11">        },</a>
<a class="sourceLine" id="cb408-12" data-line-number="12">        {</a>
<a class="sourceLine" id="cb408-13" data-line-number="13">            <span class="st">&quot;[1, 2, 3][1]&quot;</span>,</a>
<a class="sourceLine" id="cb408-14" data-line-number="14">            <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb408-15" data-line-number="15">        },</a>
<a class="sourceLine" id="cb408-16" data-line-number="16">        {</a>
<a class="sourceLine" id="cb408-17" data-line-number="17">            <span class="st">&quot;[1, 2, 3][2]&quot;</span>,</a>
<a class="sourceLine" id="cb408-18" data-line-number="18">            <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb408-19" data-line-number="19">        },</a>
<a class="sourceLine" id="cb408-20" data-line-number="20">        {</a>
<a class="sourceLine" id="cb408-21" data-line-number="21">            <span class="st">&quot;let i = 0; [1][i];&quot;</span>,</a>
<a class="sourceLine" id="cb408-22" data-line-number="22">            <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb408-23" data-line-number="23">        },</a>
<a class="sourceLine" id="cb408-24" data-line-number="24">        {</a>
<a class="sourceLine" id="cb408-25" data-line-number="25">            <span class="st">&quot;[1, 2, 3][1 + 1];&quot;</span>,</a>
<a class="sourceLine" id="cb408-26" data-line-number="26">            <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb408-27" data-line-number="27">        },</a>
<a class="sourceLine" id="cb408-28" data-line-number="28">        {</a>
<a class="sourceLine" id="cb408-29" data-line-number="29">            <span class="st">&quot;let myArray = [1, 2, 3]; myArray[2];&quot;</span>,</a>
<a class="sourceLine" id="cb408-30" data-line-number="30">            <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb408-31" data-line-number="31">        },</a>
<a class="sourceLine" id="cb408-32" data-line-number="32">        {</a>
<a class="sourceLine" id="cb408-33" data-line-number="33">            <span class="st">&quot;let myArray = [1, 2, 3]; myArray[0] + myArray[1] + myArray[2];&quot;</span>,</a>
<a class="sourceLine" id="cb408-34" data-line-number="34">            <span class="dv">6</span>,</a>
<a class="sourceLine" id="cb408-35" data-line-number="35">        },</a>
<a class="sourceLine" id="cb408-36" data-line-number="36">        {</a>
<a class="sourceLine" id="cb408-37" data-line-number="37">            <span class="st">&quot;let myArray = [1, 2, 3]; let i = myArray[0]; myArray[i]&quot;</span>,</a>
<a class="sourceLine" id="cb408-38" data-line-number="38">            <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb408-39" data-line-number="39">        },</a>
<a class="sourceLine" id="cb408-40" data-line-number="40">        {</a>
<a class="sourceLine" id="cb408-41" data-line-number="41">            <span class="st">&quot;[1, 2, 3][3]&quot;</span>,</a>
<a class="sourceLine" id="cb408-42" data-line-number="42">            <span class="ot">nil</span>,</a>
<a class="sourceLine" id="cb408-43" data-line-number="43">        },</a>
<a class="sourceLine" id="cb408-44" data-line-number="44">        {</a>
<a class="sourceLine" id="cb408-45" data-line-number="45">            <span class="st">&quot;[1, 2, 3][-1]&quot;</span>,</a>
<a class="sourceLine" id="cb408-46" data-line-number="46">            <span class="ot">nil</span>,</a>
<a class="sourceLine" id="cb408-47" data-line-number="47">        },</a>
<a class="sourceLine" id="cb408-48" data-line-number="48">    }</a>
<a class="sourceLine" id="cb408-49" data-line-number="49"></a>
<a class="sourceLine" id="cb408-50" data-line-number="50">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb408-51" data-line-number="51">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb408-52" data-line-number="52">        integer, ok := tt.expected.(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb408-53" data-line-number="53">        <span class="kw">if</span> ok {</a>
<a class="sourceLine" id="cb408-54" data-line-number="54">            testIntegerObject(t, evaluated, <span class="dt">int64</span>(integer))</a>
<a class="sourceLine" id="cb408-55" data-line-number="55">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb408-56" data-line-number="56">            testNullObject(t, evaluated)</a>
<a class="sourceLine" id="cb408-57" data-line-number="57">        }</a>
<a class="sourceLine" id="cb408-58" data-line-number="58">    }</a>
<a class="sourceLine" id="cb408-59" data-line-number="59">}</a></code></pre></div>
<p>Okay, I’ll admit, these tests might seem excessive. A lot of the things we’re testing implicitly here have already been tested elsewhere. But the test cases are so easy to write! And they are so readable! I love these tests.</p>
<p>Take note of the desired behaviour these tests specify. They contain something we haven’t talked about yet: when we use an index that’s out of the arrays bounds, we’ll return <code>NULL</code>. Some languages produce an error in such a case and some return a null value. I choose to return <code>NULL</code>.</p>
<p>As expected the tests are failing. And not only that, they’re blowing up:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb409-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb409-2" data-line-number="2">--- FAIL: TestArrayIndexExpressions (0.00s)</a>
<a class="sourceLine" id="cb409-3" data-line-number="3">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-4" data-line-number="4">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-5" data-line-number="5">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-6" data-line-number="6">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-7" data-line-number="7">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-8" data-line-number="8">  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb409-9" data-line-number="9">panic: runtime error: invalid memory address or nil pointer dereference</a>
<a class="sourceLine" id="cb409-10" data-line-number="10">[signal SIGSEGV: segmentation violation code=0x1 addr=0x28 pc=0x70057]</a>
<a class="sourceLine" id="cb409-11" data-line-number="11">[redacted: backtrace here]</a>
<a class="sourceLine" id="cb409-12" data-line-number="12">FAIL    monkey/evaluator        0.011s</a></code></pre></div>
<p>So how do we fix this and evaluate index expressions? As we’ve seen, the left operand of the index operator can be any expression and the index itself can be any expression. That means we need to evaluate both before we can evaluate the “indexing” itself. Otherwise we’d try to access elements of an identifier or a function call, which doesn’t work.</p>
<p>Here is the <code>case</code> branch for <code>*ast.IndexExpression</code> that makes these desired calls to <code>Eval</code>:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb410-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb410-2" data-line-number="2"></a>
<a class="sourceLine" id="cb410-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb410-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb410-5" data-line-number="5"></a>
<a class="sourceLine" id="cb410-6" data-line-number="6">    <span class="kw">case</span> *ast.IndexExpression:</a>
<a class="sourceLine" id="cb410-7" data-line-number="7">        left := Eval(node.Left, env)</a>
<a class="sourceLine" id="cb410-8" data-line-number="8">        <span class="kw">if</span> isError(left) {</a>
<a class="sourceLine" id="cb410-9" data-line-number="9">            <span class="kw">return</span> left</a>
<a class="sourceLine" id="cb410-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb410-11" data-line-number="11">        index := Eval(node.Index, env)</a>
<a class="sourceLine" id="cb410-12" data-line-number="12">        <span class="kw">if</span> isError(index) {</a>
<a class="sourceLine" id="cb410-13" data-line-number="13">            <span class="kw">return</span> index</a>
<a class="sourceLine" id="cb410-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb410-15" data-line-number="15">        <span class="kw">return</span> evalIndexExpression(left, index)</a>
<a class="sourceLine" id="cb410-16" data-line-number="16"></a>
<a class="sourceLine" id="cb410-17" data-line-number="17"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb410-18" data-line-number="18">}</a></code></pre></div>
<p>And here is the <code>evalIndexExpression</code> function it uses:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb411-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb411-2" data-line-number="2"></a>
<a class="sourceLine" id="cb411-3" data-line-number="3"><span class="kw">func</span> evalIndexExpression(left, index object.Object) object.Object {</a>
<a class="sourceLine" id="cb411-4" data-line-number="4">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb411-5" data-line-number="5">    <span class="kw">case</span> left.Type() == object.ARRAY_OBJ &amp;&amp; index.Type() == object.INTEGER_OBJ:</a>
<a class="sourceLine" id="cb411-6" data-line-number="6">        <span class="kw">return</span> evalArrayIndexExpression(left, index)</a>
<a class="sourceLine" id="cb411-7" data-line-number="7">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb411-8" data-line-number="8">        <span class="kw">return</span> newError(<span class="st">&quot;index operator not supported: %s&quot;</span>, left.Type())</a>
<a class="sourceLine" id="cb411-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb411-10" data-line-number="10">}</a></code></pre></div>
<p>An if-conditional would do the job of the switch statement here just fine, but we’re going to add another <code>case</code> branch later in this chapter. Besides the error handling (for which I also added a test) nothing really interesting happens in this function. The meat of the operation is in <code>evalArrayIndexExpression</code>:</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb412-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb412-2" data-line-number="2"></a>
<a class="sourceLine" id="cb412-3" data-line-number="3"><span class="kw">func</span> evalArrayIndexExpression(array, index object.Object) object.Object {</a>
<a class="sourceLine" id="cb412-4" data-line-number="4">    arrayObject := array.(*object.Array)</a>
<a class="sourceLine" id="cb412-5" data-line-number="5">    idx := index.(*object.Integer).Value</a>
<a class="sourceLine" id="cb412-6" data-line-number="6">    max := <span class="dt">int64</span>(<span class="bu">len</span>(arrayObject.Elements) - <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb412-7" data-line-number="7"></a>
<a class="sourceLine" id="cb412-8" data-line-number="8">    <span class="kw">if</span> idx &lt; <span class="dv">0</span> || idx &gt; max {</a>
<a class="sourceLine" id="cb412-9" data-line-number="9">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb412-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb412-11" data-line-number="11"></a>
<a class="sourceLine" id="cb412-12" data-line-number="12">    <span class="kw">return</span> arrayObject.Elements[idx]</a>
<a class="sourceLine" id="cb412-13" data-line-number="13">}</a></code></pre></div>
<p>Here we actually retrieve the element with the specified index from the array. Besides the little type assertion and conversion dances this function is pretty straightforward: it checks if the given index is out of range and if that’s the case it returns <code>NULL</code>, otherwise the desired element. Just like we specified in our tests, which are now passing:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb413-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb413-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>Okay, now take a deep breath, relax and take a look at this:</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb414-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb414-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb414-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb414-4" data-line-number="4">&gt;&gt; let a = [1, 2 * 2, 10 - 5, 8 / 2];</a>
<a class="sourceLine" id="cb414-5" data-line-number="5">&gt;&gt; a[0]</a>
<a class="sourceLine" id="cb414-6" data-line-number="6">1</a>
<a class="sourceLine" id="cb414-7" data-line-number="7">&gt;&gt; a[1]</a>
<a class="sourceLine" id="cb414-8" data-line-number="8">4</a>
<a class="sourceLine" id="cb414-9" data-line-number="9">&gt;&gt; a[5 - 3]</a>
<a class="sourceLine" id="cb414-10" data-line-number="10">5</a>
<a class="sourceLine" id="cb414-11" data-line-number="11">&gt;&gt; a[99]</a>
<a class="sourceLine" id="cb414-12" data-line-number="12">null</a></code></pre></div>
<p>Retrieving elements from an array works! Sweet! I can only repeat myself here: it’s amazing how easy it was to implement this language feature, isn’t it?</p>
<h3 id="adding-built-in-functions-for-arrays">Adding Built-in Functions for Arrays</h3>
<p>We are now able to construct arrays by using array literals. And we can access single elements by using index expressions. Just those two things alone make arrays quite useful to have. But in order to make them even more useful, we need to add a few built-in functions that make working with them more convenient. In this sub-section we’re going to do exactly that.</p>
<p>I won’t be showing any test code and test cases in this section. The reason is that these particular tests take up space without adding anything new. Our “framework” for testing built-in functions is already in place with <code>TestBuiltinFunctions</code> and the added tests follow the existing scheme. You can find them in the accompanying code.</p>
<p>Our goal is to add new built-in functions. But the first thing we actually have to do is not adding a new one but changing an existing function. We need to add support for arrays to <code>len</code>, which only supported strings until now:</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb415-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb415-2" data-line-number="2"></a>
<a class="sourceLine" id="cb415-3" data-line-number="3"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb415-4" data-line-number="4">    <span class="st">&quot;len&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb415-5" data-line-number="5">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb415-6" data-line-number="6">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb415-7" data-line-number="7">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</a>
<a class="sourceLine" id="cb415-8" data-line-number="8">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb415-9" data-line-number="9">            }</a>
<a class="sourceLine" id="cb415-10" data-line-number="10"></a>
<a class="sourceLine" id="cb415-11" data-line-number="11">            <span class="kw">switch</span> arg := args[<span class="dv">0</span>].(<span class="kw">type</span>) {</a>
<a class="sourceLine" id="cb415-12" data-line-number="12">            <span class="kw">case</span> *object.Array:</a>
<a class="sourceLine" id="cb415-13" data-line-number="13">                <span class="kw">return</span> &amp;object.Integer{Value: <span class="dt">int64</span>(<span class="bu">len</span>(arg.Elements))}</a>
<a class="sourceLine" id="cb415-14" data-line-number="14">            <span class="kw">case</span> *object.String:</a>
<a class="sourceLine" id="cb415-15" data-line-number="15">                <span class="kw">return</span> &amp;object.Integer{Value: <span class="dt">int64</span>(<span class="bu">len</span>(arg.Value))}</a>
<a class="sourceLine" id="cb415-16" data-line-number="16">            <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb415-17" data-line-number="17">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `len` not supported, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb415-18" data-line-number="18">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb415-19" data-line-number="19">            }</a>
<a class="sourceLine" id="cb415-20" data-line-number="20">        },</a>
<a class="sourceLine" id="cb415-21" data-line-number="21">    },</a>
<a class="sourceLine" id="cb415-22" data-line-number="22">}</a></code></pre></div>
<p>The only change is the added <code>case</code> branch for <code>*object.Array</code>. And with that out of the way, we’re ready to start adding new functions. Yay!</p>
<p>The first of these new built-in functions is <code>first</code>. <code>first</code> returns the first element of the given array. Yes, calling <code>myArray[0]</code> does the same thing. But <code>first</code> is arguably prettier. Here is its implementation:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb416-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb416-2" data-line-number="2"></a>
<a class="sourceLine" id="cb416-3" data-line-number="3"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb416-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb416-5" data-line-number="5"></a>
<a class="sourceLine" id="cb416-6" data-line-number="6">    <span class="st">&quot;first&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb416-7" data-line-number="7">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb416-8" data-line-number="8">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb416-9" data-line-number="9">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</a>
<a class="sourceLine" id="cb416-10" data-line-number="10">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb416-11" data-line-number="11">            }</a>
<a class="sourceLine" id="cb416-12" data-line-number="12">            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != object.ARRAY_OBJ {</a>
<a class="sourceLine" id="cb416-13" data-line-number="13">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `first` must be ARRAY, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb416-14" data-line-number="14">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb416-15" data-line-number="15">            }</a>
<a class="sourceLine" id="cb416-16" data-line-number="16"></a>
<a class="sourceLine" id="cb416-17" data-line-number="17">            arr := args[<span class="dv">0</span>].(*object.Array)</a>
<a class="sourceLine" id="cb416-18" data-line-number="18">            <span class="kw">if</span> <span class="bu">len</span>(arr.Elements) &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb416-19" data-line-number="19">                <span class="kw">return</span> arr.Elements[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb416-20" data-line-number="20">            }</a>
<a class="sourceLine" id="cb416-21" data-line-number="21"></a>
<a class="sourceLine" id="cb416-22" data-line-number="22">            <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb416-23" data-line-number="23">        },</a>
<a class="sourceLine" id="cb416-24" data-line-number="24">    },</a>
<a class="sourceLine" id="cb416-25" data-line-number="25">}</a></code></pre></div>
<p>Great! That works! And what comes after <code>first</code>? You’re correct, the next function we’re going to add is called <code>last</code>.</p>
<p>The purpose of <code>last</code> is to return the last element of the given array. In index operator terms it returns <code>myArray[len(myArray)-1]</code>. And as it turns out, implementing <code>last</code> is not much harder than implementing <code>first</code> - who would have thought that? Here it is:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb417-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb417-2" data-line-number="2"></a>
<a class="sourceLine" id="cb417-3" data-line-number="3"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb417-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb417-5" data-line-number="5"></a>
<a class="sourceLine" id="cb417-6" data-line-number="6">    <span class="st">&quot;last&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb417-7" data-line-number="7">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb417-8" data-line-number="8">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb417-9" data-line-number="9">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</a>
<a class="sourceLine" id="cb417-10" data-line-number="10">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb417-11" data-line-number="11">            }</a>
<a class="sourceLine" id="cb417-12" data-line-number="12">            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != object.ARRAY_OBJ {</a>
<a class="sourceLine" id="cb417-13" data-line-number="13">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `last` must be ARRAY, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb417-14" data-line-number="14">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb417-15" data-line-number="15">            }</a>
<a class="sourceLine" id="cb417-16" data-line-number="16"></a>
<a class="sourceLine" id="cb417-17" data-line-number="17">            arr := args[<span class="dv">0</span>].(*object.Array)</a>
<a class="sourceLine" id="cb417-18" data-line-number="18">            length := <span class="bu">len</span>(arr.Elements)</a>
<a class="sourceLine" id="cb417-19" data-line-number="19">            <span class="kw">if</span> length &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb417-20" data-line-number="20">                <span class="kw">return</span> arr.Elements[length<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb417-21" data-line-number="21">            }</a>
<a class="sourceLine" id="cb417-22" data-line-number="22"></a>
<a class="sourceLine" id="cb417-23" data-line-number="23">            <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb417-24" data-line-number="24">        },</a>
<a class="sourceLine" id="cb417-25" data-line-number="25">    },</a>
<a class="sourceLine" id="cb417-26" data-line-number="26">}</a></code></pre></div>
<p>The next function we’re going to add would be called <code>cdr</code> in Scheme. In some other languages it’s sometimes called <code>tail</code>. We’re going to call it <code>rest</code>. <code>rest</code> returns a new array containing all elements of the array passed as argument, <em>except the first one</em>. Here’s what using it looks like:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb418-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb418-2" data-line-number="2"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(a)</a>
<a class="sourceLine" id="cb418-3" data-line-number="3">[<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb418-4" data-line-number="4"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(<span class="at">rest</span>(a))</a>
<a class="sourceLine" id="cb418-5" data-line-number="5">[<span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb418-6" data-line-number="6"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(a)))</a>
<a class="sourceLine" id="cb418-7" data-line-number="7">[<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb418-8" data-line-number="8"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(a))))</a>
<a class="sourceLine" id="cb418-9" data-line-number="9">[]</a>
<a class="sourceLine" id="cb418-10" data-line-number="10"><span class="op">&gt;&gt;</span> <span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(<span class="at">rest</span>(a)))))</a>
<a class="sourceLine" id="cb418-11" data-line-number="11"><span class="kw">null</span></a></code></pre></div>
<p>Its implementation is simple, but keep in mind that we’re returning a <em>newly allocated</em> array. We’re not modifying the array passed to <code>rest</code>:</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb419-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb419-2" data-line-number="2"></a>
<a class="sourceLine" id="cb419-3" data-line-number="3"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb419-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb419-5" data-line-number="5"></a>
<a class="sourceLine" id="cb419-6" data-line-number="6">    <span class="st">&quot;rest&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb419-7" data-line-number="7">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb419-8" data-line-number="8">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb419-9" data-line-number="9">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</a>
<a class="sourceLine" id="cb419-10" data-line-number="10">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb419-11" data-line-number="11">            }</a>
<a class="sourceLine" id="cb419-12" data-line-number="12">            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != object.ARRAY_OBJ {</a>
<a class="sourceLine" id="cb419-13" data-line-number="13">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `rest` must be ARRAY, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb419-14" data-line-number="14">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb419-15" data-line-number="15">            }</a>
<a class="sourceLine" id="cb419-16" data-line-number="16"></a>
<a class="sourceLine" id="cb419-17" data-line-number="17">            arr := args[<span class="dv">0</span>].(*object.Array)</a>
<a class="sourceLine" id="cb419-18" data-line-number="18">            length := <span class="bu">len</span>(arr.Elements)</a>
<a class="sourceLine" id="cb419-19" data-line-number="19">            <span class="kw">if</span> length &gt; <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb419-20" data-line-number="20">                newElements := <span class="bu">make</span>([]object.Object, length<span class="dv">-1</span>, length<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb419-21" data-line-number="21">                <span class="bu">copy</span>(newElements, arr.Elements[<span class="dv">1</span>:length])</a>
<a class="sourceLine" id="cb419-22" data-line-number="22">                <span class="kw">return</span> &amp;object.Array{Elements: newElements}</a>
<a class="sourceLine" id="cb419-23" data-line-number="23">            }</a>
<a class="sourceLine" id="cb419-24" data-line-number="24"></a>
<a class="sourceLine" id="cb419-25" data-line-number="25">            <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb419-26" data-line-number="26">        },</a>
<a class="sourceLine" id="cb419-27" data-line-number="27">    },</a>
<a class="sourceLine" id="cb419-28" data-line-number="28">}</a></code></pre></div>
<p>The last array function we’re going to build into our interpreter is called <code>push</code>. It adds a new element to the end of the array. But, and here’s the kicker, it doesn’t modify the given array. Instead it allocates a new array with the same elements as the old one plus the new, pushed element. Arrays are immutable in Monkey. Here is <code>push</code> in action:</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb420-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb420-2" data-line-number="2"><span class="op">&gt;&gt;</span> <span class="kw">let</span> b <span class="op">=</span> <span class="at">push</span>(a<span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb420-3" data-line-number="3"><span class="op">&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb420-4" data-line-number="4">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb420-5" data-line-number="5"><span class="op">&gt;&gt;</span> b</a>
<a class="sourceLine" id="cb420-6" data-line-number="6">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]</a></code></pre></div>
<p>And here is its implementation:</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb421-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb421-2" data-line-number="2"></a>
<a class="sourceLine" id="cb421-3" data-line-number="3"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb421-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb421-5" data-line-number="5"></a>
<a class="sourceLine" id="cb421-6" data-line-number="6">    <span class="st">&quot;push&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb421-7" data-line-number="7">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb421-8" data-line-number="8">            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">2</span> {</a>
<a class="sourceLine" id="cb421-9" data-line-number="9">                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=2&quot;</span>,</a>
<a class="sourceLine" id="cb421-10" data-line-number="10">                    <span class="bu">len</span>(args))</a>
<a class="sourceLine" id="cb421-11" data-line-number="11">            }</a>
<a class="sourceLine" id="cb421-12" data-line-number="12">            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != object.ARRAY_OBJ {</a>
<a class="sourceLine" id="cb421-13" data-line-number="13">                <span class="kw">return</span> newError(<span class="st">&quot;argument to `push` must be ARRAY, got %s&quot;</span>,</a>
<a class="sourceLine" id="cb421-14" data-line-number="14">                    args[<span class="dv">0</span>].Type())</a>
<a class="sourceLine" id="cb421-15" data-line-number="15">            }</a>
<a class="sourceLine" id="cb421-16" data-line-number="16"></a>
<a class="sourceLine" id="cb421-17" data-line-number="17">            arr := args[<span class="dv">0</span>].(*object.Array)</a>
<a class="sourceLine" id="cb421-18" data-line-number="18">            length := <span class="bu">len</span>(arr.Elements)</a>
<a class="sourceLine" id="cb421-19" data-line-number="19"></a>
<a class="sourceLine" id="cb421-20" data-line-number="20">            newElements := <span class="bu">make</span>([]object.Object, length+<span class="dv">1</span>, length+<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb421-21" data-line-number="21">            <span class="bu">copy</span>(newElements, arr.Elements)</a>
<a class="sourceLine" id="cb421-22" data-line-number="22">            newElements[length] = args[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb421-23" data-line-number="23"></a>
<a class="sourceLine" id="cb421-24" data-line-number="24">            <span class="kw">return</span> &amp;object.Array{Elements: newElements}</a>
<a class="sourceLine" id="cb421-25" data-line-number="25">        },</a>
<a class="sourceLine" id="cb421-26" data-line-number="26">    },</a>
<a class="sourceLine" id="cb421-27" data-line-number="27">}</a></code></pre></div>
<h3 id="test-driving-arrays">Test-Driving Arrays</h3>
<p>We now have array literals, the index operator and a few built-in functions to work with arrays. It’s time to take them for a spin. Let’s see what they can do.</p>
<p>With <code>first</code>, <code>rest</code> and <code>push</code> we can build a <code>map</code> function:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb422-1" data-line-number="1"><span class="kw">let</span> map <span class="op">=</span> <span class="at">fn</span>(arr<span class="op">,</span> f) <span class="op">{</span></a>
<a class="sourceLine" id="cb422-2" data-line-number="2">  <span class="kw">let</span> iter <span class="op">=</span> <span class="at">fn</span>(arr<span class="op">,</span> accumulated) <span class="op">{</span></a>
<a class="sourceLine" id="cb422-3" data-line-number="3">    <span class="cf">if</span> (<span class="at">len</span>(arr) <span class="op">==</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb422-4" data-line-number="4">      accumulated</a>
<a class="sourceLine" id="cb422-5" data-line-number="5">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb422-6" data-line-number="6">      <span class="at">iter</span>(<span class="at">rest</span>(arr)<span class="op">,</span> <span class="at">push</span>(accumulated<span class="op">,</span> <span class="at">f</span>(<span class="at">first</span>(arr))))<span class="op">;</span></a>
<a class="sourceLine" id="cb422-7" data-line-number="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb422-8" data-line-number="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb422-9" data-line-number="9"></a>
<a class="sourceLine" id="cb422-10" data-line-number="10">  <span class="at">iter</span>(arr<span class="op">,</span> [])<span class="op">;</span></a>
<a class="sourceLine" id="cb422-11" data-line-number="11"><span class="op">};</span></a></code></pre></div>
<p>And with <code>map</code> we can do things like this:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb423-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb423-2" data-line-number="2"><span class="op">&gt;&gt;</span> <span class="kw">let</span> double <span class="op">=</span> <span class="at">fn</span>(x) <span class="op">{</span> x <span class="op">*</span> <span class="dv">2</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb423-3" data-line-number="3"><span class="op">&gt;&gt;</span> <span class="at">map</span>(a<span class="op">,</span> double)<span class="op">;</span></a>
<a class="sourceLine" id="cb423-4" data-line-number="4">[<span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">8</span>]</a></code></pre></div>
<p>Isn’t this amazing? There’s more! Based on the same built-in functions we can also define a <code>reduce</code> function:</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb424-1" data-line-number="1"><span class="kw">let</span> reduce <span class="op">=</span> <span class="at">fn</span>(arr<span class="op">,</span> initial<span class="op">,</span> f) <span class="op">{</span></a>
<a class="sourceLine" id="cb424-2" data-line-number="2">  <span class="kw">let</span> iter <span class="op">=</span> <span class="at">fn</span>(arr<span class="op">,</span> result) <span class="op">{</span></a>
<a class="sourceLine" id="cb424-3" data-line-number="3">    <span class="cf">if</span> (<span class="at">len</span>(arr) <span class="op">==</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb424-4" data-line-number="4">      result</a>
<a class="sourceLine" id="cb424-5" data-line-number="5">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb424-6" data-line-number="6">      <span class="at">iter</span>(<span class="at">rest</span>(arr)<span class="op">,</span> <span class="at">f</span>(result<span class="op">,</span> <span class="at">first</span>(arr)))<span class="op">;</span></a>
<a class="sourceLine" id="cb424-7" data-line-number="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb424-8" data-line-number="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb424-9" data-line-number="9"></a>
<a class="sourceLine" id="cb424-10" data-line-number="10">  <span class="at">iter</span>(arr<span class="op">,</span> initial)<span class="op">;</span></a>
<a class="sourceLine" id="cb424-11" data-line-number="11"><span class="op">};</span></a></code></pre></div>
<p>And <code>reduce</code>, in turn, can be used to define a <code>sum</code> function:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb425-1" data-line-number="1"><span class="kw">let</span> sum <span class="op">=</span> <span class="at">fn</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb425-2" data-line-number="2">  <span class="at">reduce</span>(arr<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="at">fn</span>(initial<span class="op">,</span> el) <span class="op">{</span> initial <span class="op">+</span> el <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb425-3" data-line-number="3"><span class="op">};</span></a></code></pre></div>
<p>And it works like a charm:</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb426-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="at">sum</span>([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb426-2" data-line-number="2"><span class="dv">15</span></a></code></pre></div>
<p>As you probably know, I’m not a fan of patting oneself on the back, but let me just say this: holy monkey! Look at what our interpreter can do! A <code>map</code> function?! <code>reduce</code>?! We’ve come a long, long way!</p>
<p>And that’s not even all of it! There’s a lot more we can do now and I urge you to explore the possibilities the array data type and the few built-in functions give us. But you know what you should do first? Take some time off, brag about this to your friends and family, enjoy the praise and compliments. And when you come back, we’ll add another data type.</p>
<h2 id="hashes">4.5 - Hashes</h2>
<p>The next data type we’re going to add is called “hash”. A hash in Monkey is what’s sometimes called hash, map, hash map or dictionary in other programming languages. It maps keys to values.</p>
<p>In order to construct a hash in Monkey one uses the hash literal: a comma-separated list of key-value pairs that’s enclosed by curly braces. Each key-value pair uses a colon to differentiate between the key and the value. Here is what using a hash literal looks like:</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb427-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> myHash <span class="op">=</span> <span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Jimmy&quot;</span><span class="op">,</span> <span class="st">&quot;age&quot;</span><span class="op">:</span> <span class="dv">72</span><span class="op">,</span> <span class="st">&quot;band&quot;</span><span class="op">:</span> <span class="st">&quot;Led Zeppelin&quot;</span><span class="op">};</span></a>
<a class="sourceLine" id="cb427-2" data-line-number="2"><span class="op">&gt;&gt;</span> myHash[<span class="st">&quot;name&quot;</span>]</a>
<a class="sourceLine" id="cb427-3" data-line-number="3">Jimmy</a>
<a class="sourceLine" id="cb427-4" data-line-number="4"><span class="op">&gt;&gt;</span> myHash[<span class="st">&quot;age&quot;</span>]</a>
<a class="sourceLine" id="cb427-5" data-line-number="5"><span class="dv">72</span></a>
<a class="sourceLine" id="cb427-6" data-line-number="6"><span class="op">&gt;&gt;</span> myHash[<span class="st">&quot;band&quot;</span>]</a>
<a class="sourceLine" id="cb427-7" data-line-number="7">Led Zeppelin</a></code></pre></div>
<p>In this example <code>myHash</code> contains three key-value pairs. The keys are all strings. And, as you can see, we can use index operator expressions to get values out of the hash again, just like we can with arrays. Except that in this example the index values are strings, which don’t work with arrays. And that’s not even the only data type that’s usable as a hash key:</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb428-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> myHash <span class="op">=</span> <span class="op">{</span><span class="dt">true</span><span class="op">:</span> <span class="st">&quot;yes, a boolean&quot;</span><span class="op">,</span> <span class="dv">99</span><span class="op">:</span> <span class="st">&quot;correct, an integer&quot;</span><span class="op">};</span></a>
<a class="sourceLine" id="cb428-2" data-line-number="2"><span class="op">&gt;&gt;</span> myHash[<span class="kw">true</span>]</a>
<a class="sourceLine" id="cb428-3" data-line-number="3">yes<span class="op">,</span> a boolean</a>
<a class="sourceLine" id="cb428-4" data-line-number="4"><span class="op">&gt;&gt;</span> myHash[<span class="dv">99</span>]</a>
<a class="sourceLine" id="cb428-5" data-line-number="5">correct<span class="op">,</span> an integer</a></code></pre></div>
<p>That’s also valid. In fact, besides string, integer and boolean literals we can use any expression as index in index operator expressions:</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb429-1" data-line-number="1"><span class="op">&gt;&gt;</span> myHash[<span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb429-2" data-line-number="2">yes<span class="op">,</span> a boolean</a>
<a class="sourceLine" id="cb429-3" data-line-number="3"><span class="op">&gt;&gt;</span> myHash[<span class="dv">100</span> <span class="op">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb429-4" data-line-number="4">correct<span class="op">,</span> an integer</a></code></pre></div>
<p>As long as these expressions evaluate to either strings, integers or booleans they are usable as hash keys. Here <code>5 &gt; 1</code> evaluates to <code>true</code> and <code>100 - 1</code> evaluates to <code>99</code>, both of which are valid and mapped to values in <code>myHash</code>.</p>
<p>Rather unsurprisingly our implementation will use Go’s <code>map</code> as the underlying data structure for Monkey hashes. But since we want to use strings, integers and booleans interchangeably as keys, we need to build something on top of plain old <code>map</code> to make it work. We’ll come to that when we extend our object system. But first we have to turn hash literals into tokens.</p>
<h3 id="lexing-hash-literals">Lexing Hash Literals</h3>
<p>How do we turn hash literals into tokens? Which tokens do we need to recognize and output in our lexer so that we can later work with them in the parser? Here is the hash literal from above again:</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb430-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Jimmy&quot;</span><span class="op">,</span> <span class="st">&quot;age&quot;</span><span class="op">:</span> <span class="dv">72</span><span class="op">,</span> <span class="st">&quot;band&quot;</span><span class="op">:</span> <span class="st">&quot;Led Zeppelin&quot;</span><span class="op">}</span></a></code></pre></div>
<p>Besides the string and integer literals there are four characters in use here that are important: <code>{</code>, <code>}</code>, <code>,</code> and <code>:</code>. We already know how to lex the first three. Our lexer turns these into <code>token.LBRACE</code>, <code>token.RBRACE</code> and <code>token.COMMA</code> respectively. That means, all that’s left for us to do in this section is to turn <code>:</code> into a token.</p>
<p>And for that we first need to define the necessary token type in the <code>token</code> package:</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb431-1" data-line-number="1"><span class="co">// token/token.go</span></a>
<a class="sourceLine" id="cb431-2" data-line-number="2"></a>
<a class="sourceLine" id="cb431-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb431-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb431-5" data-line-number="5">    COLON = <span class="st">&quot;:&quot;</span></a>
<a class="sourceLine" id="cb431-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb431-7" data-line-number="7">)</a></code></pre></div>
<p>Next we’re going to add a new test for the <code>NextToken</code> method of <code>Lexer</code> that expects a <code>token.COLON</code>:</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb432-1" data-line-number="1"><span class="co">// lexer/lexer_test.go</span></a>
<a class="sourceLine" id="cb432-2" data-line-number="2"></a>
<a class="sourceLine" id="cb432-3" data-line-number="3"><span class="kw">func</span> TestNextToken(t *testing.T) {</a>
<a class="sourceLine" id="cb432-4" data-line-number="4">    input := <span class="st">`let five = 5;</span></a>
<a class="sourceLine" id="cb432-5" data-line-number="5"><span class="st">let ten = 10;</span></a>
<a class="sourceLine" id="cb432-6" data-line-number="6"></a>
<a class="sourceLine" id="cb432-7" data-line-number="7"><span class="st">let add = fn(x, y) {</span></a>
<a class="sourceLine" id="cb432-8" data-line-number="8"><span class="st">  x + y;</span></a>
<a class="sourceLine" id="cb432-9" data-line-number="9"><span class="st">};</span></a>
<a class="sourceLine" id="cb432-10" data-line-number="10"></a>
<a class="sourceLine" id="cb432-11" data-line-number="11"><span class="st">let result = add(five, ten);</span></a>
<a class="sourceLine" id="cb432-12" data-line-number="12"><span class="st">!-/*5;</span></a>
<a class="sourceLine" id="cb432-13" data-line-number="13"><span class="st">5 &lt; 10 &gt; 5;</span></a>
<a class="sourceLine" id="cb432-14" data-line-number="14"></a>
<a class="sourceLine" id="cb432-15" data-line-number="15"><span class="st">if (5 &lt; 10) {</span></a>
<a class="sourceLine" id="cb432-16" data-line-number="16"><span class="st">    return true;</span></a>
<a class="sourceLine" id="cb432-17" data-line-number="17"><span class="st">} else {</span></a>
<a class="sourceLine" id="cb432-18" data-line-number="18"><span class="st">    return false;</span></a>
<a class="sourceLine" id="cb432-19" data-line-number="19"><span class="st">}</span></a>
<a class="sourceLine" id="cb432-20" data-line-number="20"></a>
<a class="sourceLine" id="cb432-21" data-line-number="21"><span class="st">10 == 10;</span></a>
<a class="sourceLine" id="cb432-22" data-line-number="22"><span class="st">10 != 9;</span></a>
<a class="sourceLine" id="cb432-23" data-line-number="23"><span class="st">&quot;foobar&quot;</span></a>
<a class="sourceLine" id="cb432-24" data-line-number="24"><span class="st">&quot;foo bar&quot;</span></a>
<a class="sourceLine" id="cb432-25" data-line-number="25"><span class="st">[1, 2];</span></a>
<a class="sourceLine" id="cb432-26" data-line-number="26"><span class="st">{&quot;foo&quot;: &quot;bar&quot;}</span></a>
<a class="sourceLine" id="cb432-27" data-line-number="27"><span class="st">`</span></a>
<a class="sourceLine" id="cb432-28" data-line-number="28"></a>
<a class="sourceLine" id="cb432-29" data-line-number="29">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb432-30" data-line-number="30">        expectedType    token.TokenType</a>
<a class="sourceLine" id="cb432-31" data-line-number="31">        expectedLiteral <span class="dt">string</span></a>
<a class="sourceLine" id="cb432-32" data-line-number="32">    }{</a>
<a class="sourceLine" id="cb432-33" data-line-number="33"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb432-34" data-line-number="34">        {token.LBRACE, <span class="st">&quot;{&quot;</span>},</a>
<a class="sourceLine" id="cb432-35" data-line-number="35">        {token.STRING, <span class="st">&quot;foo&quot;</span>},</a>
<a class="sourceLine" id="cb432-36" data-line-number="36">        {token.COLON, <span class="st">&quot;:&quot;</span>},</a>
<a class="sourceLine" id="cb432-37" data-line-number="37">        {token.STRING, <span class="st">&quot;bar&quot;</span>},</a>
<a class="sourceLine" id="cb432-38" data-line-number="38">        {token.RBRACE, <span class="st">&quot;}&quot;</span>},</a>
<a class="sourceLine" id="cb432-39" data-line-number="39">        {token.EOF, <span class="st">&quot;&quot;</span>},</a>
<a class="sourceLine" id="cb432-40" data-line-number="40">    }</a>
<a class="sourceLine" id="cb432-41" data-line-number="41"></a>
<a class="sourceLine" id="cb432-42" data-line-number="42"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb432-43" data-line-number="43">}</a></code></pre></div>
<p>We could get away with adding a single <code>:</code> to the test input, but using a hash literal as we did here provides a little more context when later reading and eventually debugging the test.</p>
<p>Turning <code>:</code> into <code>token.COLON</code> is as easy as it gets:</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb433-1" data-line-number="1"><span class="co">// lexer/lexer.go</span></a>
<a class="sourceLine" id="cb433-2" data-line-number="2"></a>
<a class="sourceLine" id="cb433-3" data-line-number="3"><span class="kw">func</span> (l *Lexer) NextToken() token.Token {</a>
<a class="sourceLine" id="cb433-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb433-5" data-line-number="5">    <span class="kw">case</span> <span class="ch">&#39;:&#39;</span>:</a>
<a class="sourceLine" id="cb433-6" data-line-number="6">        tok = newToken(token.COLON, l.ch)</a>
<a class="sourceLine" id="cb433-7" data-line-number="7"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb433-8" data-line-number="8">}</a></code></pre></div>
<p>Only two new lines and the lexer now spits out <code>token.COLON</code>:</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb434-1" data-line-number="1">$ go test ./lexer</a>
<a class="sourceLine" id="cb434-2" data-line-number="2">ok      monkey/lexer    0.006s</a></code></pre></div>
<p>Boom! The lexer now returns <code>token.LBRACE</code>, <code>token.RBRACE</code>, <code>token.COMMA</code> and the new <code>token.COLON</code>. That’s all we need in order to parse to hash literals.</p>
<h3 id="parsing-hash-literals">Parsing Hash Literals</h3>
<p>Before we start working on our parser or even writing a test, let’s look at the basic syntactic structure of a hash literal:</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb435-1" data-line-number="1">{&lt;expression&gt; : &lt;expression&gt;, &lt;expression&gt; : &lt;expression&gt;, ... }</a></code></pre></div>
<p>It’s a comma-separated list of pairs. Each pair consists of two expressions. One produces the hash key and one produces the value. The key is separated from the value with a colon. The list is enclosed by a pair of curly braces.</p>
<p>When we turn this into an AST node, we have to keep track of the key-value pairs. Now how would we do that? We’ll use a <code>map</code>, yes, but of what type are the keys and the values in this <code>map</code>?</p>
<p>We said earlier that the only admissible data types for hash keys are strings, integers and booleans. But we can’t enforce that in the parser. Instead we’ll have to validate hash key types in the evaluation stage and generate possible errors there.</p>
<p>That’s because a lot of different expressions can produce strings, integers or booleans. Not just their literal forms. Enforcing the data type of hash keys in the parsing stage would prevent us from doing something like this:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb436-1" data-line-number="1"><span class="kw">let</span> key <span class="op">=</span> <span class="st">&quot;name&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb436-2" data-line-number="2"><span class="kw">let</span> hash <span class="op">=</span> <span class="op">{</span><span class="dt">key</span><span class="op">:</span> <span class="st">&quot;Monkey&quot;</span><span class="op">};</span></a></code></pre></div>
<p>Here <code>key</code> evaluates to <code>&quot;name&quot;</code> and is thus totally valid as a hash key, even though it’s an identifier. In order to allow this, we need to allow any expression as a key and any expression as a value in a hash literal. At least in the parsing stage. Following that our <code>ast.HashLiteral</code> definition looks like this:</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb437-1" data-line-number="1"><span class="co">// ast/ast.go</span></a>
<a class="sourceLine" id="cb437-2" data-line-number="2"></a>
<a class="sourceLine" id="cb437-3" data-line-number="3"><span class="kw">type</span> HashLiteral <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb437-4" data-line-number="4">    Token token.Token <span class="co">// the &#39;{&#39; token</span></a>
<a class="sourceLine" id="cb437-5" data-line-number="5">    Pairs <span class="kw">map</span>[Expression]Expression</a>
<a class="sourceLine" id="cb437-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb437-7" data-line-number="7"></a>
<a class="sourceLine" id="cb437-8" data-line-number="8"><span class="kw">func</span> (hl *HashLiteral) expressionNode()      {}</a>
<a class="sourceLine" id="cb437-9" data-line-number="9"><span class="kw">func</span> (hl *HashLiteral) TokenLiteral() <span class="dt">string</span> { <span class="kw">return</span> hl.Token.Literal }</a>
<a class="sourceLine" id="cb437-10" data-line-number="10"><span class="kw">func</span> (hl *HashLiteral) String() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb437-11" data-line-number="11">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb437-12" data-line-number="12"></a>
<a class="sourceLine" id="cb437-13" data-line-number="13">    pairs := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb437-14" data-line-number="14">    <span class="kw">for</span> key, value := <span class="kw">range</span> hl.Pairs {</a>
<a class="sourceLine" id="cb437-15" data-line-number="15">        pairs = <span class="bu">append</span>(pairs, key.String()+<span class="st">&quot;:&quot;</span>+value.String())</a>
<a class="sourceLine" id="cb437-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb437-17" data-line-number="17"></a>
<a class="sourceLine" id="cb437-18" data-line-number="18">    out.WriteString(<span class="st">&quot;{&quot;</span>)</a>
<a class="sourceLine" id="cb437-19" data-line-number="19">    out.WriteString(strings.Join(pairs, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb437-20" data-line-number="20">    out.WriteString(<span class="st">&quot;}&quot;</span>)</a>
<a class="sourceLine" id="cb437-21" data-line-number="21"></a>
<a class="sourceLine" id="cb437-22" data-line-number="22">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb437-23" data-line-number="23">}</a></code></pre></div>
<p>Now that we’re clear about the structure of hash literals and have <code>ast.HashLiteral</code> defined, we can write tests for our parser:</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb438-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb438-2" data-line-number="2"></a>
<a class="sourceLine" id="cb438-3" data-line-number="3"><span class="kw">func</span> TestParsingHashLiteralsStringKeys(t *testing.T) {</a>
<a class="sourceLine" id="cb438-4" data-line-number="4">    input := <span class="st">`{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}`</span></a>
<a class="sourceLine" id="cb438-5" data-line-number="5"></a>
<a class="sourceLine" id="cb438-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb438-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb438-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb438-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb438-10" data-line-number="10"></a>
<a class="sourceLine" id="cb438-11" data-line-number="11">    stmt := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb438-12" data-line-number="12">    hash, ok := stmt.Expression.(*ast.HashLiteral)</a>
<a class="sourceLine" id="cb438-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb438-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb438-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb438-16" data-line-number="16"></a>
<a class="sourceLine" id="cb438-17" data-line-number="17">    <span class="kw">if</span> <span class="bu">len</span>(hash.Pairs) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb438-18" data-line-number="18">        t.Errorf(<span class="st">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class="bu">len</span>(hash.Pairs))</a>
<a class="sourceLine" id="cb438-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb438-20" data-line-number="20"></a>
<a class="sourceLine" id="cb438-21" data-line-number="21">    expected := <span class="kw">map</span>[<span class="dt">string</span>]<span class="dt">int64</span>{</a>
<a class="sourceLine" id="cb438-22" data-line-number="22">        <span class="st">&quot;one&quot;</span>:   <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb438-23" data-line-number="23">        <span class="st">&quot;two&quot;</span>:   <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb438-24" data-line-number="24">        <span class="st">&quot;three&quot;</span>: <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb438-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb438-26" data-line-number="26"></a>
<a class="sourceLine" id="cb438-27" data-line-number="27">    <span class="kw">for</span> key, value := <span class="kw">range</span> hash.Pairs {</a>
<a class="sourceLine" id="cb438-28" data-line-number="28">        literal, ok := key.(*ast.StringLiteral)</a>
<a class="sourceLine" id="cb438-29" data-line-number="29">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb438-30" data-line-number="30">            t.Errorf(<span class="st">&quot;key is not ast.StringLiteral. got=%T&quot;</span>, key)</a>
<a class="sourceLine" id="cb438-31" data-line-number="31">        }</a>
<a class="sourceLine" id="cb438-32" data-line-number="32"></a>
<a class="sourceLine" id="cb438-33" data-line-number="33">        expectedValue := expected[literal.String()]</a>
<a class="sourceLine" id="cb438-34" data-line-number="34"></a>
<a class="sourceLine" id="cb438-35" data-line-number="35">        testIntegerLiteral(t, value, expectedValue)</a>
<a class="sourceLine" id="cb438-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb438-37" data-line-number="37">}</a></code></pre></div>
<p>And of course, we also have to be sure that we parse an empty hash literal correctly, because such edge-cases are the root of all hair loss in programming:</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb439-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb439-2" data-line-number="2"></a>
<a class="sourceLine" id="cb439-3" data-line-number="3"><span class="kw">func</span> TestParsingEmptyHashLiteral(t *testing.T) {</a>
<a class="sourceLine" id="cb439-4" data-line-number="4">    input := <span class="st">&quot;{}&quot;</span></a>
<a class="sourceLine" id="cb439-5" data-line-number="5"></a>
<a class="sourceLine" id="cb439-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb439-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb439-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb439-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb439-10" data-line-number="10"></a>
<a class="sourceLine" id="cb439-11" data-line-number="11">    stmt := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb439-12" data-line-number="12">    hash, ok := stmt.Expression.(*ast.HashLiteral)</a>
<a class="sourceLine" id="cb439-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb439-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb439-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb439-16" data-line-number="16"></a>
<a class="sourceLine" id="cb439-17" data-line-number="17">    <span class="kw">if</span> <span class="bu">len</span>(hash.Pairs) != <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb439-18" data-line-number="18">        t.Errorf(<span class="st">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class="bu">len</span>(hash.Pairs))</a>
<a class="sourceLine" id="cb439-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb439-20" data-line-number="20">}</a></code></pre></div>
<p>I also added two more tests that are similar to <code>TestHashLiteralStringKeys</code> but use integers and booleans as hash keys and make sure the parser turns those into <code>*ast.IntegerLiteral</code> and <code>*ast.Boolean</code> respectively. And then there is a fifth test function that makes sure the values in a hash literal can be any expression, even operator expressions. It looks like this:</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb440-1" data-line-number="1"><span class="co">// parser/parser_test.go</span></a>
<a class="sourceLine" id="cb440-2" data-line-number="2"></a>
<a class="sourceLine" id="cb440-3" data-line-number="3"><span class="kw">func</span> TestParsingHashLiteralsWithExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb440-4" data-line-number="4">    input := <span class="st">`{&quot;one&quot;: 0 + 1, &quot;two&quot;: 10 - 8, &quot;three&quot;: 15 / 5}`</span></a>
<a class="sourceLine" id="cb440-5" data-line-number="5"></a>
<a class="sourceLine" id="cb440-6" data-line-number="6">    l := lexer.New(input)</a>
<a class="sourceLine" id="cb440-7" data-line-number="7">    p := New(l)</a>
<a class="sourceLine" id="cb440-8" data-line-number="8">    program := p.ParseProgram()</a>
<a class="sourceLine" id="cb440-9" data-line-number="9">    checkParserErrors(t, p)</a>
<a class="sourceLine" id="cb440-10" data-line-number="10"></a>
<a class="sourceLine" id="cb440-11" data-line-number="11">    stmt := program.Statements[<span class="dv">0</span>].(*ast.ExpressionStatement)</a>
<a class="sourceLine" id="cb440-12" data-line-number="12">    hash, ok := stmt.Expression.(*ast.HashLiteral)</a>
<a class="sourceLine" id="cb440-13" data-line-number="13">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb440-14" data-line-number="14">        t.Fatalf(<span class="st">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</a>
<a class="sourceLine" id="cb440-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb440-16" data-line-number="16"></a>
<a class="sourceLine" id="cb440-17" data-line-number="17">    <span class="kw">if</span> <span class="bu">len</span>(hash.Pairs) != <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb440-18" data-line-number="18">        t.Errorf(<span class="st">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class="bu">len</span>(hash.Pairs))</a>
<a class="sourceLine" id="cb440-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb440-20" data-line-number="20"></a>
<a class="sourceLine" id="cb440-21" data-line-number="21">    tests := <span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">func</span>(ast.Expression){</a>
<a class="sourceLine" id="cb440-22" data-line-number="22">        <span class="st">&quot;one&quot;</span>: <span class="kw">func</span>(e ast.Expression) {</a>
<a class="sourceLine" id="cb440-23" data-line-number="23">            testInfixExpression(t, e, <span class="dv">0</span>, <span class="st">&quot;+&quot;</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb440-24" data-line-number="24">        },</a>
<a class="sourceLine" id="cb440-25" data-line-number="25">        <span class="st">&quot;two&quot;</span>: <span class="kw">func</span>(e ast.Expression) {</a>
<a class="sourceLine" id="cb440-26" data-line-number="26">            testInfixExpression(t, e, <span class="dv">10</span>, <span class="st">&quot;-&quot;</span>, <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb440-27" data-line-number="27">        },</a>
<a class="sourceLine" id="cb440-28" data-line-number="28">        <span class="st">&quot;three&quot;</span>: <span class="kw">func</span>(e ast.Expression) {</a>
<a class="sourceLine" id="cb440-29" data-line-number="29">            testInfixExpression(t, e, <span class="dv">15</span>, <span class="st">&quot;/&quot;</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb440-30" data-line-number="30">        },</a>
<a class="sourceLine" id="cb440-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb440-32" data-line-number="32"></a>
<a class="sourceLine" id="cb440-33" data-line-number="33">    <span class="kw">for</span> key, value := <span class="kw">range</span> hash.Pairs {</a>
<a class="sourceLine" id="cb440-34" data-line-number="34">        literal, ok := key.(*ast.StringLiteral)</a>
<a class="sourceLine" id="cb440-35" data-line-number="35">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb440-36" data-line-number="36">            t.Errorf(<span class="st">&quot;key is not ast.StringLiteral. got=%T&quot;</span>, key)</a>
<a class="sourceLine" id="cb440-37" data-line-number="37">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb440-38" data-line-number="38">        }</a>
<a class="sourceLine" id="cb440-39" data-line-number="39"></a>
<a class="sourceLine" id="cb440-40" data-line-number="40">        testFunc, ok := tests[literal.String()]</a>
<a class="sourceLine" id="cb440-41" data-line-number="41">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb440-42" data-line-number="42">            t.Errorf(<span class="st">&quot;No test function for key %q found&quot;</span>, literal.String())</a>
<a class="sourceLine" id="cb440-43" data-line-number="43">            <span class="kw">continue</span></a>
<a class="sourceLine" id="cb440-44" data-line-number="44">        }</a>
<a class="sourceLine" id="cb440-45" data-line-number="45"></a>
<a class="sourceLine" id="cb440-46" data-line-number="46">        testFunc(value)</a>
<a class="sourceLine" id="cb440-47" data-line-number="47">    }</a>
<a class="sourceLine" id="cb440-48" data-line-number="48">}</a></code></pre></div>
<p>So how are all of these test functions doing? Not so well, to be honest. We get a lot of failures and parser errors:</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb441-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb441-2" data-line-number="2">--- FAIL: TestParsingEmptyHashLiteral (0.00s)</a>
<a class="sourceLine" id="cb441-3" data-line-number="3">  parser_test.go:1173: parser has 2 errors</a>
<a class="sourceLine" id="cb441-4" data-line-number="4">  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb441-5" data-line-number="5">  parser_test.go:1175: parser error: &quot;no prefix parse function for } found&quot;</a>
<a class="sourceLine" id="cb441-6" data-line-number="6">--- FAIL: TestParsingHashLiteralsStringKeys (0.00s)</a>
<a class="sourceLine" id="cb441-7" data-line-number="7">  parser_test.go:1173: parser has 7 errors</a>
<a class="sourceLine" id="cb441-8" data-line-number="8">  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb441-9" data-line-number="9">[... more errors ...]</a>
<a class="sourceLine" id="cb441-10" data-line-number="10">--- FAIL: TestParsingHashLiteralsBooleanKeys (0.00s)</a>
<a class="sourceLine" id="cb441-11" data-line-number="11">  parser_test.go:1173: parser has 5 errors</a>
<a class="sourceLine" id="cb441-12" data-line-number="12">  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb441-13" data-line-number="13">[... more errors ...]</a>
<a class="sourceLine" id="cb441-14" data-line-number="14">--- FAIL: TestParsingHashLiteralsIntegerKeys (0.00s)</a>
<a class="sourceLine" id="cb441-15" data-line-number="15">  parser_test.go:967: parser has 7 errors</a>
<a class="sourceLine" id="cb441-16" data-line-number="16">  parser_test.go:969: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb441-17" data-line-number="17">[... more errors ...]</a>
<a class="sourceLine" id="cb441-18" data-line-number="18">--- FAIL: TestParsingHashLiteralsWithExpressions (0.00s)</a>
<a class="sourceLine" id="cb441-19" data-line-number="19">  parser_test.go:1173: parser has 7 errors</a>
<a class="sourceLine" id="cb441-20" data-line-number="20">  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</a>
<a class="sourceLine" id="cb441-21" data-line-number="21">[... more errors ...]</a>
<a class="sourceLine" id="cb441-22" data-line-number="22">FAIL</a>
<a class="sourceLine" id="cb441-23" data-line-number="23">FAIL    monkey/parser   0.008s</a></code></pre></div>
<p>It might sound unbelievable but there’s good news: it only takes one function to make all of these tests pass. One <code>prefixParseFn</code>, to be exact. Since the <code>token.LBRACE</code> of a hash literal is in prefix position, just like the <code>token.LBRACKET</code> of an array literal, we can define a <code>parseHashLiteral</code> method as a <code>prefixParseFn</code>:</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb442-1" data-line-number="1"><span class="co">// parser/parser.go</span></a>
<a class="sourceLine" id="cb442-2" data-line-number="2"></a>
<a class="sourceLine" id="cb442-3" data-line-number="3"><span class="kw">func</span> New(l *lexer.Lexer) *Parser {</a>
<a class="sourceLine" id="cb442-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb442-5" data-line-number="5">    p.registerPrefix(token.LBRACE, p.parseHashLiteral)</a>
<a class="sourceLine" id="cb442-6" data-line-number="6"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb442-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb442-8" data-line-number="8"></a>
<a class="sourceLine" id="cb442-9" data-line-number="9"><span class="kw">func</span> (p *Parser) parseHashLiteral() ast.Expression {</a>
<a class="sourceLine" id="cb442-10" data-line-number="10">    hash := &amp;ast.HashLiteral{Token: p.curToken}</a>
<a class="sourceLine" id="cb442-11" data-line-number="11">    hash.Pairs = <span class="bu">make</span>(<span class="kw">map</span>[ast.Expression]ast.Expression)</a>
<a class="sourceLine" id="cb442-12" data-line-number="12"></a>
<a class="sourceLine" id="cb442-13" data-line-number="13">    <span class="kw">for</span> !p.peekTokenIs(token.RBRACE) {</a>
<a class="sourceLine" id="cb442-14" data-line-number="14">        p.nextToken()</a>
<a class="sourceLine" id="cb442-15" data-line-number="15">        key := p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb442-16" data-line-number="16"></a>
<a class="sourceLine" id="cb442-17" data-line-number="17">        <span class="kw">if</span> !p.expectPeek(token.COLON) {</a>
<a class="sourceLine" id="cb442-18" data-line-number="18">            <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb442-19" data-line-number="19">        }</a>
<a class="sourceLine" id="cb442-20" data-line-number="20"></a>
<a class="sourceLine" id="cb442-21" data-line-number="21">        p.nextToken()</a>
<a class="sourceLine" id="cb442-22" data-line-number="22">        value := p.parseExpression(LOWEST)</a>
<a class="sourceLine" id="cb442-23" data-line-number="23"></a>
<a class="sourceLine" id="cb442-24" data-line-number="24">        hash.Pairs[key] = value</a>
<a class="sourceLine" id="cb442-25" data-line-number="25"></a>
<a class="sourceLine" id="cb442-26" data-line-number="26">        <span class="kw">if</span> !p.peekTokenIs(token.RBRACE) &amp;&amp; !p.expectPeek(token.COMMA) {</a>
<a class="sourceLine" id="cb442-27" data-line-number="27">            <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb442-28" data-line-number="28">        }</a>
<a class="sourceLine" id="cb442-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb442-30" data-line-number="30"></a>
<a class="sourceLine" id="cb442-31" data-line-number="31">    <span class="kw">if</span> !p.expectPeek(token.RBRACE) {</a>
<a class="sourceLine" id="cb442-32" data-line-number="32">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb442-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb442-34" data-line-number="34"></a>
<a class="sourceLine" id="cb442-35" data-line-number="35">    <span class="kw">return</span> hash</a>
<a class="sourceLine" id="cb442-36" data-line-number="36">}</a></code></pre></div>
<p>It may look intimidating, but there is nothing in <code>parseHashLiteral</code> we haven’t seen before. It only loops over key-value expression pairs by checking for a closing <code>token.RBRACE</code> and calling <code>parseExpression</code> two times. That and the filling of <code>hash.Pairs</code> are the most important parts of this method. It does its job well:</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb443-1" data-line-number="1">$ go test ./parser</a>
<a class="sourceLine" id="cb443-2" data-line-number="2">ok      monkey/parser   0.006s</a></code></pre></div>
<p>All of our parser tests pass! And judging by the numbers of tests we added, we can be reasonably sure that our parser now knows how to parse hash literals. That means we’re now coming to the most interesting part of adding hashes to our interpreter: representing them in the object system and evaluating hash literals.</p>
<h3 id="hashing-objects">Hashing Objects</h3>
<p>Besides extending the lexer and parser, adding a new data type also means representing it in the object system. We successfully did that for integers, strings and arrays. But whereas implementing these other data types just meant defining a struct that has a <code>.Value</code> field with the correct type, hashes require a little bit more effort. Let me explain why.</p>
<p>Let’s say we defined a new <code>object.Hash</code> type like this:</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb444-1" data-line-number="1"><span class="kw">type</span> Hash <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb444-2" data-line-number="2">  Pairs <span class="kw">map</span>[Object]Object</a>
<a class="sourceLine" id="cb444-3" data-line-number="3">}</a></code></pre></div>
<p>That’s the most obvious choice for implementing a <code>Hash</code> data type based on Go’s <code>map</code>. But with this definition, how would we fill the <code>Pairs</code> map? And more importantly, how would we get values back out of it?</p>
<p>Consider this piece of Monkey code:</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb445-1" data-line-number="1"><span class="kw">let</span> hash <span class="op">=</span> <span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Monkey&quot;</span><span class="op">};</span></a>
<a class="sourceLine" id="cb445-2" data-line-number="2">hash[<span class="st">&quot;name&quot;</span>]</a></code></pre></div>
<p>Let’s say we are evaluating these two lines and are using the <code>object.Hash</code> definition from above. When evaluating the hash literal in the first line we take every key-value pair and put it in the <code>map[Object]Object</code> map, resulting in <code>.Pairs</code> having the following mapping: an <code>*object.String</code> with <code>.Value</code> being <code>&quot;name&quot;</code> mapped to an <code>*object.String</code> with <code>.Value</code> being <code>&quot;Monkey&quot;</code>.</p>
<p>So far, so good. But the problem arises in the second line where we use an index expression to try to access the <code>&quot;Monkey&quot;</code> string.</p>
<p>In this second line the <code>&quot;name&quot;</code> string literal of the index expression evaluates to a new, freshly allocated <code>*object.String</code>. And even though this new <code>*object.String</code> also contains <code>&quot;name&quot;</code> in its <code>.Value</code> field, just like the other <code>*object.String</code> in <code>Pairs</code>, we can’t use the new one to retrieve <code>&quot;Monkey&quot;</code>.</p>
<p>The reason for this is that they’re pointers pointing to different memory locations. The fact that the content of the memory locations they point to is the same (<code>&quot;name&quot;</code>) doesn’t matter. Comparing these pointers would tell us that they’re not equal. That means using the newly created <code>*object.String</code> as a key doesn’t get us <code>&quot;Monkey&quot;</code>. That’s how pointers and comparison between them works in Go.</p>
<p>Here is an example that demonstrates the problem we’d face with the <code>object.Hash</code> implementation from above:</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb446-1" data-line-number="1">name1 := &amp;object.String{Value: <span class="st">&quot;name&quot;</span>}</a>
<a class="sourceLine" id="cb446-2" data-line-number="2">monkey := &amp;object.String{Value: <span class="st">&quot;Monkey&quot;</span>}</a>
<a class="sourceLine" id="cb446-3" data-line-number="3"></a>
<a class="sourceLine" id="cb446-4" data-line-number="4">pairs := <span class="kw">map</span>[object.Object]object.Object{}</a>
<a class="sourceLine" id="cb446-5" data-line-number="5">pairs[name1] = monkey</a>
<a class="sourceLine" id="cb446-6" data-line-number="6"></a>
<a class="sourceLine" id="cb446-7" data-line-number="7">fmt.Printf(<span class="st">&quot;pairs[name1]=%+v</span><span class="ch">\n</span><span class="st">&quot;</span>, pairs[name1])</a>
<a class="sourceLine" id="cb446-8" data-line-number="8"><span class="co">// =&gt; pairs[name1]=&amp;{Value:Monkey}</span></a>
<a class="sourceLine" id="cb446-9" data-line-number="9"></a>
<a class="sourceLine" id="cb446-10" data-line-number="10">name2 := &amp;object.String{Value: <span class="st">&quot;name&quot;</span>}</a>
<a class="sourceLine" id="cb446-11" data-line-number="11"></a>
<a class="sourceLine" id="cb446-12" data-line-number="12">fmt.Printf(<span class="st">&quot;pairs[name2]=%+v</span><span class="ch">\n</span><span class="st">&quot;</span>, pairs[name2])</a>
<a class="sourceLine" id="cb446-13" data-line-number="13"><span class="co">// =&gt; pairs[name2]=&lt;nil&gt;</span></a>
<a class="sourceLine" id="cb446-14" data-line-number="14"></a>
<a class="sourceLine" id="cb446-15" data-line-number="15">fmt.Printf(<span class="st">&quot;(name1 == name2)=%t</span><span class="ch">\n</span><span class="st">&quot;</span>, name1 == name2)</a>
<a class="sourceLine" id="cb446-16" data-line-number="16"><span class="co">// =&gt; (name1 == name2)=false</span></a></code></pre></div>
<p>As a solution to this problem we could iterate over every key in <code>.Pairs</code>, check if it’s an <code>*object.String</code> and compare its <code>.Value</code> to the <code>.Value</code> of the key in the index expression. We’d find the matching value this way, but this method turns the lookup time for a given key from O(1) into O(n), defeating the entire purpose of using hashes in the first place.</p>
<p>Another option is to define <code>Pairs</code> as a <code>map[string]Object</code> and then use the <code>.Value</code> of <code>*object.String</code> as the keys. That works, but not for integers and booleans.</p>
<p>No, what we need is a way to generate hashes for objects that we can easily compare and use as hash keys in our <code>object.Hash</code>. We need to be able to generate a hash key for an <code>*object.String</code> that’s comparable and equal to the hash key of another <code>*object.String</code> with the same <code>.Value</code>. The same goes for <code>*object.Integer</code> and <code>*object.Boolean</code>. But the hash keys for an <code>*object.String</code> must never be equal to the hash key for an <code>*object.Integer</code> or an <code>*object.Boolean</code>. Between types the hash keys always have to differ.</p>
<p>We can express the desired behaviour in a set of test functions in our object system:</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb447-1" data-line-number="1"><span class="co">// object/object_test.go</span></a>
<a class="sourceLine" id="cb447-2" data-line-number="2"></a>
<a class="sourceLine" id="cb447-3" data-line-number="3"><span class="kw">package</span> object</a>
<a class="sourceLine" id="cb447-4" data-line-number="4"></a>
<a class="sourceLine" id="cb447-5" data-line-number="5"><span class="kw">import</span> <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb447-6" data-line-number="6"></a>
<a class="sourceLine" id="cb447-7" data-line-number="7"><span class="kw">func</span> TestStringHashKey(t *testing.T) {</a>
<a class="sourceLine" id="cb447-8" data-line-number="8">    hello1 := &amp;String{Value: <span class="st">&quot;Hello World&quot;</span>}</a>
<a class="sourceLine" id="cb447-9" data-line-number="9">    hello2 := &amp;String{Value: <span class="st">&quot;Hello World&quot;</span>}</a>
<a class="sourceLine" id="cb447-10" data-line-number="10">    diff1 := &amp;String{Value: <span class="st">&quot;My name is johnny&quot;</span>}</a>
<a class="sourceLine" id="cb447-11" data-line-number="11">    diff2 := &amp;String{Value: <span class="st">&quot;My name is johnny&quot;</span>}</a>
<a class="sourceLine" id="cb447-12" data-line-number="12"></a>
<a class="sourceLine" id="cb447-13" data-line-number="13">    <span class="kw">if</span> hello1.HashKey() != hello2.HashKey() {</a>
<a class="sourceLine" id="cb447-14" data-line-number="14">        t.Errorf(<span class="st">&quot;strings with same content have different hash keys&quot;</span>)</a>
<a class="sourceLine" id="cb447-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb447-16" data-line-number="16"></a>
<a class="sourceLine" id="cb447-17" data-line-number="17">    <span class="kw">if</span> diff1.HashKey() != diff2.HashKey() {</a>
<a class="sourceLine" id="cb447-18" data-line-number="18">        t.Errorf(<span class="st">&quot;strings with same content have different hash keys&quot;</span>)</a>
<a class="sourceLine" id="cb447-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb447-20" data-line-number="20"></a>
<a class="sourceLine" id="cb447-21" data-line-number="21">    <span class="kw">if</span> hello1.HashKey() == diff1.HashKey() {</a>
<a class="sourceLine" id="cb447-22" data-line-number="22">        t.Errorf(<span class="st">&quot;strings with different content have same hash keys&quot;</span>)</a>
<a class="sourceLine" id="cb447-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb447-24" data-line-number="24">}</a></code></pre></div>
<p>That’s exactly what we want from a <code>HashKey()</code> method. And not just for <code>*object.String</code> but for <code>*object.Boolean</code> and <code>*object.Integer</code>, which is why the same test function exists for both of them too.</p>
<p>To stop the tests from blowing up we need to implement the <code>HashKey()</code> method on each of the three types:</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb448-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb448-2" data-line-number="2"></a>
<a class="sourceLine" id="cb448-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb448-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb448-5" data-line-number="5">    <span class="st">&quot;hash/fnv&quot;</span></a>
<a class="sourceLine" id="cb448-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb448-7" data-line-number="7"></a>
<a class="sourceLine" id="cb448-8" data-line-number="8"><span class="kw">type</span> HashKey <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb448-9" data-line-number="9">    Type  ObjectType</a>
<a class="sourceLine" id="cb448-10" data-line-number="10">    Value <span class="dt">uint64</span></a>
<a class="sourceLine" id="cb448-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb448-12" data-line-number="12"></a>
<a class="sourceLine" id="cb448-13" data-line-number="13"><span class="kw">func</span> (b *Boolean) HashKey() HashKey {</a>
<a class="sourceLine" id="cb448-14" data-line-number="14">    <span class="kw">var</span> value <span class="dt">uint64</span></a>
<a class="sourceLine" id="cb448-15" data-line-number="15"></a>
<a class="sourceLine" id="cb448-16" data-line-number="16">    <span class="kw">if</span> b.Value {</a>
<a class="sourceLine" id="cb448-17" data-line-number="17">        value = <span class="dv">1</span></a>
<a class="sourceLine" id="cb448-18" data-line-number="18">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb448-19" data-line-number="19">        value = <span class="dv">0</span></a>
<a class="sourceLine" id="cb448-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb448-21" data-line-number="21"></a>
<a class="sourceLine" id="cb448-22" data-line-number="22">    <span class="kw">return</span> HashKey{Type: b.Type(), Value: value}</a>
<a class="sourceLine" id="cb448-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb448-24" data-line-number="24"></a>
<a class="sourceLine" id="cb448-25" data-line-number="25"><span class="kw">func</span> (i *Integer) HashKey() HashKey {</a>
<a class="sourceLine" id="cb448-26" data-line-number="26">    <span class="kw">return</span> HashKey{Type: i.Type(), Value: <span class="dt">uint64</span>(i.Value)}</a>
<a class="sourceLine" id="cb448-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb448-28" data-line-number="28"></a>
<a class="sourceLine" id="cb448-29" data-line-number="29"><span class="kw">func</span> (s *String) HashKey() HashKey {</a>
<a class="sourceLine" id="cb448-30" data-line-number="30">    h := fnv.New64a()</a>
<a class="sourceLine" id="cb448-31" data-line-number="31">    h.Write([]<span class="dt">byte</span>(s.Value))</a>
<a class="sourceLine" id="cb448-32" data-line-number="32"></a>
<a class="sourceLine" id="cb448-33" data-line-number="33">    <span class="kw">return</span> HashKey{Type: s.Type(), Value: h.Sum64()}</a>
<a class="sourceLine" id="cb448-34" data-line-number="34">}</a></code></pre></div>
<p>Every <code>HashKey()</code> method returns a <code>HashKey</code>. As you can see in its definition, <code>HashKey</code> is nothing fancy. The <code>Type</code> field contains an <code>ObjectType</code> and thus effectively “scopes” <code>HashKey</code>s to different object types. The <code>Value</code> field holds the actual hash, which is just an integer. Since it’s just two integers we can easily compare a <code>HashKey</code> to another <code>HashKey</code> by using the <code>==</code> operator. And that also makes <code>HashKey</code> usable as a key in a Go <code>map</code>.</p>
<p>There is still a possibility, albeit a small one, that different <code>String</code>s with different <code>Value</code>s result in the same hash. That happens when the <code>hash/fnv</code> package generates the same integer for different values, an event called a hash collision. Chances that we experience it are low, but it should be noted that there are well-known techniques such as “separate chaining” and “open addressing” to work around the problem. Implementing one of these mitigations is outside of this book’s scope, but certainly a nice exercise for the curious reader.</p>
<p>The problem we demonstrated earlier is solved by using this newly defined <code>HashKey</code> and the <code>HashKey()</code> methods:</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb449-1" data-line-number="1">name1 := &amp;object.String{Value: <span class="st">&quot;name&quot;</span>}</a>
<a class="sourceLine" id="cb449-2" data-line-number="2">monkey := &amp;object.String{Value: <span class="st">&quot;Monkey&quot;</span>}</a>
<a class="sourceLine" id="cb449-3" data-line-number="3"></a>
<a class="sourceLine" id="cb449-4" data-line-number="4">pairs := <span class="kw">map</span>[object.HashKey]object.Object{}</a>
<a class="sourceLine" id="cb449-5" data-line-number="5">pairs[name1.HashKey()] = monkey</a>
<a class="sourceLine" id="cb449-6" data-line-number="6"></a>
<a class="sourceLine" id="cb449-7" data-line-number="7">fmt.Printf(<span class="st">&quot;pairs[name1.HashKey()]=%+v</span><span class="ch">\n</span><span class="st">&quot;</span>, pairs[name1.HashKey()])</a>
<a class="sourceLine" id="cb449-8" data-line-number="8"><span class="co">// =&gt; pairs[name1.HashKey()]=&amp;{Value:Monkey}</span></a>
<a class="sourceLine" id="cb449-9" data-line-number="9"></a>
<a class="sourceLine" id="cb449-10" data-line-number="10">name2 := &amp;object.String{Value: <span class="st">&quot;name&quot;</span>}</a>
<a class="sourceLine" id="cb449-11" data-line-number="11"></a>
<a class="sourceLine" id="cb449-12" data-line-number="12">fmt.Printf(<span class="st">&quot;pairs[name2.HashKey()]=%+v</span><span class="ch">\n</span><span class="st">&quot;</span>, pairs[name2.HashKey()])</a>
<a class="sourceLine" id="cb449-13" data-line-number="13"><span class="co">// =&gt; pairs[name2.HashKey()]=&amp;{Value:Monkey}</span></a>
<a class="sourceLine" id="cb449-14" data-line-number="14"></a>
<a class="sourceLine" id="cb449-15" data-line-number="15">fmt.Printf(<span class="st">&quot;(name1 == name2)=%t</span><span class="ch">\n</span><span class="st">&quot;</span>, name1 == name2)</a>
<a class="sourceLine" id="cb449-16" data-line-number="16"><span class="co">// =&gt; (name1 == name2)=false</span></a>
<a class="sourceLine" id="cb449-17" data-line-number="17"></a>
<a class="sourceLine" id="cb449-18" data-line-number="18">fmt.Printf(<span class="st">&quot;(name1.HashKey() == name2.HashKey())=%t</span><span class="ch">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb449-19" data-line-number="19">  name1.HashKey() == name2.HashKey())</a>
<a class="sourceLine" id="cb449-20" data-line-number="20"><span class="co">// =&gt; (name1.HashKey() == name2.HashKey())=true</span></a></code></pre></div>
<p>That’s <em>exactly</em> what we want! The <code>HashKey</code> definition and the <code>HashKey()</code> method implementations solve the problems we had with our naive <code>Hash</code> definition. They also make the tests pass:</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb450-1" data-line-number="1">$ go test ./object</a>
<a class="sourceLine" id="cb450-2" data-line-number="2">ok      monkey/object   0.008s</a></code></pre></div>
<p>Now we can define <code>object.Hash</code> and use this new <code>HashKey</code> type:</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb451-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb451-2" data-line-number="2"></a>
<a class="sourceLine" id="cb451-3" data-line-number="3"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb451-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb451-5" data-line-number="5">    HASH_OBJ = <span class="st">&quot;HASH&quot;</span></a>
<a class="sourceLine" id="cb451-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb451-7" data-line-number="7"></a>
<a class="sourceLine" id="cb451-8" data-line-number="8"><span class="kw">type</span> HashPair <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb451-9" data-line-number="9">    Key   Object</a>
<a class="sourceLine" id="cb451-10" data-line-number="10">    Value Object</a>
<a class="sourceLine" id="cb451-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb451-12" data-line-number="12"></a>
<a class="sourceLine" id="cb451-13" data-line-number="13"><span class="kw">type</span> Hash <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb451-14" data-line-number="14">    Pairs <span class="kw">map</span>[HashKey]HashPair</a>
<a class="sourceLine" id="cb451-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb451-16" data-line-number="16"></a>
<a class="sourceLine" id="cb451-17" data-line-number="17"><span class="kw">func</span> (h *Hash) Type() ObjectType { <span class="kw">return</span> HASH_OBJ }</a></code></pre></div>
<p>This adds both the definition of <code>Hash</code> and <code>HashPair</code>. <code>HashPair</code> is the type of the values in <code>Hash.Pairs</code>. You might be wondering why we use that and not just define <code>Pairs</code> as a <code>map[HashKey]Object</code>.</p>
<p>The reason is the <code>Inspect()</code> method of <code>Hash</code>. When we later print a Monkey hash in our REPL, we want to print the values contained in the hash as well as its keys. And just printing the <code>HashKey</code>s is not really useful. So we keep track of the objects that generated the <code>HashKey</code>s by using <code>HashPair</code>s as values, where we save the original key object and the value object its mapped to. That way we can call the <code>Inspect()</code> methods of the key objects to generate the <code>Inspect()</code> output for <code>*object.Hash</code>. Here is said <code>Inspect()</code> method:</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb452-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb452-2" data-line-number="2"></a>
<a class="sourceLine" id="cb452-3" data-line-number="3"><span class="kw">func</span> (h *Hash) Inspect() <span class="dt">string</span> {</a>
<a class="sourceLine" id="cb452-4" data-line-number="4">    <span class="kw">var</span> out bytes.Buffer</a>
<a class="sourceLine" id="cb452-5" data-line-number="5"></a>
<a class="sourceLine" id="cb452-6" data-line-number="6">    pairs := []<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb452-7" data-line-number="7">    <span class="kw">for</span> _, pair := <span class="kw">range</span> h.Pairs {</a>
<a class="sourceLine" id="cb452-8" data-line-number="8">        pairs = <span class="bu">append</span>(pairs, fmt.Sprintf(<span class="st">&quot;%s: %s&quot;</span>,</a>
<a class="sourceLine" id="cb452-9" data-line-number="9">            pair.Key.Inspect(), pair.Value.Inspect()))</a>
<a class="sourceLine" id="cb452-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb452-11" data-line-number="11"></a>
<a class="sourceLine" id="cb452-12" data-line-number="12">    out.WriteString(<span class="st">&quot;{&quot;</span>)</a>
<a class="sourceLine" id="cb452-13" data-line-number="13">    out.WriteString(strings.Join(pairs, <span class="st">&quot;, &quot;</span>))</a>
<a class="sourceLine" id="cb452-14" data-line-number="14">    out.WriteString(<span class="st">&quot;}&quot;</span>)</a>
<a class="sourceLine" id="cb452-15" data-line-number="15"></a>
<a class="sourceLine" id="cb452-16" data-line-number="16">    <span class="kw">return</span> out.String()</a>
<a class="sourceLine" id="cb452-17" data-line-number="17">}</a></code></pre></div>
<p>The <code>Inspect()</code> method is not the only reason why it’s good to keep track of the objects that generated the <code>HashKey</code>. That would also be necessary if we were to implement something like a <code>range</code> function for Monkey hashes, which iterates over keys and values in the hash. Or if we want to add a <code>firstPair</code> function that returns the first key and value of a given hash as an array. Or if we want… You get the drift. Keeping track of keys is highly useful, even though for now only the <code>Inspect()</code> method benefits.</p>
<p>And that’s it! That’s the whole implementation of <code>object.Hash</code>. But there’s a small thing we ought to do while we still have the <code>object</code> package open:</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb453-1" data-line-number="1"><span class="co">// object/object.go</span></a>
<a class="sourceLine" id="cb453-2" data-line-number="2"></a>
<a class="sourceLine" id="cb453-3" data-line-number="3"><span class="kw">type</span> Hashable <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb453-4" data-line-number="4">    HashKey() HashKey</a>
<a class="sourceLine" id="cb453-5" data-line-number="5">}</a></code></pre></div>
<p>We can use this interface in our evaluator to check if the given object is usable as a hash key when we evaluate hash literals or index expressions for hashes.</p>
<p>At the moment it’s only implemented by <code>*object.String</code>, <code>*object.Boolean</code> and <code>*object.Integer</code>.</p>
<p>Granted, there’s one more thing we could do before moving on: we could optimize the performance of the <code>HashKey()</code> methods by caching their return values, but that sounds like a nice exercise for the performance-minded reader.</p>
<h3 id="evaluating-hash-literals">Evaluating Hash Literals</h3>
<p>We’re about to start evaluating hash literals and I’ll be completely honest with you: the hardest part about adding hashes to our interpreter is over. It’s smooth sailing from here on out. So, let’s enjoy the ride, relax and write a test:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb454-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb454-2" data-line-number="2"></a>
<a class="sourceLine" id="cb454-3" data-line-number="3"><span class="kw">func</span> TestHashLiterals(t *testing.T) {</a>
<a class="sourceLine" id="cb454-4" data-line-number="4">    input := <span class="st">`let two = &quot;two&quot;;</span></a>
<a class="sourceLine" id="cb454-5" data-line-number="5"><span class="st">    {</span></a>
<a class="sourceLine" id="cb454-6" data-line-number="6"><span class="st">        &quot;one&quot;: 10 - 9,</span></a>
<a class="sourceLine" id="cb454-7" data-line-number="7"><span class="st">        two: 1 + 1,</span></a>
<a class="sourceLine" id="cb454-8" data-line-number="8"><span class="st">        &quot;thr&quot; + &quot;ee&quot;: 6 / 2,</span></a>
<a class="sourceLine" id="cb454-9" data-line-number="9"><span class="st">        4: 4,</span></a>
<a class="sourceLine" id="cb454-10" data-line-number="10"><span class="st">        true: 5,</span></a>
<a class="sourceLine" id="cb454-11" data-line-number="11"><span class="st">        false: 6</span></a>
<a class="sourceLine" id="cb454-12" data-line-number="12"><span class="st">    }`</span></a>
<a class="sourceLine" id="cb454-13" data-line-number="13"></a>
<a class="sourceLine" id="cb454-14" data-line-number="14">    evaluated := testEval(input)</a>
<a class="sourceLine" id="cb454-15" data-line-number="15">    result, ok := evaluated.(*object.Hash)</a>
<a class="sourceLine" id="cb454-16" data-line-number="16">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb454-17" data-line-number="17">        t.Fatalf(<span class="st">&quot;Eval didn&#39;t return Hash. got=%T (%+v)&quot;</span>, evaluated, evaluated)</a>
<a class="sourceLine" id="cb454-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb454-19" data-line-number="19"></a>
<a class="sourceLine" id="cb454-20" data-line-number="20">    expected := <span class="kw">map</span>[object.HashKey]<span class="dt">int64</span>{</a>
<a class="sourceLine" id="cb454-21" data-line-number="21">        (&amp;object.String{Value: <span class="st">&quot;one&quot;</span>}).HashKey():   <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb454-22" data-line-number="22">        (&amp;object.String{Value: <span class="st">&quot;two&quot;</span>}).HashKey():   <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb454-23" data-line-number="23">        (&amp;object.String{Value: <span class="st">&quot;three&quot;</span>}).HashKey(): <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb454-24" data-line-number="24">        (&amp;object.Integer{Value: <span class="dv">4</span>}).HashKey():      <span class="dv">4</span>,</a>
<a class="sourceLine" id="cb454-25" data-line-number="25">        TRUE.HashKey():                             <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb454-26" data-line-number="26">        FALSE.HashKey():                            <span class="dv">6</span>,</a>
<a class="sourceLine" id="cb454-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb454-28" data-line-number="28"></a>
<a class="sourceLine" id="cb454-29" data-line-number="29">    <span class="kw">if</span> <span class="bu">len</span>(result.Pairs) != <span class="bu">len</span>(expected) {</a>
<a class="sourceLine" id="cb454-30" data-line-number="30">        t.Fatalf(<span class="st">&quot;Hash has wrong num of pairs. got=%d&quot;</span>, <span class="bu">len</span>(result.Pairs))</a>
<a class="sourceLine" id="cb454-31" data-line-number="31">    }</a>
<a class="sourceLine" id="cb454-32" data-line-number="32"></a>
<a class="sourceLine" id="cb454-33" data-line-number="33">    <span class="kw">for</span> expectedKey, expectedValue := <span class="kw">range</span> expected {</a>
<a class="sourceLine" id="cb454-34" data-line-number="34">        pair, ok := result.Pairs[expectedKey]</a>
<a class="sourceLine" id="cb454-35" data-line-number="35">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb454-36" data-line-number="36">            t.Errorf(<span class="st">&quot;no pair for given key in Pairs&quot;</span>)</a>
<a class="sourceLine" id="cb454-37" data-line-number="37">        }</a>
<a class="sourceLine" id="cb454-38" data-line-number="38"></a>
<a class="sourceLine" id="cb454-39" data-line-number="39">        testIntegerObject(t, pair.Value, expectedValue)</a>
<a class="sourceLine" id="cb454-40" data-line-number="40">    }</a>
<a class="sourceLine" id="cb454-41" data-line-number="41">}</a></code></pre></div>
<p>This test function shows what we want from <code>Eval</code> when it encounters a <code>*ast.HashLiteral</code>: a fresh <code>*object.Hash</code> with the correct number of <code>HashPair</code>s mapped to the matching <code>HashKey</code>s in its <code>Pairs</code> attribute.</p>
<p>And it also shows another requirement we have: strings, identifiers, infix operator expressions, booleans and integers - they should all be usable as keys. Any expression really. As long as it produces an <code>object</code> that implements the <code>Hashable</code> interface it should usable as a hash key.</p>
<p>Then there are the values. They can be produced by any expression, too. We test for this here by asserting that <code>10 - 9</code> evaluates to <code>1</code>, <code>6 / 2</code> to <code>3</code> and so on.</p>
<p>As expected the test fails:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb455-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb455-2" data-line-number="2">--- FAIL: TestHashLiterals (0.00s)</a>
<a class="sourceLine" id="cb455-3" data-line-number="3">  evaluator_test.go:522: Eval didn&#39;t return Hash. got=&lt;nil&gt; (&lt;nil&gt;)</a>
<a class="sourceLine" id="cb455-4" data-line-number="4">FAIL</a>
<a class="sourceLine" id="cb455-5" data-line-number="5">FAIL    monkey/evaluator        0.008s</a></code></pre></div>
<p>We know how to get it to pass, though. We need to extend our <code>Eval</code> function with another <code>case</code> branch for <code>*ast.HashLiteral</code>s:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb456-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb456-2" data-line-number="2"></a>
<a class="sourceLine" id="cb456-3" data-line-number="3"><span class="kw">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</a>
<a class="sourceLine" id="cb456-4" data-line-number="4"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb456-5" data-line-number="5"></a>
<a class="sourceLine" id="cb456-6" data-line-number="6">    <span class="kw">case</span> *ast.HashLiteral:</a>
<a class="sourceLine" id="cb456-7" data-line-number="7">        <span class="kw">return</span> evalHashLiteral(node, env)</a>
<a class="sourceLine" id="cb456-8" data-line-number="8"></a>
<a class="sourceLine" id="cb456-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb456-10" data-line-number="10">}</a></code></pre></div>
<p>The <code>evalHashLiteral</code> function here may look intimidating, but trust me, it doesn’t bite:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb457-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb457-2" data-line-number="2"></a>
<a class="sourceLine" id="cb457-3" data-line-number="3"><span class="kw">func</span> evalHashLiteral(</a>
<a class="sourceLine" id="cb457-4" data-line-number="4">    node *ast.HashLiteral,</a>
<a class="sourceLine" id="cb457-5" data-line-number="5">    env *object.Environment,</a>
<a class="sourceLine" id="cb457-6" data-line-number="6">) object.Object {</a>
<a class="sourceLine" id="cb457-7" data-line-number="7">    pairs := <span class="bu">make</span>(<span class="kw">map</span>[object.HashKey]object.HashPair)</a>
<a class="sourceLine" id="cb457-8" data-line-number="8"></a>
<a class="sourceLine" id="cb457-9" data-line-number="9">    <span class="kw">for</span> keyNode, valueNode := <span class="kw">range</span> node.Pairs {</a>
<a class="sourceLine" id="cb457-10" data-line-number="10">        key := Eval(keyNode, env)</a>
<a class="sourceLine" id="cb457-11" data-line-number="11">        <span class="kw">if</span> isError(key) {</a>
<a class="sourceLine" id="cb457-12" data-line-number="12">            <span class="kw">return</span> key</a>
<a class="sourceLine" id="cb457-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb457-14" data-line-number="14"></a>
<a class="sourceLine" id="cb457-15" data-line-number="15">        hashKey, ok := key.(object.Hashable)</a>
<a class="sourceLine" id="cb457-16" data-line-number="16">        <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb457-17" data-line-number="17">            <span class="kw">return</span> newError(<span class="st">&quot;unusable as hash key: %s&quot;</span>, key.Type())</a>
<a class="sourceLine" id="cb457-18" data-line-number="18">        }</a>
<a class="sourceLine" id="cb457-19" data-line-number="19"></a>
<a class="sourceLine" id="cb457-20" data-line-number="20">        value := Eval(valueNode, env)</a>
<a class="sourceLine" id="cb457-21" data-line-number="21">        <span class="kw">if</span> isError(value) {</a>
<a class="sourceLine" id="cb457-22" data-line-number="22">            <span class="kw">return</span> value</a>
<a class="sourceLine" id="cb457-23" data-line-number="23">        }</a>
<a class="sourceLine" id="cb457-24" data-line-number="24"></a>
<a class="sourceLine" id="cb457-25" data-line-number="25">        hashed := hashKey.HashKey()</a>
<a class="sourceLine" id="cb457-26" data-line-number="26">        pairs[hashed] = object.HashPair{Key: key, Value: value}</a>
<a class="sourceLine" id="cb457-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb457-28" data-line-number="28"></a>
<a class="sourceLine" id="cb457-29" data-line-number="29">    <span class="kw">return</span> &amp;object.Hash{Pairs: pairs}</a>
<a class="sourceLine" id="cb457-30" data-line-number="30">}</a></code></pre></div>
<p>When iterating over the <code>node.Pairs</code> the <code>keyNode</code> is the first to be evaluated. Besides checking if the call to <code>Eval</code> produced an error we also make a type assertion about the evaluation result: it needs to implement the <code>object.Hashable</code> interface, otherwise it’s unusable as a hash key. That’s exactly why we added the <code>Hashable</code> definition.</p>
<p>Then we call <code>Eval</code> again, to evaluate <code>valueNode</code>. If that call to <code>Eval</code> also doesn’t produce an error, we can add the newly produced key-value pair to our <code>pairs</code> map. We do this by generating a <code>HashKey</code> for the aptly-named <code>hashKey</code> object with a call to <code>HashKey()</code>. Then we initialize a new <code>HashPair</code>, pointing to both <code>key</code> and <code>value</code> and add it to <code>pairs</code>.</p>
<p>And that’s all it takes. The tests are now passing:</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb458-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb458-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>That means we can already start using hash literals in our REPL:</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb459-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb459-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb459-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb459-4" data-line-number="4">&gt;&gt; {&quot;name&quot;: &quot;Monkey&quot;, &quot;age&quot;: 0, &quot;type&quot;: &quot;Language&quot;, &quot;status&quot;: &quot;awesome&quot;}</a>
<a class="sourceLine" id="cb459-5" data-line-number="5">{age: 0, type: Language, status: awesome, name: Monkey}</a></code></pre></div>
<p>That’s awesome! But we can’t get elements out of the hash yet, which kinda diminishes their usefulness:</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb460-1" data-line-number="1"><span class="op">&gt;&gt;</span> <span class="kw">let</span> bob <span class="op">=</span> <span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">:</span> <span class="st">&quot;Bob&quot;</span><span class="op">,</span> <span class="st">&quot;age&quot;</span><span class="op">:</span> <span class="dv">99</span><span class="op">};</span></a>
<a class="sourceLine" id="cb460-2" data-line-number="2"><span class="op">&gt;&gt;</span> bob[<span class="st">&quot;name&quot;</span>]</a>
<a class="sourceLine" id="cb460-3" data-line-number="3">ERROR<span class="op">:</span> index operator not supported<span class="op">:</span> HASH</a></code></pre></div>
<p>That’s what we’re going to fix now.</p>
<h3 id="evaluating-index-expressions-with-hashes">Evaluating Index Expressions With Hashes</h3>
<p>Remember that switch statement we added to <code>evalIndexExpression</code> in our evaluator? And do you also remember when I told you that we’re going to add another <code>case</code> branch? Well, here we are!</p>
<p>But first of all we need to add a test function that makes sure accessing values in a hash via an index expression works:</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb461-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb461-2" data-line-number="2"></a>
<a class="sourceLine" id="cb461-3" data-line-number="3"><span class="kw">func</span> TestHashIndexExpressions(t *testing.T) {</a>
<a class="sourceLine" id="cb461-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb461-5" data-line-number="5">        input    <span class="dt">string</span></a>
<a class="sourceLine" id="cb461-6" data-line-number="6">        expected <span class="kw">interface</span>{}</a>
<a class="sourceLine" id="cb461-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb461-8" data-line-number="8">        {</a>
<a class="sourceLine" id="cb461-9" data-line-number="9">            <span class="st">`{&quot;foo&quot;: 5}[&quot;foo&quot;]`</span>,</a>
<a class="sourceLine" id="cb461-10" data-line-number="10">            <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb461-11" data-line-number="11">        },</a>
<a class="sourceLine" id="cb461-12" data-line-number="12">        {</a>
<a class="sourceLine" id="cb461-13" data-line-number="13">            <span class="st">`{&quot;foo&quot;: 5}[&quot;bar&quot;]`</span>,</a>
<a class="sourceLine" id="cb461-14" data-line-number="14">            <span class="ot">nil</span>,</a>
<a class="sourceLine" id="cb461-15" data-line-number="15">        },</a>
<a class="sourceLine" id="cb461-16" data-line-number="16">        {</a>
<a class="sourceLine" id="cb461-17" data-line-number="17">            <span class="st">`let key = &quot;foo&quot;; {&quot;foo&quot;: 5}[key]`</span>,</a>
<a class="sourceLine" id="cb461-18" data-line-number="18">            <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb461-19" data-line-number="19">        },</a>
<a class="sourceLine" id="cb461-20" data-line-number="20">        {</a>
<a class="sourceLine" id="cb461-21" data-line-number="21">            <span class="st">`{}[&quot;foo&quot;]`</span>,</a>
<a class="sourceLine" id="cb461-22" data-line-number="22">            <span class="ot">nil</span>,</a>
<a class="sourceLine" id="cb461-23" data-line-number="23">        },</a>
<a class="sourceLine" id="cb461-24" data-line-number="24">        {</a>
<a class="sourceLine" id="cb461-25" data-line-number="25">            <span class="st">`{5: 5}[5]`</span>,</a>
<a class="sourceLine" id="cb461-26" data-line-number="26">            <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb461-27" data-line-number="27">        },</a>
<a class="sourceLine" id="cb461-28" data-line-number="28">        {</a>
<a class="sourceLine" id="cb461-29" data-line-number="29">            <span class="st">`{true: 5}[true]`</span>,</a>
<a class="sourceLine" id="cb461-30" data-line-number="30">            <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb461-31" data-line-number="31">        },</a>
<a class="sourceLine" id="cb461-32" data-line-number="32">        {</a>
<a class="sourceLine" id="cb461-33" data-line-number="33">            <span class="st">`{false: 5}[false]`</span>,</a>
<a class="sourceLine" id="cb461-34" data-line-number="34">            <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb461-35" data-line-number="35">        },</a>
<a class="sourceLine" id="cb461-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb461-37" data-line-number="37"></a>
<a class="sourceLine" id="cb461-38" data-line-number="38">    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</a>
<a class="sourceLine" id="cb461-39" data-line-number="39">        evaluated := testEval(tt.input)</a>
<a class="sourceLine" id="cb461-40" data-line-number="40">        integer, ok := tt.expected.(<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb461-41" data-line-number="41">        <span class="kw">if</span> ok {</a>
<a class="sourceLine" id="cb461-42" data-line-number="42">            testIntegerObject(t, evaluated, <span class="dt">int64</span>(integer))</a>
<a class="sourceLine" id="cb461-43" data-line-number="43">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb461-44" data-line-number="44">            testNullObject(t, evaluated)</a>
<a class="sourceLine" id="cb461-45" data-line-number="45">        }</a>
<a class="sourceLine" id="cb461-46" data-line-number="46">    }</a>
<a class="sourceLine" id="cb461-47" data-line-number="47">}</a></code></pre></div>
<p>Just like in <code>TestArrayIndexExpressions</code> we’re making sure using index operator expressions produces the correct value - only this time with hashes. The different test cases here use string, integer or boolean hash keys when retrieving values out of a hash. So, in essence, what the test really asserts is that the <code>HashKey</code> methods implemented by various data types are called correctly.</p>
<p>And to make sure that using an object as hash key that does not implement <code>object.Hashable</code> produces an error, we can add another test to our <code>TestErrorHandling</code> test function:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb462-1" data-line-number="1"><span class="co">// evaluator/evaluator_test.go</span></a>
<a class="sourceLine" id="cb462-2" data-line-number="2"></a>
<a class="sourceLine" id="cb462-3" data-line-number="3"><span class="kw">func</span> TestErrorHandling(t *testing.T) {</a>
<a class="sourceLine" id="cb462-4" data-line-number="4">    tests := []<span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb462-5" data-line-number="5">        input           <span class="dt">string</span></a>
<a class="sourceLine" id="cb462-6" data-line-number="6">        expectedMessage <span class="dt">string</span></a>
<a class="sourceLine" id="cb462-7" data-line-number="7">    }{</a>
<a class="sourceLine" id="cb462-8" data-line-number="8"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb462-9" data-line-number="9">        {</a>
<a class="sourceLine" id="cb462-10" data-line-number="10">            <span class="st">`{&quot;name&quot;: &quot;Monkey&quot;}[fn(x) { x }];`</span>,</a>
<a class="sourceLine" id="cb462-11" data-line-number="11">            <span class="st">&quot;unusable as hash key: FUNCTION&quot;</span>,</a>
<a class="sourceLine" id="cb462-12" data-line-number="12">        },</a>
<a class="sourceLine" id="cb462-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb462-14" data-line-number="14"></a>
<a class="sourceLine" id="cb462-15" data-line-number="15"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb462-16" data-line-number="16">}</a></code></pre></div>
<p>Running <code>go test</code> now results in the expected failures:</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb463-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb463-2" data-line-number="2">--- FAIL: TestErrorHandling (0.00s)</a>
<a class="sourceLine" id="cb463-3" data-line-number="3">  evaluator_test.go:237: wrong error message.\</a>
<a class="sourceLine" id="cb463-4" data-line-number="4">    expected=&quot;unusable as hash key: FUNCTION&quot;,\</a>
<a class="sourceLine" id="cb463-5" data-line-number="5">    got=&quot;index operator not supported: HASH&quot;</a>
<a class="sourceLine" id="cb463-6" data-line-number="6">--- FAIL: TestHashIndexExpressions (0.00s)</a>
<a class="sourceLine" id="cb463-7" data-line-number="7">  evaluator_test.go:597: object is not Integer.\</a>
<a class="sourceLine" id="cb463-8" data-line-number="8">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-9" data-line-number="9">  evaluator_test.go:625: object is not NULL.\</a>
<a class="sourceLine" id="cb463-10" data-line-number="10">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-11" data-line-number="11">  evaluator_test.go:597: object is not Integer.\</a>
<a class="sourceLine" id="cb463-12" data-line-number="12">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-13" data-line-number="13">  evaluator_test.go:625: object is not NULL.\</a>
<a class="sourceLine" id="cb463-14" data-line-number="14">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-15" data-line-number="15">  evaluator_test.go:597: object is not Integer.\</a>
<a class="sourceLine" id="cb463-16" data-line-number="16">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-17" data-line-number="17">  evaluator_test.go:597: object is not Integer.\</a>
<a class="sourceLine" id="cb463-18" data-line-number="18">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-19" data-line-number="19">  evaluator_test.go:597: object is not Integer.\</a>
<a class="sourceLine" id="cb463-20" data-line-number="20">    got=*object.Error (&amp;{Message:index operator not supported: HASH})</a>
<a class="sourceLine" id="cb463-21" data-line-number="21">FAIL</a>
<a class="sourceLine" id="cb463-22" data-line-number="22">FAIL    monkey/evaluator        0.009s</a></code></pre></div>
<p>That means we’re ready to add another <code>case</code> branch to the switch statement in <code>evalIndexExpression</code>:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb464-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb464-2" data-line-number="2"></a>
<a class="sourceLine" id="cb464-3" data-line-number="3"><span class="kw">func</span> evalIndexExpression(left, index object.Object) object.Object {</a>
<a class="sourceLine" id="cb464-4" data-line-number="4">    <span class="kw">switch</span> {</a>
<a class="sourceLine" id="cb464-5" data-line-number="5">    <span class="kw">case</span> left.Type() == object.ARRAY_OBJ &amp;&amp; index.Type() == object.INTEGER_OBJ:</a>
<a class="sourceLine" id="cb464-6" data-line-number="6">        <span class="kw">return</span> evalArrayIndexExpression(left, index)</a>
<a class="sourceLine" id="cb464-7" data-line-number="7">    <span class="kw">case</span> left.Type() == object.HASH_OBJ:</a>
<a class="sourceLine" id="cb464-8" data-line-number="8">        <span class="kw">return</span> evalHashIndexExpression(left, index)</a>
<a class="sourceLine" id="cb464-9" data-line-number="9">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb464-10" data-line-number="10">        <span class="kw">return</span> newError(<span class="st">&quot;index operator not supported: %s&quot;</span>, left.Type())</a>
<a class="sourceLine" id="cb464-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb464-12" data-line-number="12">}</a></code></pre></div>
<p>The new <code>case</code> branch calls a new function: <code>evalHashIndexExpression</code>. And we already know how <code>evalHashIndexExpression</code> has to work, since we successfully tested the usage of the <code>object.Hashable</code> interface before - in our tests and when evaluating hash literals. So no surprises here:</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb465-1" data-line-number="1"><span class="co">// evaluator/evaluator.go</span></a>
<a class="sourceLine" id="cb465-2" data-line-number="2"></a>
<a class="sourceLine" id="cb465-3" data-line-number="3"><span class="kw">func</span> evalHashIndexExpression(hash, index object.Object) object.Object {</a>
<a class="sourceLine" id="cb465-4" data-line-number="4">    hashObject := hash.(*object.Hash)</a>
<a class="sourceLine" id="cb465-5" data-line-number="5"></a>
<a class="sourceLine" id="cb465-6" data-line-number="6">    key, ok := index.(object.Hashable)</a>
<a class="sourceLine" id="cb465-7" data-line-number="7">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb465-8" data-line-number="8">        <span class="kw">return</span> newError(<span class="st">&quot;unusable as hash key: %s&quot;</span>, index.Type())</a>
<a class="sourceLine" id="cb465-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb465-10" data-line-number="10"></a>
<a class="sourceLine" id="cb465-11" data-line-number="11">    pair, ok := hashObject.Pairs[key.HashKey()]</a>
<a class="sourceLine" id="cb465-12" data-line-number="12">    <span class="kw">if</span> !ok {</a>
<a class="sourceLine" id="cb465-13" data-line-number="13">        <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb465-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb465-15" data-line-number="15"></a>
<a class="sourceLine" id="cb465-16" data-line-number="16">    <span class="kw">return</span> pair.Value</a>
<a class="sourceLine" id="cb465-17" data-line-number="17">}</a></code></pre></div>
<p>Adding <code>evalHashIndexExpression</code> to the switch statement makes the tests pass:</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb466-1" data-line-number="1">$ go test ./evaluator</a>
<a class="sourceLine" id="cb466-2" data-line-number="2">ok      monkey/evaluator        0.007s</a></code></pre></div>
<p>We can now successfully retrieve values from our hashes! Don’t believe me? Think the tests are lying to us? I faked the test output? It can’t be? The whole book is full of li.. what? No, watch this.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb467-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb467-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb467-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb467-4" data-line-number="4">&gt;&gt; let people = [{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 24}, {&quot;name&quot;: &quot;Anna&quot;, &quot;age&quot;: 28}];</a>
<a class="sourceLine" id="cb467-5" data-line-number="5">&gt;&gt; people[0][&quot;name&quot;];</a>
<a class="sourceLine" id="cb467-6" data-line-number="6">Alice</a>
<a class="sourceLine" id="cb467-7" data-line-number="7">&gt;&gt; people[1][&quot;age&quot;];</a>
<a class="sourceLine" id="cb467-8" data-line-number="8">28</a>
<a class="sourceLine" id="cb467-9" data-line-number="9">&gt;&gt; people[1][&quot;age&quot;] + people[0][&quot;age&quot;];</a>
<a class="sourceLine" id="cb467-10" data-line-number="10">52</a>
<a class="sourceLine" id="cb467-11" data-line-number="11">&gt;&gt; let getName = fn(person) { person[&quot;name&quot;]; };</a>
<a class="sourceLine" id="cb467-12" data-line-number="12">&gt;&gt; getName(people[0]);</a>
<a class="sourceLine" id="cb467-13" data-line-number="13">Alice</a>
<a class="sourceLine" id="cb467-14" data-line-number="14">&gt;&gt; getName(people[1]);</a>
<a class="sourceLine" id="cb467-15" data-line-number="15">Anna</a></code></pre></div>
<h2 id="the-grand-finale">4.6 - The Grand Finale</h2>
<p>Our Monkey interpreter is now fully functional. It supports mathematical expressions, variable bindings, functions and the application of those functions, conditionals, return statements and even advanced concepts like higher-order functions and closures. And then there are the different data types: integers, booleans, strings, arrays and hashes. We can be proud of ourselves.</p>
<p>But… and here comes the but… our interpreter still does not pass the most basic of all programming language tests: printing something. Yes, our Monkey interpreter can’t communicate with the outside world. Even programming language scoundrel like Bash and Brainfuck manage to do that. It’s clear what we have to do. We have to add one last built-in function: <code>puts</code>.</p>
<p><code>puts</code> prints the given arguments on new lines to STDOUT. It calls the <code>Inspect()</code> method on the objects passed in as arguments and prints the return value of these calls. The <code>Inspect()</code> method is part of the <code>Object</code> interface, so every entity in our object system supports it. Using <code>puts</code> should look kinda like this:</p>
<div class="sourceCode" id="cb468"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb468-1" data-line-number="1">&gt;&gt; puts(&quot;Hello!&quot;)</a>
<a class="sourceLine" id="cb468-2" data-line-number="2">Hello!</a>
<a class="sourceLine" id="cb468-3" data-line-number="3">&gt;&gt; puts(1234)</a>
<a class="sourceLine" id="cb468-4" data-line-number="4">1234</a>
<a class="sourceLine" id="cb468-5" data-line-number="5">&gt;&gt; puts(fn(x) { x * x })</a>
<a class="sourceLine" id="cb468-6" data-line-number="6">fn(x) {</a>
<a class="sourceLine" id="cb468-7" data-line-number="7">(x * x)</a>
<a class="sourceLine" id="cb468-8" data-line-number="8">}</a></code></pre></div>
<p>And <code>puts</code> is a variadic function. It takes an unlimited number of arguments and prints each on a separate line:</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb469-1" data-line-number="1">&gt;&gt; puts(&quot;hello&quot;, &quot;world&quot;, &quot;how&quot;, &quot;are&quot;, &quot;you&quot;)</a>
<a class="sourceLine" id="cb469-2" data-line-number="2">hello</a>
<a class="sourceLine" id="cb469-3" data-line-number="3">world</a>
<a class="sourceLine" id="cb469-4" data-line-number="4">how</a>
<a class="sourceLine" id="cb469-5" data-line-number="5">are</a>
<a class="sourceLine" id="cb469-6" data-line-number="6">you</a></code></pre></div>
<p>Of course, <code>puts</code> is all about printing things and not producing a value, so we need to make sure that it returns <code>NULL</code>:</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb470-1" data-line-number="1">&gt;&gt; let putsReturnValue = puts(&quot;foobar&quot;);</a>
<a class="sourceLine" id="cb470-2" data-line-number="2">foobar</a>
<a class="sourceLine" id="cb470-3" data-line-number="3">&gt;&gt; putsReturnValue</a>
<a class="sourceLine" id="cb470-4" data-line-number="4">null</a></code></pre></div>
<p>That also means that our REPL will print the <code>null</code> in addition to the output we expect from <code>puts</code>. So it will look like this:</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb471-1" data-line-number="1">&gt;&gt; puts(&quot;Hello!&quot;)</a>
<a class="sourceLine" id="cb471-2" data-line-number="2">Hello!</a>
<a class="sourceLine" id="cb471-3" data-line-number="3">null</a></code></pre></div>
<p>Now that’s more than enough information and specification to complete this last quest of ours. Are you ready?</p>
<p>Here it is, here’s what this section has been building up to, here is the complete, working implementation of <code>puts</code>:</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb472-1" data-line-number="1"><span class="co">// evaluator/builtins.go</span></a>
<a class="sourceLine" id="cb472-2" data-line-number="2"></a>
<a class="sourceLine" id="cb472-3" data-line-number="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb472-4" data-line-number="4">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb472-5" data-line-number="5">    <span class="st">&quot;monkey/object&quot;</span></a>
<a class="sourceLine" id="cb472-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb472-7" data-line-number="7"></a>
<a class="sourceLine" id="cb472-8" data-line-number="8"><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</a>
<a class="sourceLine" id="cb472-9" data-line-number="9"><span class="co">// [...]</span></a>
<a class="sourceLine" id="cb472-10" data-line-number="10">    <span class="st">&quot;puts&quot;</span>: &amp;object.Builtin{</a>
<a class="sourceLine" id="cb472-11" data-line-number="11">        Fn: <span class="kw">func</span>(args ...object.Object) object.Object {</a>
<a class="sourceLine" id="cb472-12" data-line-number="12">            <span class="kw">for</span> _, arg := <span class="kw">range</span> args {</a>
<a class="sourceLine" id="cb472-13" data-line-number="13">                fmt.Println(arg.Inspect())</a>
<a class="sourceLine" id="cb472-14" data-line-number="14">            }</a>
<a class="sourceLine" id="cb472-15" data-line-number="15"></a>
<a class="sourceLine" id="cb472-16" data-line-number="16">            <span class="kw">return</span> NULL</a>
<a class="sourceLine" id="cb472-17" data-line-number="17">        },</a>
<a class="sourceLine" id="cb472-18" data-line-number="18">    },</a>
<a class="sourceLine" id="cb472-19" data-line-number="19">}</a></code></pre></div>
<p>And with that, we did it. We’re done. Even if you were wary of our little celebrations and shrugged them off before, now’s the time to go looking for a funny party hat and put it on.</p>
<p>In chapter three we brought the Monkey programming language to life. It started to breathe. With our last change, we made it talk. Now, Monkey is finally a real programming language:</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode changelog"><code class="sourceCode changelog"><a class="sourceLine" id="cb473-1" data-line-number="1">$ go run main.go</a>
<a class="sourceLine" id="cb473-2" data-line-number="2">Hello mrnugget! This is the Monkey programming language!</a>
<a class="sourceLine" id="cb473-3" data-line-number="3">Feel free to type in commands</a>
<a class="sourceLine" id="cb473-4" data-line-number="4">&gt;&gt; puts(&quot;Hello World!&quot;)</a>
<a class="sourceLine" id="cb473-5" data-line-number="5">Hello World!</a>
<a class="sourceLine" id="cb473-6" data-line-number="6">null</a>
<a class="sourceLine" id="cb473-7" data-line-number="7">&gt;&gt;</a></code></pre></div>
<h1 id="going-further" class="unnumbered">Going Further</h1>
<h2 id="the-lost-chapter">The Lost Chapter</h2>
<figure>
<img src="./images/lost_chapter_cover.png" alt=" " width="150" /><figcaption> </figcaption>
</figure>
<p>Nearly half a year after publishing the first version of <em>Writing An Interpreter In Go</em>, I decided to add another chapter. It’s called <em>The Lost Chapter: A Macro System For Monkey</em> and available for free. You can read or download it as an eBook at <a href="https://interpreterbook.com/lost" class="uri">https://interpreterbook.com/lost</a>.</p>
<h2 id="writing-a-compiler-in-go">Writing A Compiler In Go</h2>
<figure>
<img src="./images/wacig_cover.png" alt=" " width="150" /><figcaption> </figcaption>
</figure>
<p><em>Writing A Compiler In Go</em> is the sequel to <em>Writing An Interpreter In Go</em> and contains the next step in Monkey’s evolution: a bytecode compiler and a virtual machine. It’s the same codebase and the same approach, the books connect seamlessly, except that Monkey ends up being 3 times faster.</p>
<p>You find out more about it and buy it at <a href="https://compilerbook.com" class="uri">https://compilerbook.com</a>.</p>
<h1 id="resources" class="unnumbered">Resources</h1>
<h4 id="books">Books</h4>
<ul>
<li>Abelson, Harold and Sussman, Gerald Jay with Sussman, Julie. 1996. <strong>Structure and Interpretation of Computer Programs, Second Edition</strong>. MIT Press.</li>
<li>Appel, Andrew W.. 2004. <strong>Modern Compiler Implementation in C</strong>. Cambridge University Press.</li>
<li>Cooper, Keith D. and Torczon Linda. 2011. <strong>Engineering a Compiler, Second Edition</strong>. Morgan Kaufmann.</li>
<li>Grune, Dick and Jacobs, Ceriel. 1990. <strong>Parsing Techniques. A Practical Guide.</strong>. Ellis Horwood Limited.</li>
<li>Grune, Dick and van Reeuwijk, Kees and Bal Henri E. and Jacobs, Ceriel J.H. Jacobs and Langendoen, Koen. 2012. <strong>Modern Compiler Design, Second Edition</strong>. Springer</li>
<li>Nisan, Noam and Schocken, Shimon. 2008. <strong>The Elements Of Computing Systems</strong>. MIT Press.</li>
</ul>
<h4 id="papers">Papers</h4>
<ul>
<li>Ayock, John. 2003. <strong>A Brief History of Just-In-Time</strong>. In <strong>ACM Computing Surveys, Vol. 35, No. 2, June 2003</strong></li>
<li>Ertl, M. Anton and Gregg, David. 2003. <strong>The Structure and Performance of Efficient Interpreters</strong>. In <strong>Journal Of Instruction-Level Parallelism 5 (2003)</strong></li>
<li>Ghuloum, Abdulaziz. 2006. <strong>An Incremental Approach To Compiler Construction</strong>. In <strong>Proceedings of the 2006 Scheme and Functional Programming Workshop</strong>.</li>
<li>Ierusalimschy, Robert and de Figueiredo, Luiz Henrique and Celes Waldemar. <strong>The Implementation of Lua 5.0</strong>. <a href="https://www.lua.org/doc/jucs05.pdf" class="uri">https://www.lua.org/doc/jucs05.pdf</a></li>
<li>Pratt, Vaughan R. 1973. <strong>Top Down Operator Precedence</strong>. Massachusetts Institute of Technology.</li>
<li>Romer, Theodore H. and Lee, Dennis and Voelker, Geoffrey M. and Wolman, Alec and Wong, Wayne A. and Baer, Jean-Loup and Bershad, Brian N. and Levy, Henry M.. 1996. <strong>The Structure and Performance of Interpreters</strong>. In <strong>ASPLOS VII Proceedings of the seventh international conference on Architectural support for programming languages and operating systems</strong>.</li>
<li>Dybvig, R. Kent. 2006. <strong>The Development of Chez Scheme</strong>. In <strong>ACM ICFP ’06</strong></li>
</ul>
<h4 id="web">Web</h4>
<ul>
<li>Jack W. Crenshaw - Let’s Build a Compiler! - <a href="http://compilers.iecc.com/crenshaw/tutorfinal.pdf" class="uri">http://compilers.iecc.com/crenshaw/tutorfinal.pdf</a></li>
<li>Douglas Crockford - Top Down Operator Precedence - <a href="http://javascript.crockford.com/tdop/tdop.html" class="uri">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li>Bob Nystrom - Expression Parsing Made Easy - <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/" class="uri">http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/</a></li>
<li>Shriram Krishnamurthi and Joe Gibbs Politz - Programming Languages: Application and Interpretation - <a href="http://papl.cs.brown.edu/2015/" class="uri">http://papl.cs.brown.edu/2015/</a></li>
<li>A Python Interpreter Written In Python - <a href="http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html" class="uri">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></li>
<li>Dr. Dobbs - Bob: A Tiny Object-Oriented Language - <a href="http://www.drdobbs.com/open-source/bob-a-tiny-object-oriented-language/184409401" class="uri">http://www.drdobbs.com/open-source/bob-a-tiny-object-oriented-language/184409401</a></li>
<li>Nick Desaulniers - Interpreter, Compiler, JIT - <a href="https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/" class="uri">https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/</a></li>
<li>Peter Norvig - (How to Write a (Lisp) Interpreter (in Python)) - <a href="http://norvig.com/lispy.html" class="uri">http://norvig.com/lispy.html</a></li>
<li>Fredrik Lundh - Simple Town-Down Parsing In Python - <a href="http://effbot.org/zone/simple-top-down-parsing.htm" class="uri">http://effbot.org/zone/simple-top-down-parsing.htm</a></li>
<li>Mihai Bazon - How to implement a programming language in JavaScript - <a href="http://lisperator.net/pltut/" class="uri">http://lisperator.net/pltut/</a></li>
<li>Mary Rose Cook - Little Lisp interpreter - <a href="https://www.recurse.com/blog/21-little-lisp-interpreter" class="uri">https://www.recurse.com/blog/21-little-lisp-interpreter</a></li>
<li>Peter Michaux - Scheme From Scratch - <a href="http://peter.michaux.ca/articles/scheme-from-scratch-introduction" class="uri">http://peter.michaux.ca/articles/scheme-from-scratch-introduction</a></li>
<li>Make a Lisp - <a href="https://github.com/kanaka/mal" class="uri">https://github.com/kanaka/mal</a></li>
<li>Matt Might - Compiling Scheme to C with closure conversion - <a href="http://matt.might.net/articles/compiling-scheme-to-c/" class="uri">http://matt.might.net/articles/compiling-scheme-to-c/</a></li>
<li>Rob Pike - Implementing a bignum calculator - <a href="https://www.youtube.com/watch?v=PXoG0WX0r_E" class="uri">https://www.youtube.com/watch?v=PXoG0WX0r_E</a></li>
<li>Rob Pike - Lexical Scanning in Go - <a href="https://www.youtube.com/watch?v=HxaD_trXwRE" class="uri">https://www.youtube.com/watch?v=HxaD_trXwRE</a></li>
</ul>
<h4 id="source-code">Source Code</h4>
<ul>
<li>The Wren Programming Language - <a href="https://github.com/munificent/wren" class="uri">https://github.com/munificent/wren</a></li>
<li>Otto - A JavaScript Interpreter In Go - <a href="https://github.com/robertkrimen/otto" class="uri">https://github.com/robertkrimen/otto</a></li>
<li>The Go Programming Language - <a href="https://github.com/golang/go" class="uri">https://github.com/golang/go</a></li>
<li>The Lua Programming Language (1.1, 3.1, 5.3.2) - <a href="https://www.lua.org/versions.html" class="uri">https://www.lua.org/versions.html</a></li>
<li>The Ruby Programming Language - <a href="https://github.com/ruby/ruby" class="uri">https://github.com/ruby/ruby</a></li>
<li>c4 - C in four functions - <a href="https://github.com/rswier/c4" class="uri">https://github.com/rswier/c4</a></li>
<li>tcc - Tiny C Compiler - <a href="https://github.com/LuaDist/tcc" class="uri">https://github.com/LuaDist/tcc</a></li>
<li>8cc - A Small C Compiler - <a href="https://github.com/rui314/8cc" class="uri">https://github.com/rui314/8cc</a></li>
<li>Fedjmike/mini-c - <a href="https://github.com/Fedjmike/mini-c" class="uri">https://github.com/Fedjmike/mini-c</a></li>
<li>thejameskyle/the-super-tiny-compiler - <a href="https://github.com/thejameskyle/the-super-tiny-compiler" class="uri">https://github.com/thejameskyle/the-super-tiny-compiler</a></li>
<li>lisp.c - <a href="https://gist.github.com/sanxiyn/523967" class="uri">https://gist.github.com/sanxiyn/523967</a></li>
</ul>
<h1 id="feedback" class="unnumbered">Feedback</h1>
<p>If you spot a typo, find something wrong with the code, have a suggestion to make or just a question, feel free to send me an email:</p>
<p><strong>me@thorstenball.com</strong></p>
<h1 id="changelog" class="unnumbered">Changelog</h1>
<h4 id="july-2018---1.5">31 July 2018 - 1.5</h4>
<p>Besides fixes for various typos and spelling errors:</p>
<ul>
<li>Chapter 2:
<ul>
<li>Fix wrong mention of <code>program.Body</code> in test error messages and change it to <code>program.Statements</code></li>
</ul></li>
<li>Section 1.3:
<ul>
<li>Make it clearer where to put <code>import &quot;monkey/token&quot;</code> line</li>
</ul></li>
<li>Section 2.4:
<ul>
<li>Fix wrong error message in <code>testLetStatement</code> helper function</li>
<li>Fix wrong indentation of <code>input</code> in test function</li>
<li>Fix missing imports of <code>fmt</code> package</li>
</ul></li>
<li>Section 2.5:
<ul>
<li>Fix wrong mention of <code>ParseProgram</code> instead of the correct <code>parseStatement</code></li>
</ul></li>
<li>Section 2.6:
<ul>
<li>Fix wrong explanation of failing test output in prefix operators section</li>
<li>Fix wrong explanation of the for-loop condition in <code>parseExpression</code></li>
<li>Rename local variable <code>oe</code> to <code>ie</code> in <code>*ast.InfixExpression</code> methods</li>
</ul></li>
<li>Section 2.8:
<ul>
<li>Change post-refactoring version of <code>TestParsingInfixExpressions</code> to make clearer that it has been refactored</li>
<li>Fix wrong error message in <code>testInfixExpression</code></li>
<li>Fix wrong output in test error message (“true” to “TRUE”)</li>
<li>Add missing import of <code>strings</code> package</li>
<li>Change wording to make clearer that the section includes changes to the existing test suite</li>
</ul></li>
<li>Section 2.9:
<ul>
<li>Add the missing <code>import</code> of <code>monkey/parser</code> to the REPL code</li>
</ul></li>
<li>Section 3.5:
<ul>
<li>Fix wrong error message in failing test output for <code>TestEvalBooleanExpression</code></li>
</ul></li>
<li>Section 3.8:
<ul>
<li>Add missing import of <code>fmt</code></li>
</ul></li>
<li>Section 3.10:
<ul>
<li>Add missing import</li>
</ul></li>
<li>Chapter 4:
<ul>
<li>Remove unused import of <code>unicode/utf8</code> package</li>
</ul></li>
<li>Section 4.5:
<ul>
<li>Add note about hash collisions when explaining the <code>HashKey</code> methods</li>
<li>Fix wrong failing test output after adding a test to <code>TestErrorHandling</code></li>
</ul></li>
<li>Going Further:
<ul>
<li>Add link to the sequel <em>Writing A Compiler In Go</em>.</li>
</ul></li>
</ul>
<h4 id="june-2017---1.4">28 June 2017 - 1.4</h4>
<ul>
<li>Section 1.4:
<ul>
<li>Use a local variable to save the <code>literal</code> when creating <code>token.EQ</code> and <code>token.NOT_EQ</code></li>
</ul></li>
<li>Section 2.3:
<ul>
<li>Fix a small typo</li>
</ul></li>
<li>Section 2.4:
<ul>
<li>Change incorrect mention of <code>peekPosition</code> in lexer to correct <code>readPosition</code></li>
</ul></li>
<li>Section 2.6:
<ul>
<li>Fix duplicate test input in <code>TestOperatorPrecedenceParsing</code> here and in the following sections where it’s referenced</li>
</ul></li>
<li>Section 3.9:
<ul>
<li>In the first example the expression <code>5 * 5</code> was used and the text explained that this should evaluate to <code>10</code>, which is wrong. It should evaluate to <code>25</code>, of course.</li>
</ul></li>
<li>The Lost Chapter:
<ul>
<li>Added a new section at the end of the book about <em>The Lost Chapter: A Macro System For Monkey</em> and where it can be found.</li>
</ul></li>
</ul>
<h4 id="january-2017---1.3">26 January 2017 - 1.3</h4>
<ul>
<li>License of the code:
<ul>
<li>The <code>code</code> folder and its content are now licensed under the MIT license. See the <code>LICENSE</code> file and/or the <code>README.md</code> file.</li>
</ul></li>
<li>Section 1.1:
<ul>
<li>Make clear that whitespace is only significant in the sense that it separates tokens, but not its length.</li>
</ul></li>
<li>Section 1.3:
<ul>
<li>Small wording change</li>
<li>Fix wrong reference to <code>NextToken</code> when <code>readChar</code> was meant</li>
</ul></li>
<li>Section 2.8:
<ul>
<li>Fix the <code>parseBlockStatement</code> method so it doesn’t run into an endless loop when parsing incomplete input</li>
</ul></li>
<li>Section 4.2:
<ul>
<li>Fix the <code>readString</code> method so it doesn’t run into an endless loop when a string in the input is not terminated with a closing double quote</li>
</ul></li>
<li>Section 4.4:
<ul>
<li>Fix a typo in the error message of the builtin <code>push</code> function</li>
</ul></li>
</ul>
<h4 id="december-2016---1.2">20 December 2016 - 1.2</h4>
<ul>
<li>Section 2.8:
<ul>
<li>Add a missing semicolon to the test input in <code>TestLetStatements</code></li>
</ul></li>
<li>Section 4.4:
<ul>
<li>Fix the failing test for the builtin <code>push</code> function. Error was introduced with the last update. This change only occurrs in the code accompanying the book and only in subfolder <code>04</code>.</li>
</ul></li>
</ul>
<h4 id="december-2016---1.1">8 December 2016 - 1.1</h4>
<p>Besides fixed typos and spelling errors:</p>
<ul>
<li>Introduction
<ul>
<li>Change the “How To Use This Book” subsection to include a link to the downloadable archive of the accompanying code</li>
</ul></li>
<li>Section 1.4:
<ul>
<li>Add hint about accompanying code</li>
<li>Show the last, fully extended version of the test <code>input</code> for <code>TestNextToken</code></li>
</ul></li>
<li>Section 2.6:
<ul>
<li>The failing test output for <code>TestParsingPrefixExpressions</code> in the book text was wrong. It’s corrected to match the actual output one gets when building the parser from scratch</li>
<li>Fix wording that didn’t match the described test output</li>
<li>Remove <code>token.LPAREN</code> from the <code>precedences</code> table here. It somehow slipped in at this point, but should only be added later on in section 2.8, where tests are supposed to fail because it’s missing</li>
</ul></li>
<li>Section 2.8:
<ul>
<li>Fix wrong test expectation (<code>&quot;x&quot;</code> changed to <code>&quot;y&quot;</code>) in <code>TestLetStatement</code></li>
<li>Change <code>parser_parser_test.go</code> to <code>parser_test.go</code></li>
<li>Better show how to use <code>testLiteralExpression</code> in <code>TestParsingInfixExpressions</code></li>
<li>Fix outdated test output for failing <code>TestOperatorPrecedenceParsing</code>, <code>TestIfExpression</code>, <code>TestIfElseExpression</code>, <code>TestFunctionLiteralParsing</code></li>
</ul></li>
<li>Section 3.10:
<ul>
<li>Change the <code>Inspect()</code> method of <code>*object.Function</code> to use <code>fn</code> instead of <code>function</code> and newlines in output</li>
<li>Remove needless semicolons in example</li>
</ul></li>
<li>Section 3.5:
<ul>
<li>Change from if/else to “if and return” in <code>nativeBoolToBooleanObject</code></li>
</ul></li>
<li>Section 3.6:
<ul>
<li>Update the version of <code>testNullObject</code> to be the one in the accompanying code, with a correct call to <code>t.Errorf</code></li>
</ul></li>
<li>Section 4.4:
<ul>
<li>Name the <code>token.Token</code> field of <code>ast.ArrayLiteral</code></li>
<li>Fix possible panic through nil error in “first”, “last”, “rest”, and “push” functions by adding separate check</li>
</ul></li>
<li>Section 4.5:
<ul>
<li>Name the <code>token.Token</code> field of <code>ast.HashLiteral</code></li>
<li>Replace <code>null</code> in output with missing error message when trying to access hash via index expression before it’s implemented</li>
</ul></li>
<li>Section 4.6:
<ul>
<li>Change the expected output using <code>puts</code> with a function literal to match the updated <code>Inspect()</code> of <code>*object.Function</code></li>
<li>Explain the <code>null</code>s in the expected output of <code>put</code> better</li>
</ul></li>
</ul>
<h4 id="november-2016---1.0">23 November 2016 - 1.0</h4>
<ul>
<li>Initial Release</li>
</ul>

      </body>
</html>
